/*! For license information please see bundle.js.LICENSE.txt */
!function (t, e) { if ("object" == typeof exports && "object" == typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { var n = e(); for (var r in n) ("object" == typeof exports ? exports : t)[r] = n[r] } }(self, (function () { return function () { var t = { 9662: function (t, e, n) { var r = n(614), i = n(6330), a = TypeError; t.exports = function (t) { if (r(t)) return t; throw a(i(t) + " is not a function") } }, 9483: function (t, e, n) { var r = n(4411), i = n(6330), a = TypeError; t.exports = function (t) { if (r(t)) return t; throw a(i(t) + " is not a constructor") } }, 6077: function (t, e, n) { var r = n(614), i = String, a = TypeError; t.exports = function (t) { if ("object" == typeof t || r(t)) return t; throw a("Can't set " + i(t) + " as a prototype") } }, 1223: function (t, e, n) { var r = n(5112), i = n(30), a = n(3070).f, o = r("unscopables"), s = Array.prototype; null == s[o] && a(s, o, { configurable: !0, value: i(null) }), t.exports = function (t) { s[o][t] = !0 } }, 5787: function (t, e, n) { var r = n(7976), i = TypeError; t.exports = function (t, e) { if (r(e, t)) return t; throw i("Incorrect invocation") } }, 9670: function (t, e, n) { var r = n(111), i = String, a = TypeError; t.exports = function (t) { if (r(t)) return t; throw a(i(t) + " is not an object") } }, 3013: function (t) { t.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView }, 260: function (t, e, n) { "use strict"; var r, i, a, o = n(3013), s = n(9781), l = n(7854), c = n(614), u = n(111), h = n(2597), d = n(648), f = n(6330), p = n(8880), m = n(8052), g = n(3070).f, v = n(7976), _ = n(9518), y = n(7674), x = n(5112), b = n(9711), M = n(9909), w = M.enforce, S = M.get, T = l.Int8Array, E = T && T.prototype, A = l.Uint8ClampedArray, C = A && A.prototype, L = T && _(T), P = E && _(E), R = Object.prototype, D = l.TypeError, I = x("toStringTag"), O = b("TYPED_ARRAY_TAG"), N = o && !!y && "Opera" !== d(l.opera), z = !1, F = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, U = { BigInt64Array: 8, BigUint64Array: 8 }, k = function (t) { var e = _(t); if (u(e)) { var n = S(e); return n && h(n, "TypedArrayConstructor") ? n.TypedArrayConstructor : k(e) } }, B = function (t) { if (!u(t)) return !1; var e = d(t); return h(F, e) || h(U, e) }; for (r in F) (a = (i = l[r]) && i.prototype) ? w(a).TypedArrayConstructor = i : N = !1; for (r in U) (a = (i = l[r]) && i.prototype) && (w(a).TypedArrayConstructor = i); if ((!N || !c(L) || L === Function.prototype) && (L = function () { throw D("Incorrect invocation") }, N)) for (r in F) l[r] && y(l[r], L); if ((!N || !P || P === R) && (P = L.prototype, N)) for (r in F) l[r] && y(l[r].prototype, P); if (N && _(C) !== P && y(C, P), s && !h(P, I)) for (r in z = !0, g(P, I, { get: function () { return u(this) ? this[O] : void 0 } }), F) l[r] && p(l[r], O, r); t.exports = { NATIVE_ARRAY_BUFFER_VIEWS: N, TYPED_ARRAY_TAG: z && O, aTypedArray: function (t) { if (B(t)) return t; throw D("Target is not a typed array") }, aTypedArrayConstructor: function (t) { if (c(t) && (!y || v(L, t))) return t; throw D(f(t) + " is not a typed array constructor") }, exportTypedArrayMethod: function (t, e, n, r) { if (s) { if (n) for (var i in F) { var a = l[i]; if (a && h(a.prototype, t)) try { delete a.prototype[t] } catch (n) { try { a.prototype[t] = e } catch (t) { } } } P[t] && !n || m(P, t, n ? e : N && E[t] || e, r) } }, exportTypedArrayStaticMethod: function (t, e, n) { var r, i; if (s) { if (y) { if (n) for (r in F) if ((i = l[r]) && h(i, t)) try { delete i[t] } catch (t) { } if (L[t] && !n) return; try { return m(L, t, n ? e : N && L[t] || e) } catch (t) { } } for (r in F) !(i = l[r]) || i[t] && !n || m(i, t, e) } }, getTypedArrayConstructor: k, isView: function (t) { if (!u(t)) return !1; var e = d(t); return "DataView" === e || h(F, e) || h(U, e) }, isTypedArray: B, TypedArray: L, TypedArrayPrototype: P } }, 3331: function (t, e, n) { "use strict"; var r = n(7854), i = n(1702), a = n(9781), o = n(3013), s = n(6530), l = n(8880), c = n(9190), u = n(7293), h = n(5787), d = n(9303), f = n(7466), p = n(7067), m = n(1179), g = n(9518), v = n(7674), _ = n(8006).f, y = n(3070).f, x = n(1285), b = n(1589), M = n(8003), w = n(9909), S = s.PROPER, T = s.CONFIGURABLE, E = w.get, A = w.set, C = "ArrayBuffer", L = "Wrong index", P = r.ArrayBuffer, R = P, D = R && R.prototype, I = r.DataView, O = I && I.prototype, N = Object.prototype, z = r.Array, F = r.RangeError, U = i(x), k = i([].reverse), B = m.pack, V = m.unpack, G = function (t) { return [255 & t] }, H = function (t) { return [255 & t, t >> 8 & 255] }, W = function (t) { return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255] }, j = function (t) { return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0] }, q = function (t) { return B(t, 23, 4) }, X = function (t) { return B(t, 52, 8) }, Y = function (t, e) { y(t.prototype, e, { get: function () { return E(this)[e] } }) }, Z = function (t, e, n, r) { var i = p(n), a = E(t); if (i + e > a.byteLength) throw F(L); var o = E(a.buffer).bytes, s = i + a.byteOffset, l = b(o, s, s + e); return r ? l : k(l) }, K = function (t, e, n, r, i, a) { var o = p(n), s = E(t); if (o + e > s.byteLength) throw F(L); for (var l = E(s.buffer).bytes, c = o + s.byteOffset, u = r(+i), h = 0; h < e; h++)l[c + h] = u[a ? h : e - h - 1] }; if (o) { var J = S && P.name !== C; if (u((function () { P(1) })) && u((function () { new P(-1) })) && !u((function () { return new P, new P(1.5), new P(NaN), 1 != P.length || J && !T }))) J && T && l(P, "name", C); else { (R = function (t) { return h(this, D), new P(p(t)) }).prototype = D; for (var Q, $ = _(P), tt = 0; $.length > tt;)(Q = $[tt++]) in R || l(R, Q, P[Q]); D.constructor = R } v && g(O) !== N && v(O, N); var et = new I(new R(2)), nt = i(O.setInt8); et.setInt8(0, 2147483648), et.setInt8(1, 2147483649), !et.getInt8(0) && et.getInt8(1) || c(O, { setInt8: function (t, e) { nt(this, t, e << 24 >> 24) }, setUint8: function (t, e) { nt(this, t, e << 24 >> 24) } }, { unsafe: !0 }) } else D = (R = function (t) { h(this, D); var e = p(t); A(this, { bytes: U(z(e), 0), byteLength: e }), a || (this.byteLength = e) }).prototype, O = (I = function (t, e, n) { h(this, O), h(t, D); var r = E(t).byteLength, i = d(e); if (i < 0 || i > r) throw F("Wrong offset"); if (i + (n = void 0 === n ? r - i : f(n)) > r) throw F("Wrong length"); A(this, { buffer: t, byteLength: n, byteOffset: i }), a || (this.buffer = t, this.byteLength = n, this.byteOffset = i) }).prototype, a && (Y(R, "byteLength"), Y(I, "buffer"), Y(I, "byteLength"), Y(I, "byteOffset")), c(O, { getInt8: function (t) { return Z(this, 1, t)[0] << 24 >> 24 }, getUint8: function (t) { return Z(this, 1, t)[0] }, getInt16: function (t) { var e = Z(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return (e[1] << 8 | e[0]) << 16 >> 16 }, getUint16: function (t) { var e = Z(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return e[1] << 8 | e[0] }, getInt32: function (t) { return j(Z(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) }, getUint32: function (t) { return j(Z(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) >>> 0 }, getFloat32: function (t) { return V(Z(this, 4, t, arguments.length > 1 ? arguments[1] : void 0), 23) }, getFloat64: function (t) { return V(Z(this, 8, t, arguments.length > 1 ? arguments[1] : void 0), 52) }, setInt8: function (t, e) { K(this, 1, t, G, e) }, setUint8: function (t, e) { K(this, 1, t, G, e) }, setInt16: function (t, e) { K(this, 2, t, H, e, arguments.length > 2 ? arguments[2] : void 0) }, setUint16: function (t, e) { K(this, 2, t, H, e, arguments.length > 2 ? arguments[2] : void 0) }, setInt32: function (t, e) { K(this, 4, t, W, e, arguments.length > 2 ? arguments[2] : void 0) }, setUint32: function (t, e) { K(this, 4, t, W, e, arguments.length > 2 ? arguments[2] : void 0) }, setFloat32: function (t, e) { K(this, 4, t, q, e, arguments.length > 2 ? arguments[2] : void 0) }, setFloat64: function (t, e) { K(this, 8, t, X, e, arguments.length > 2 ? arguments[2] : void 0) } }); M(R, C), M(I, "DataView"), t.exports = { ArrayBuffer: R, DataView: I } }, 1048: function (t, e, n) { "use strict"; var r = n(7908), i = n(1400), a = n(6244), o = n(5117), s = Math.min; t.exports = [].copyWithin || function (t, e) { var n = r(this), l = a(n), c = i(t, l), u = i(e, l), h = arguments.length > 2 ? arguments[2] : void 0, d = s((void 0 === h ? l : i(h, l)) - u, l - c), f = 1; for (u < c && c < u + d && (f = -1, u += d - 1, c += d - 1); d-- > 0;)u in n ? n[c] = n[u] : o(n, c), c += f, u += f; return n } }, 1285: function (t, e, n) { "use strict"; var r = n(7908), i = n(1400), a = n(6244); t.exports = function (t) { for (var e = r(this), n = a(e), o = arguments.length, s = i(o > 1 ? arguments[1] : void 0, n), l = o > 2 ? arguments[2] : void 0, c = void 0 === l ? n : i(l, n); c > s;)e[s++] = t; return e } }, 8533: function (t, e, n) { "use strict"; var r = n(2092).forEach, i = n(9341)("forEach"); t.exports = i ? [].forEach : function (t) { return r(this, t, arguments.length > 1 ? arguments[1] : void 0) } }, 7745: function (t, e, n) { var r = n(6244); t.exports = function (t, e) { for (var n = 0, i = r(e), a = new t(i); i > n;)a[n] = e[n++]; return a } }, 1318: function (t, e, n) { var r = n(5656), i = n(1400), a = n(6244), o = function (t) { return function (e, n, o) { var s, l = r(e), c = a(l), u = i(o, c); if (t && n != n) { for (; c > u;)if ((s = l[u++]) != s) return !0 } else for (; c > u; u++)if ((t || u in l) && l[u] === n) return t || u || 0; return !t && -1 } }; t.exports = { includes: o(!0), indexOf: o(!1) } }, 2092: function (t, e, n) { var r = n(9974), i = n(1702), a = n(8361), o = n(7908), s = n(6244), l = n(5417), c = i([].push), u = function (t) { var e = 1 == t, n = 2 == t, i = 3 == t, u = 4 == t, h = 6 == t, d = 7 == t, f = 5 == t || h; return function (p, m, g, v) { for (var _, y, x = o(p), b = a(x), M = r(m, g), w = s(b), S = 0, T = v || l, E = e ? T(p, w) : n || d ? T(p, 0) : void 0; w > S; S++)if ((f || S in b) && (y = M(_ = b[S], S, x), t)) if (e) E[S] = y; else if (y) switch (t) { case 3: return !0; case 5: return _; case 6: return S; case 2: c(E, _) } else switch (t) { case 4: return !1; case 7: c(E, _) }return h ? -1 : i || u ? u : E } }; t.exports = { forEach: u(0), map: u(1), filter: u(2), some: u(3), every: u(4), find: u(5), findIndex: u(6), filterReject: u(7) } }, 6583: function (t, e, n) { "use strict"; var r = n(2104), i = n(5656), a = n(9303), o = n(6244), s = n(9341), l = Math.min, c = [].lastIndexOf, u = !!c && 1 / [1].lastIndexOf(1, -0) < 0, h = s("lastIndexOf"), d = u || !h; t.exports = d ? function (t) { if (u) return r(c, this, arguments) || 0; var e = i(this), n = o(e), s = n - 1; for (arguments.length > 1 && (s = l(s, a(arguments[1]))), s < 0 && (s = n + s); s >= 0; s--)if (s in e && e[s] === t) return s || 0; return -1 } : c }, 1194: function (t, e, n) { var r = n(7293), i = n(5112), a = n(7392), o = i("species"); t.exports = function (t) { return a >= 51 || !r((function () { var e = []; return (e.constructor = {})[o] = function () { return { foo: 1 } }, 1 !== e[t](Boolean).foo })) } }, 9341: function (t, e, n) { "use strict"; var r = n(7293); t.exports = function (t, e) { var n = [][t]; return !!n && r((function () { n.call(null, e || function () { return 1 }, 1) })) } }, 3671: function (t, e, n) { var r = n(9662), i = n(7908), a = n(8361), o = n(6244), s = TypeError, l = function (t) { return function (e, n, l, c) { r(n); var u = i(e), h = a(u), d = o(u), f = t ? d - 1 : 0, p = t ? -1 : 1; if (l < 2) for (; ;) { if (f in h) { c = h[f], f += p; break } if (f += p, t ? f < 0 : d <= f) throw s("Reduce of empty array with no initial value") } for (; t ? f >= 0 : d > f; f += p)f in h && (c = n(c, h[f], f, u)); return c } }; t.exports = { left: l(!1), right: l(!0) } }, 1589: function (t, e, n) { var r = n(1400), i = n(6244), a = n(6135), o = Array, s = Math.max; t.exports = function (t, e, n) { for (var l = i(t), c = r(e, l), u = r(void 0 === n ? l : n, l), h = o(s(u - c, 0)), d = 0; c < u; c++, d++)a(h, d, t[c]); return h.length = d, h } }, 206: function (t, e, n) { var r = n(1702); t.exports = r([].slice) }, 4362: function (t, e, n) { var r = n(1589), i = Math.floor, a = function (t, e) { var n = t.length, l = i(n / 2); return n < 8 ? o(t, e) : s(t, a(r(t, 0, l), e), a(r(t, l), e), e) }, o = function (t, e) { for (var n, r, i = t.length, a = 1; a < i;) { for (r = a, n = t[a]; r && e(t[r - 1], n) > 0;)t[r] = t[--r]; r !== a++ && (t[r] = n) } return t }, s = function (t, e, n, r) { for (var i = e.length, a = n.length, o = 0, s = 0; o < i || s < a;)t[o + s] = o < i && s < a ? r(e[o], n[s]) <= 0 ? e[o++] : n[s++] : o < i ? e[o++] : n[s++]; return t }; t.exports = a }, 7475: function (t, e, n) { var r = n(3157), i = n(4411), a = n(111), o = n(5112)("species"), s = Array; t.exports = function (t) { var e; return r(t) && (e = t.constructor, (i(e) && (e === s || r(e.prototype)) || a(e) && null === (e = e[o])) && (e = void 0)), void 0 === e ? s : e } }, 5417: function (t, e, n) { var r = n(7475); t.exports = function (t, e) { return new (r(t))(0 === e ? 0 : e) } }, 7072: function (t, e, n) { var r = n(5112)("iterator"), i = !1; try { var a = 0, o = { next: function () { return { done: !!a++ } }, return: function () { i = !0 } }; o[r] = function () { return this }, Array.from(o, (function () { throw 2 })) } catch (t) { } t.exports = function (t, e) { if (!e && !i) return !1; var n = !1; try { var a = {}; a[r] = function () { return { next: function () { return { done: n = !0 } } } }, t(a) } catch (t) { } return n } }, 4326: function (t, e, n) { var r = n(1702), i = r({}.toString), a = r("".slice); t.exports = function (t) { return a(i(t), 8, -1) } }, 648: function (t, e, n) { var r = n(1694), i = n(614), a = n(4326), o = n(5112)("toStringTag"), s = Object, l = "Arguments" == a(function () { return arguments }()); t.exports = r ? a : function (t) { var e, n, r; return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) { try { return t[e] } catch (t) { } }(e = s(t), o)) ? n : l ? a(e) : "Object" == (r = a(e)) && i(e.callee) ? "Arguments" : r } }, 9920: function (t, e, n) { var r = n(2597), i = n(3887), a = n(1236), o = n(3070); t.exports = function (t, e, n) { for (var s = i(e), l = o.f, c = a.f, u = 0; u < s.length; u++) { var h = s[u]; r(t, h) || n && r(n, h) || l(t, h, c(e, h)) } } }, 8544: function (t, e, n) { var r = n(7293); t.exports = !r((function () { function t() { } return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype })) }, 8880: function (t, e, n) { var r = n(9781), i = n(3070), a = n(9114); t.exports = r ? function (t, e, n) { return i.f(t, e, a(1, n)) } : function (t, e, n) { return t[e] = n, t } }, 9114: function (t) { t.exports = function (t, e) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e } } }, 6135: function (t, e, n) { "use strict"; var r = n(4948), i = n(3070), a = n(9114); t.exports = function (t, e, n) { var o = r(e); o in t ? i.f(t, o, a(0, n)) : t[o] = n } }, 8052: function (t, e, n) { var r = n(614), i = n(3070), a = n(6339), o = n(3072); t.exports = function (t, e, n, s) { s || (s = {}); var l = s.enumerable, c = void 0 !== s.name ? s.name : e; if (r(n) && a(n, c, s), s.global) l ? t[e] = n : o(e, n); else { try { s.unsafe ? t[e] && (l = !0) : delete t[e] } catch (t) { } l ? t[e] = n : i.f(t, e, { value: n, enumerable: !1, configurable: !s.nonConfigurable, writable: !s.nonWritable }) } return t } }, 9190: function (t, e, n) { var r = n(8052); t.exports = function (t, e, n) { for (var i in e) r(t, i, e[i], n); return t } }, 3072: function (t, e, n) { var r = n(7854), i = Object.defineProperty; t.exports = function (t, e) { try { i(r, t, { value: e, configurable: !0, writable: !0 }) } catch (n) { r[t] = e } return e } }, 5117: function (t, e, n) { "use strict"; var r = n(6330), i = TypeError; t.exports = function (t, e) { if (!delete t[e]) throw i("Cannot delete property " + r(e) + " of " + r(t)) } }, 9781: function (t, e, n) { var r = n(7293); t.exports = !r((function () { return 7 != Object.defineProperty({}, 1, { get: function () { return 7 } })[1] })) }, 317: function (t, e, n) { var r = n(7854), i = n(111), a = r.document, o = i(a) && i(a.createElement); t.exports = function (t) { return o ? a.createElement(t) : {} } }, 8324: function (t) { t.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 } }, 8509: function (t, e, n) { var r = n(317)("span").classList, i = r && r.constructor && r.constructor.prototype; t.exports = i === Object.prototype ? void 0 : i }, 8886: function (t, e, n) { var r = n(8113).match(/firefox\/(\d+)/i); t.exports = !!r && +r[1] }, 7871: function (t, e, n) { var r = n(3823), i = n(5268); t.exports = !r && !i && "object" == typeof window && "object" == typeof document }, 3823: function (t) { t.exports = "object" == typeof Deno && Deno && "object" == typeof Deno.version }, 256: function (t, e, n) { var r = n(8113); t.exports = /MSIE|Trident/.test(r) }, 1528: function (t, e, n) { var r = n(8113), i = n(7854); t.exports = /ipad|iphone|ipod/i.test(r) && void 0 !== i.Pebble }, 6833: function (t, e, n) { var r = n(8113); t.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(r) }, 5268: function (t, e, n) { var r = n(4326), i = n(7854); t.exports = "process" == r(i.process) }, 1036: function (t, e, n) { var r = n(8113); t.exports = /web0s(?!.*chrome)/i.test(r) }, 8113: function (t, e, n) { var r = n(5005); t.exports = r("navigator", "userAgent") || "" }, 7392: function (t, e, n) { var r, i, a = n(7854), o = n(8113), s = a.process, l = a.Deno, c = s && s.versions || l && l.version, u = c && c.v8; u && (i = (r = u.split("."))[0] > 0 && r[0] < 4 ? 1 : +(r[0] + r[1])), !i && o && (!(r = o.match(/Edge\/(\d+)/)) || r[1] >= 74) && (r = o.match(/Chrome\/(\d+)/)) && (i = +r[1]), t.exports = i }, 8008: function (t, e, n) { var r = n(8113).match(/AppleWebKit\/(\d+)\./); t.exports = !!r && +r[1] }, 748: function (t) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, 2109: function (t, e, n) { var r = n(7854), i = n(1236).f, a = n(8880), o = n(8052), s = n(3072), l = n(9920), c = n(4705); t.exports = function (t, e) { var n, u, h, d, f, p = t.target, m = t.global, g = t.stat; if (n = m ? r : g ? r[p] || s(p, {}) : (r[p] || {}).prototype) for (u in e) { if (d = e[u], h = t.dontCallGetSet ? (f = i(n, u)) && f.value : n[u], !c(m ? u : p + (g ? "." : "#") + u, t.forced) && void 0 !== h) { if (typeof d == typeof h) continue; l(d, h) } (t.sham || h && h.sham) && a(d, "sham", !0), o(n, u, d, t) } } }, 7293: function (t) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, 2104: function (t, e, n) { var r = n(4374), i = Function.prototype, a = i.apply, o = i.call; t.exports = "object" == typeof Reflect && Reflect.apply || (r ? o.bind(a) : function () { return o.apply(a, arguments) }) }, 9974: function (t, e, n) { var r = n(1702), i = n(9662), a = n(4374), o = r(r.bind); t.exports = function (t, e) { return i(t), void 0 === e ? t : a ? o(t, e) : function () { return t.apply(e, arguments) } } }, 4374: function (t, e, n) { var r = n(7293); t.exports = !r((function () { var t = function () { }.bind(); return "function" != typeof t || t.hasOwnProperty("prototype") })) }, 6916: function (t, e, n) { var r = n(4374), i = Function.prototype.call; t.exports = r ? i.bind(i) : function () { return i.apply(i, arguments) } }, 6530: function (t, e, n) { var r = n(9781), i = n(2597), a = Function.prototype, o = r && Object.getOwnPropertyDescriptor, s = i(a, "name"), l = s && "something" === function () { }.name, c = s && (!r || r && o(a, "name").configurable); t.exports = { EXISTS: s, PROPER: l, CONFIGURABLE: c } }, 1702: function (t, e, n) { var r = n(4374), i = Function.prototype, a = i.bind, o = i.call, s = r && a.bind(o, o); t.exports = r ? function (t) { return t && s(t) } : function (t) { return t && function () { return o.apply(t, arguments) } } }, 5005: function (t, e, n) { var r = n(7854), i = n(614), a = function (t) { return i(t) ? t : void 0 }; t.exports = function (t, e) { return arguments.length < 2 ? a(r[t]) : r[t] && r[t][e] } }, 1246: function (t, e, n) { var r = n(648), i = n(8173), a = n(8554), o = n(7497), s = n(5112)("iterator"); t.exports = function (t) { if (!a(t)) return i(t, s) || i(t, "@@iterator") || o[r(t)] } }, 4121: function (t, e, n) { var r = n(6916), i = n(9662), a = n(9670), o = n(6330), s = n(1246), l = TypeError; t.exports = function (t, e) { var n = arguments.length < 2 ? s(t) : e; if (i(n)) return a(r(n, t)); throw l(o(t) + " is not iterable") } }, 8173: function (t, e, n) { var r = n(9662), i = n(8554); t.exports = function (t, e) { var n = t[e]; return i(n) ? void 0 : r(n) } }, 7854: function (t, e, n) { var r = function (t) { return t && t.Math == Math && t }; t.exports = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof n.g && n.g) || function () { return this }() || Function("return this")() }, 2597: function (t, e, n) { var r = n(1702), i = n(7908), a = r({}.hasOwnProperty); t.exports = Object.hasOwn || function (t, e) { return a(i(t), e) } }, 3501: function (t) { t.exports = {} }, 842: function (t, e, n) { var r = n(7854); t.exports = function (t, e) { var n = r.console; n && n.error && (1 == arguments.length ? n.error(t) : n.error(t, e)) } }, 490: function (t, e, n) { var r = n(5005); t.exports = r("document", "documentElement") }, 4664: function (t, e, n) { var r = n(9781), i = n(7293), a = n(317); t.exports = !r && !i((function () { return 7 != Object.defineProperty(a("div"), "a", { get: function () { return 7 } }).a })) }, 1179: function (t) { var e = Array, n = Math.abs, r = Math.pow, i = Math.floor, a = Math.log, o = Math.LN2; t.exports = { pack: function (t, s, l) { var c, u, h, d = e(l), f = 8 * l - s - 1, p = (1 << f) - 1, m = p >> 1, g = 23 === s ? r(2, -24) - r(2, -77) : 0, v = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0, _ = 0; for ((t = n(t)) != t || t === 1 / 0 ? (u = t != t ? 1 : 0, c = p) : (c = i(a(t) / o), t * (h = r(2, -c)) < 1 && (c--, h *= 2), (t += c + m >= 1 ? g / h : g * r(2, 1 - m)) * h >= 2 && (c++, h /= 2), c + m >= p ? (u = 0, c = p) : c + m >= 1 ? (u = (t * h - 1) * r(2, s), c += m) : (u = t * r(2, m - 1) * r(2, s), c = 0)); s >= 8;)d[_++] = 255 & u, u /= 256, s -= 8; for (c = c << s | u, f += s; f > 0;)d[_++] = 255 & c, c /= 256, f -= 8; return d[--_] |= 128 * v, d }, unpack: function (t, e) { var n, i = t.length, a = 8 * i - e - 1, o = (1 << a) - 1, s = o >> 1, l = a - 7, c = i - 1, u = t[c--], h = 127 & u; for (u >>= 7; l > 0;)h = 256 * h + t[c--], l -= 8; for (n = h & (1 << -l) - 1, h >>= -l, l += e; l > 0;)n = 256 * n + t[c--], l -= 8; if (0 === h) h = 1 - s; else { if (h === o) return n ? NaN : u ? -1 / 0 : 1 / 0; n += r(2, e), h -= s } return (u ? -1 : 1) * n * r(2, h - e) } } }, 8361: function (t, e, n) { var r = n(1702), i = n(7293), a = n(4326), o = Object, s = r("".split); t.exports = i((function () { return !o("z").propertyIsEnumerable(0) })) ? function (t) { return "String" == a(t) ? s(t, "") : o(t) } : o }, 9587: function (t, e, n) { var r = n(614), i = n(111), a = n(7674); t.exports = function (t, e, n) { var o, s; return a && r(o = e.constructor) && o !== n && i(s = o.prototype) && s !== n.prototype && a(t, s), t } }, 2788: function (t, e, n) { var r = n(1702), i = n(614), a = n(5465), o = r(Function.toString); i(a.inspectSource) || (a.inspectSource = function (t) { return o(t) }), t.exports = a.inspectSource }, 9909: function (t, e, n) { var r, i, a, o = n(4811), s = n(7854), l = n(1702), c = n(111), u = n(8880), h = n(2597), d = n(5465), f = n(6200), p = n(3501), m = "Object already initialized", g = s.TypeError, v = s.WeakMap; if (o || d.state) { var _ = d.state || (d.state = new v), y = l(_.get), x = l(_.has), b = l(_.set); r = function (t, e) { if (x(_, t)) throw g(m); return e.facade = t, b(_, t, e), e }, i = function (t) { return y(_, t) || {} }, a = function (t) { return x(_, t) } } else { var M = f("state"); p[M] = !0, r = function (t, e) { if (h(t, M)) throw g(m); return e.facade = t, u(t, M, e), e }, i = function (t) { return h(t, M) ? t[M] : {} }, a = function (t) { return h(t, M) } } t.exports = { set: r, get: i, has: a, enforce: function (t) { return a(t) ? i(t) : r(t, {}) }, getterFor: function (t) { return function (e) { var n; if (!c(e) || (n = i(e)).type !== t) throw g("Incompatible receiver, " + t + " required"); return n } } } }, 7659: function (t, e, n) { var r = n(5112), i = n(7497), a = r("iterator"), o = Array.prototype; t.exports = function (t) { return void 0 !== t && (i.Array === t || o[a] === t) } }, 3157: function (t, e, n) { var r = n(4326); t.exports = Array.isArray || function (t) { return "Array" == r(t) } }, 614: function (t) { t.exports = function (t) { return "function" == typeof t } }, 4411: function (t, e, n) { var r = n(1702), i = n(7293), a = n(614), o = n(648), s = n(5005), l = n(2788), c = function () { }, u = [], h = s("Reflect", "construct"), d = /^\s*(?:class|function)\b/, f = r(d.exec), p = !d.exec(c), m = function (t) { if (!a(t)) return !1; try { return h(c, u, t), !0 } catch (t) { return !1 } }, g = function (t) { if (!a(t)) return !1; switch (o(t)) { case "AsyncFunction": case "GeneratorFunction": case "AsyncGeneratorFunction": return !1 }try { return p || !!f(d, l(t)) } catch (t) { return !0 } }; g.sham = !0, t.exports = !h || i((function () { var t; return m(m.call) || !m(Object) || !m((function () { t = !0 })) || t })) ? g : m }, 4705: function (t, e, n) { var r = n(7293), i = n(614), a = /#|\.prototype\./, o = function (t, e) { var n = l[s(t)]; return n == u || n != c && (i(e) ? r(e) : !!e) }, s = o.normalize = function (t) { return String(t).replace(a, ".").toLowerCase() }, l = o.data = {}, c = o.NATIVE = "N", u = o.POLYFILL = "P"; t.exports = o }, 5988: function (t, e, n) { var r = n(111), i = Math.floor; t.exports = Number.isInteger || function (t) { return !r(t) && isFinite(t) && i(t) === t } }, 8554: function (t) { t.exports = function (t) { return null == t } }, 111: function (t, e, n) { var r = n(614), i = "object" == typeof document && document.all, a = void 0 === i && void 0 !== i; t.exports = a ? function (t) { return "object" == typeof t ? null !== t : r(t) || t === i } : function (t) { return "object" == typeof t ? null !== t : r(t) } }, 1913: function (t) { t.exports = !1 }, 2190: function (t, e, n) { var r = n(5005), i = n(614), a = n(7976), o = n(3307), s = Object; t.exports = o ? function (t) { return "symbol" == typeof t } : function (t) { var e = r("Symbol"); return i(e) && a(e.prototype, s(t)) } }, 408: function (t, e, n) { var r = n(9974), i = n(6916), a = n(9670), o = n(6330), s = n(7659), l = n(6244), c = n(7976), u = n(4121), h = n(1246), d = n(9212), f = TypeError, p = function (t, e) { this.stopped = t, this.result = e }, m = p.prototype; t.exports = function (t, e, n) { var g, v, _, y, x, b, M, w = n && n.that, S = !(!n || !n.AS_ENTRIES), T = !(!n || !n.IS_RECORD), E = !(!n || !n.IS_ITERATOR), A = !(!n || !n.INTERRUPTED), C = r(e, w), L = function (t) { return g && d(g, "normal", t), new p(!0, t) }, P = function (t) { return S ? (a(t), A ? C(t[0], t[1], L) : C(t[0], t[1])) : A ? C(t, L) : C(t) }; if (T) g = t.iterator; else if (E) g = t; else { if (!(v = h(t))) throw f(o(t) + " is not iterable"); if (s(v)) { for (_ = 0, y = l(t); y > _; _++)if ((x = P(t[_])) && c(m, x)) return x; return new p(!1) } g = u(t, v) } for (b = T ? t.next : g.next; !(M = i(b, g)).done;) { try { x = P(M.value) } catch (t) { d(g, "throw", t) } if ("object" == typeof x && x && c(m, x)) return x } return new p(!1) } }, 9212: function (t, e, n) { var r = n(6916), i = n(9670), a = n(8173); t.exports = function (t, e, n) { var o, s; i(t); try { if (!(o = a(t, "return"))) { if ("throw" === e) throw n; return n } o = r(o, t) } catch (t) { s = !0, o = t } if ("throw" === e) throw n; if (s) throw o; return i(o), n } }, 3061: function (t, e, n) { "use strict"; var r = n(3383).IteratorPrototype, i = n(30), a = n(9114), o = n(8003), s = n(7497), l = function () { return this }; t.exports = function (t, e, n, c) { var u = e + " Iterator"; return t.prototype = i(r, { next: a(+!c, n) }), o(t, u, !1, !0), s[u] = l, t } }, 1656: function (t, e, n) { "use strict"; var r = n(2109), i = n(6916), a = n(1913), o = n(6530), s = n(614), l = n(3061), c = n(9518), u = n(7674), h = n(8003), d = n(8880), f = n(8052), p = n(5112), m = n(7497), g = n(3383), v = o.PROPER, _ = o.CONFIGURABLE, y = g.IteratorPrototype, x = g.BUGGY_SAFARI_ITERATORS, b = p("iterator"), M = "keys", w = "values", S = "entries", T = function () { return this }; t.exports = function (t, e, n, o, p, g, E) { l(n, e, o); var A, C, L, P = function (t) { if (t === p && N) return N; if (!x && t in I) return I[t]; switch (t) { case M: case w: case S: return function () { return new n(this, t) } }return function () { return new n(this) } }, R = e + " Iterator", D = !1, I = t.prototype, O = I[b] || I["@@iterator"] || p && I[p], N = !x && O || P(p), z = "Array" == e && I.entries || O; if (z && (A = c(z.call(new t))) !== Object.prototype && A.next && (a || c(A) === y || (u ? u(A, y) : s(A[b]) || f(A, b, T)), h(A, R, !0, !0), a && (m[R] = T)), v && p == w && O && O.name !== w && (!a && _ ? d(I, "name", w) : (D = !0, N = function () { return i(O, this) })), p) if (C = { values: P(w), keys: g ? N : P(M), entries: P(S) }, E) for (L in C) (x || D || !(L in I)) && f(I, L, C[L]); else r({ target: e, proto: !0, forced: x || D }, C); return a && !E || I[b] === N || f(I, b, N, { name: p }), m[e] = N, C } }, 3383: function (t, e, n) { "use strict"; var r, i, a, o = n(7293), s = n(614), l = n(111), c = n(30), u = n(9518), h = n(8052), d = n(5112), f = n(1913), p = d("iterator"), m = !1;[].keys && ("next" in (a = [].keys()) ? (i = u(u(a))) !== Object.prototype && (r = i) : m = !0), !l(r) || o((function () { var t = {}; return r[p].call(t) !== t })) ? r = {} : f && (r = c(r)), s(r[p]) || h(r, p, (function () { return this })), t.exports = { IteratorPrototype: r, BUGGY_SAFARI_ITERATORS: m } }, 7497: function (t) { t.exports = {} }, 6244: function (t, e, n) { var r = n(7466); t.exports = function (t) { return r(t.length) } }, 6339: function (t, e, n) { var r = n(7293), i = n(614), a = n(2597), o = n(9781), s = n(6530).CONFIGURABLE, l = n(2788), c = n(9909), u = c.enforce, h = c.get, d = Object.defineProperty, f = o && !r((function () { return 8 !== d((function () { }), "length", { value: 8 }).length })), p = String(String).split("String"), m = t.exports = function (t, e, n) { "Symbol(" === String(e).slice(0, 7) && (e = "[" + String(e).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!a(t, "name") || s && t.name !== e) && (o ? d(t, "name", { value: e, configurable: !0 }) : t.name = e), f && n && a(n, "arity") && t.length !== n.arity && d(t, "length", { value: n.arity }); try { n && a(n, "constructor") && n.constructor ? o && d(t, "prototype", { writable: !1 }) : t.prototype && (t.prototype = void 0) } catch (t) { } var r = u(t); return a(r, "source") || (r.source = p.join("string" == typeof e ? e : "")), t }; Function.prototype.toString = m((function () { return i(this) && h(this).source || l(this) }), "toString") }, 4758: function (t) { var e = Math.ceil, n = Math.floor; t.exports = Math.trunc || function (t) { var r = +t; return (r > 0 ? n : e)(r) } }, 5948: function (t, e, n) { var r, i, a, o, s, l, c, u, h = n(7854), d = n(9974), f = n(1236).f, p = n(261).set, m = n(6833), g = n(1528), v = n(1036), _ = n(5268), y = h.MutationObserver || h.WebKitMutationObserver, x = h.document, b = h.process, M = h.Promise, w = f(h, "queueMicrotask"), S = w && w.value; S || (r = function () { var t, e; for (_ && (t = b.domain) && t.exit(); i;) { e = i.fn, i = i.next; try { e() } catch (t) { throw i ? o() : a = void 0, t } } a = void 0, t && t.enter() }, m || _ || v || !y || !x ? !g && M && M.resolve ? ((c = M.resolve(void 0)).constructor = M, u = d(c.then, c), o = function () { u(r) }) : _ ? o = function () { b.nextTick(r) } : (p = d(p, h), o = function () { p(r) }) : (s = !0, l = x.createTextNode(""), new y(r).observe(l, { characterData: !0 }), o = function () { l.data = s = !s })), t.exports = S || function (t) { var e = { fn: t, next: void 0 }; a && (a.next = e), i || (i = e, o()), a = e } }, 8523: function (t, e, n) { "use strict"; var r = n(9662), i = TypeError, a = function (t) { var e, n; this.promise = new t((function (t, r) { if (void 0 !== e || void 0 !== n) throw i("Bad Promise constructor"); e = t, n = r })), this.resolve = r(e), this.reject = r(n) }; t.exports.f = function (t) { return new a(t) } }, 30: function (t, e, n) { var r, i = n(9670), a = n(6048), o = n(748), s = n(3501), l = n(490), c = n(317), u = n(6200)("IE_PROTO"), h = function () { }, d = function (t) { return "<script>" + t + "<\/script>" }, f = function (t) { t.write(d("")), t.close(); var e = t.parentWindow.Object; return t = null, e }, p = function () { try { r = new ActiveXObject("htmlfile") } catch (t) { } var t, e; p = "undefined" != typeof document ? document.domain && r ? f(r) : ((e = c("iframe")).style.display = "none", l.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(d("document.F=Object")), t.close(), t.F) : f(r); for (var n = o.length; n--;)delete p.prototype[o[n]]; return p() }; s[u] = !0, t.exports = Object.create || function (t, e) { var n; return null !== t ? (h.prototype = i(t), n = new h, h.prototype = null, n[u] = t) : n = p(), void 0 === e ? n : a.f(n, e) } }, 6048: function (t, e, n) { var r = n(9781), i = n(3353), a = n(3070), o = n(9670), s = n(5656), l = n(1956); e.f = r && !i ? Object.defineProperties : function (t, e) { o(t); for (var n, r = s(e), i = l(e), c = i.length, u = 0; c > u;)a.f(t, n = i[u++], r[n]); return t } }, 3070: function (t, e, n) { var r = n(9781), i = n(4664), a = n(3353), o = n(9670), s = n(4948), l = TypeError, c = Object.defineProperty, u = Object.getOwnPropertyDescriptor; e.f = r ? a ? function (t, e, n) { if (o(t), e = s(e), o(n), "function" == typeof t && "prototype" === e && "value" in n && "writable" in n && !n.writable) { var r = u(t, e); r && r.writable && (t[e] = n.value, n = { configurable: "configurable" in n ? n.configurable : r.configurable, enumerable: "enumerable" in n ? n.enumerable : r.enumerable, writable: !1 }) } return c(t, e, n) } : c : function (t, e, n) { if (o(t), e = s(e), o(n), i) try { return c(t, e, n) } catch (t) { } if ("get" in n || "set" in n) throw l("Accessors not supported"); return "value" in n && (t[e] = n.value), t } }, 1236: function (t, e, n) { var r = n(9781), i = n(6916), a = n(5296), o = n(9114), s = n(5656), l = n(4948), c = n(2597), u = n(4664), h = Object.getOwnPropertyDescriptor; e.f = r ? h : function (t, e) { if (t = s(t), e = l(e), u) try { return h(t, e) } catch (t) { } if (c(t, e)) return o(!i(a.f, t, e), t[e]) } }, 1156: function (t, e, n) { var r = n(4326), i = n(5656), a = n(8006).f, o = n(1589), s = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; t.exports.f = function (t) { return s && "Window" == r(t) ? function (t) { try { return a(t) } catch (t) { return o(s) } }(t) : a(i(t)) } }, 8006: function (t, e, n) { var r = n(6324), i = n(748).concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (t) { return r(t, i) } }, 5181: function (t, e) { e.f = Object.getOwnPropertySymbols }, 9518: function (t, e, n) { var r = n(2597), i = n(614), a = n(7908), o = n(6200), s = n(8544), l = o("IE_PROTO"), c = Object, u = c.prototype; t.exports = s ? c.getPrototypeOf : function (t) { var e = a(t); if (r(e, l)) return e[l]; var n = e.constructor; return i(n) && e instanceof n ? n.prototype : e instanceof c ? u : null } }, 7976: function (t, e, n) { var r = n(1702); t.exports = r({}.isPrototypeOf) }, 6324: function (t, e, n) { var r = n(1702), i = n(2597), a = n(5656), o = n(1318).indexOf, s = n(3501), l = r([].push); t.exports = function (t, e) { var n, r = a(t), c = 0, u = []; for (n in r) !i(s, n) && i(r, n) && l(u, n); for (; e.length > c;)i(r, n = e[c++]) && (~o(u, n) || l(u, n)); return u } }, 1956: function (t, e, n) { var r = n(6324), i = n(748); t.exports = Object.keys || function (t) { return r(t, i) } }, 5296: function (t, e) { "use strict"; var n = {}.propertyIsEnumerable, r = Object.getOwnPropertyDescriptor, i = r && !n.call({ 1: 2 }, 1); e.f = i ? function (t) { var e = r(this, t); return !!e && e.enumerable } : n }, 7674: function (t, e, n) { var r = n(1702), i = n(9670), a = n(6077); t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () { var t, e = !1, n = {}; try { (t = r(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []), e = n instanceof Array } catch (t) { } return function (n, r) { return i(n), a(r), e ? t(n, r) : n.__proto__ = r, n } }() : void 0) }, 288: function (t, e, n) { "use strict"; var r = n(1694), i = n(648); t.exports = r ? {}.toString : function () { return "[object " + i(this) + "]" } }, 2140: function (t, e, n) { var r = n(6916), i = n(614), a = n(111), o = TypeError; t.exports = function (t, e) { var n, s; if ("string" === e && i(n = t.toString) && !a(s = r(n, t))) return s; if (i(n = t.valueOf) && !a(s = r(n, t))) return s; if ("string" !== e && i(n = t.toString) && !a(s = r(n, t))) return s; throw o("Can't convert object to primitive value") } }, 3887: function (t, e, n) { var r = n(5005), i = n(1702), a = n(8006), o = n(5181), s = n(9670), l = i([].concat); t.exports = r("Reflect", "ownKeys") || function (t) { var e = a.f(s(t)), n = o.f; return n ? l(e, n(t)) : e } }, 857: function (t, e, n) { var r = n(7854); t.exports = r }, 2534: function (t) { t.exports = function (t) { try { return { error: !1, value: t() } } catch (t) { return { error: !0, value: t } } } }, 3702: function (t, e, n) { var r = n(7854), i = n(2492), a = n(614), o = n(4705), s = n(2788), l = n(5112), c = n(7871), u = n(3823), h = n(1913), d = n(7392), f = i && i.prototype, p = l("species"), m = !1, g = a(r.PromiseRejectionEvent), v = o("Promise", (function () { var t = s(i), e = t !== String(i); if (!e && 66 === d) return !0; if (h && (!f.catch || !f.finally)) return !0; if (!d || d < 51 || !/native code/.test(t)) { var n = new i((function (t) { t(1) })), r = function (t) { t((function () { }), (function () { })) }; if ((n.constructor = {})[p] = r, !(m = n.then((function () { })) instanceof r)) return !0 } return !e && (c || u) && !g })); t.exports = { CONSTRUCTOR: v, REJECTION_EVENT: g, SUBCLASSING: m } }, 2492: function (t, e, n) { var r = n(7854); t.exports = r.Promise }, 9478: function (t, e, n) { var r = n(9670), i = n(111), a = n(8523); t.exports = function (t, e) { if (r(t), i(e) && e.constructor === t) return e; var n = a.f(t); return (0, n.resolve)(e), n.promise } }, 612: function (t, e, n) { var r = n(2492), i = n(7072), a = n(3702).CONSTRUCTOR; t.exports = a || !i((function (t) { r.all(t).then(void 0, (function () { })) })) }, 8572: function (t) { var e = function () { this.head = null, this.tail = null }; e.prototype = { add: function (t) { var e = { item: t, next: null }; this.head ? this.tail.next = e : this.head = e, this.tail = e }, get: function () { var t = this.head; if (t) return this.head = t.next, this.tail === t && (this.tail = null), t.item } }, t.exports = e }, 4488: function (t, e, n) { var r = n(8554), i = TypeError; t.exports = function (t) { if (r(t)) throw i("Can't call method on " + t); return t } }, 6340: function (t, e, n) { "use strict"; var r = n(5005), i = n(3070), a = n(5112), o = n(9781), s = a("species"); t.exports = function (t) { var e = r(t), n = i.f; o && e && !e[s] && n(e, s, { configurable: !0, get: function () { return this } }) } }, 8003: function (t, e, n) { var r = n(3070).f, i = n(2597), a = n(5112)("toStringTag"); t.exports = function (t, e, n) { t && !n && (t = t.prototype), t && !i(t, a) && r(t, a, { configurable: !0, value: e }) } }, 6200: function (t, e, n) { var r = n(2309), i = n(9711), a = r("keys"); t.exports = function (t) { return a[t] || (a[t] = i(t)) } }, 5465: function (t, e, n) { var r = n(7854), i = n(3072), a = "__core-js_shared__", o = r[a] || i(a, {}); t.exports = o }, 2309: function (t, e, n) { var r = n(1913), i = n(5465); (t.exports = function (t, e) { return i[t] || (i[t] = void 0 !== e ? e : {}) })("versions", []).push({ version: "3.25.0", mode: r ? "pure" : "global", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.25.0/LICENSE", source: "https://github.com/zloirock/core-js" }) }, 6707: function (t, e, n) { var r = n(9670), i = n(9483), a = n(8554), o = n(5112)("species"); t.exports = function (t, e) { var n, s = r(t).constructor; return void 0 === s || a(n = r(s)[o]) ? e : i(n) } }, 8710: function (t, e, n) { var r = n(1702), i = n(9303), a = n(1340), o = n(4488), s = r("".charAt), l = r("".charCodeAt), c = r("".slice), u = function (t) { return function (e, n) { var r, u, h = a(o(e)), d = i(n), f = h.length; return d < 0 || d >= f ? t ? "" : void 0 : (r = l(h, d)) < 55296 || r > 56319 || d + 1 === f || (u = l(h, d + 1)) < 56320 || u > 57343 ? t ? s(h, d) : r : t ? c(h, d, d + 2) : u - 56320 + (r - 55296 << 10) + 65536 } }; t.exports = { codeAt: u(!1), charAt: u(!0) } }, 3111: function (t, e, n) { var r = n(1702), i = n(4488), a = n(1340), o = n(1361), s = r("".replace), l = "[" + o + "]", c = RegExp("^" + l + l + "*"), u = RegExp(l + l + "*$"), h = function (t) { return function (e) { var n = a(i(e)); return 1 & t && (n = s(n, c, "")), 2 & t && (n = s(n, u, "")), n } }; t.exports = { start: h(1), end: h(2), trim: h(3) } }, 6293: function (t, e, n) { var r = n(7392), i = n(7293); t.exports = !!Object.getOwnPropertySymbols && !i((function () { var t = Symbol(); return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && r && r < 41 })) }, 6532: function (t, e, n) { var r = n(6916), i = n(5005), a = n(5112), o = n(8052); t.exports = function () { var t = i("Symbol"), e = t && t.prototype, n = e && e.valueOf, s = a("toPrimitive"); e && !e[s] && o(e, s, (function (t) { return r(n, this) }), { arity: 1 }) } }, 2015: function (t, e, n) { var r = n(6293); t.exports = r && !!Symbol.for && !!Symbol.keyFor }, 261: function (t, e, n) { var r, i, a, o, s = n(7854), l = n(2104), c = n(9974), u = n(614), h = n(2597), d = n(7293), f = n(490), p = n(206), m = n(317), g = n(8053), v = n(6833), _ = n(5268), y = s.setImmediate, x = s.clearImmediate, b = s.process, M = s.Dispatch, w = s.Function, S = s.MessageChannel, T = s.String, E = 0, A = {}; try { r = s.location } catch (t) { } var C = function (t) { if (h(A, t)) { var e = A[t]; delete A[t], e() } }, L = function (t) { return function () { C(t) } }, P = function (t) { C(t.data) }, R = function (t) { s.postMessage(T(t), r.protocol + "//" + r.host) }; y && x || (y = function (t) { g(arguments.length, 1); var e = u(t) ? t : w(t), n = p(arguments, 1); return A[++E] = function () { l(e, void 0, n) }, i(E), E }, x = function (t) { delete A[t] }, _ ? i = function (t) { b.nextTick(L(t)) } : M && M.now ? i = function (t) { M.now(L(t)) } : S && !v ? (o = (a = new S).port2, a.port1.onmessage = P, i = c(o.postMessage, o)) : s.addEventListener && u(s.postMessage) && !s.importScripts && r && "file:" !== r.protocol && !d(R) ? (i = R, s.addEventListener("message", P, !1)) : i = "onreadystatechange" in m("script") ? function (t) { f.appendChild(m("script")).onreadystatechange = function () { f.removeChild(this), C(t) } } : function (t) { setTimeout(L(t), 0) }), t.exports = { set: y, clear: x } }, 863: function (t, e, n) { var r = n(1702); t.exports = r(1..valueOf) }, 1400: function (t, e, n) { var r = n(9303), i = Math.max, a = Math.min; t.exports = function (t, e) { var n = r(t); return n < 0 ? i(n + e, 0) : a(n, e) } }, 4599: function (t, e, n) { var r = n(7593), i = TypeError; t.exports = function (t) { var e = r(t, "number"); if ("number" == typeof e) throw i("Can't convert number to bigint"); return BigInt(e) } }, 7067: function (t, e, n) { var r = n(9303), i = n(7466), a = RangeError; t.exports = function (t) { if (void 0 === t) return 0; var e = r(t), n = i(e); if (e !== n) throw a("Wrong length or index"); return n } }, 5656: function (t, e, n) { var r = n(8361), i = n(4488); t.exports = function (t) { return r(i(t)) } }, 9303: function (t, e, n) { var r = n(4758); t.exports = function (t) { var e = +t; return e != e || 0 === e ? 0 : r(e) } }, 7466: function (t, e, n) { var r = n(9303), i = Math.min; t.exports = function (t) { return t > 0 ? i(r(t), 9007199254740991) : 0 } }, 7908: function (t, e, n) { var r = n(4488), i = Object; t.exports = function (t) { return i(r(t)) } }, 4590: function (t, e, n) { var r = n(3002), i = RangeError; t.exports = function (t, e) { var n = r(t); if (n % e) throw i("Wrong offset"); return n } }, 3002: function (t, e, n) { var r = n(9303), i = RangeError; t.exports = function (t) { var e = r(t); if (e < 0) throw i("The argument can't be less than 0"); return e } }, 7593: function (t, e, n) { var r = n(6916), i = n(111), a = n(2190), o = n(8173), s = n(2140), l = n(5112), c = TypeError, u = l("toPrimitive"); t.exports = function (t, e) { if (!i(t) || a(t)) return t; var n, l = o(t, u); if (l) { if (void 0 === e && (e = "default"), n = r(l, t, e), !i(n) || a(n)) return n; throw c("Can't convert object to primitive value") } return void 0 === e && (e = "number"), s(t, e) } }, 4948: function (t, e, n) { var r = n(7593), i = n(2190); t.exports = function (t) { var e = r(t, "string"); return i(e) ? e : e + "" } }, 1694: function (t, e, n) { var r = {}; r[n(5112)("toStringTag")] = "z", t.exports = "[object z]" === String(r) }, 1340: function (t, e, n) { var r = n(648), i = String; t.exports = function (t) { if ("Symbol" === r(t)) throw TypeError("Cannot convert a Symbol value to a string"); return i(t) } }, 6330: function (t) { var e = String; t.exports = function (t) { try { return e(t) } catch (t) { return "Object" } } }, 9843: function (t, e, n) { "use strict"; var r = n(2109), i = n(7854), a = n(6916), o = n(9781), s = n(3832), l = n(260), c = n(3331), u = n(5787), h = n(9114), d = n(8880), f = n(5988), p = n(7466), m = n(7067), g = n(4590), v = n(4948), _ = n(2597), y = n(648), x = n(111), b = n(2190), M = n(30), w = n(7976), S = n(7674), T = n(8006).f, E = n(7321), A = n(2092).forEach, C = n(6340), L = n(3070), P = n(1236), R = n(9909), D = n(9587), I = R.get, O = R.set, N = R.enforce, z = L.f, F = P.f, U = Math.round, k = i.RangeError, B = c.ArrayBuffer, V = B.prototype, G = c.DataView, H = l.NATIVE_ARRAY_BUFFER_VIEWS, W = l.TYPED_ARRAY_TAG, j = l.TypedArray, q = l.TypedArrayPrototype, X = l.aTypedArrayConstructor, Y = l.isTypedArray, Z = "BYTES_PER_ELEMENT", K = "Wrong length", J = function (t, e) { X(t); for (var n = 0, r = e.length, i = new t(r); r > n;)i[n] = e[n++]; return i }, Q = function (t, e) { z(t, e, { get: function () { return I(this)[e] } }) }, $ = function (t) { var e; return w(V, t) || "ArrayBuffer" == (e = y(t)) || "SharedArrayBuffer" == e }, tt = function (t, e) { return Y(t) && !b(e) && e in t && f(+e) && e >= 0 }, et = function (t, e) { return e = v(e), tt(t, e) ? h(2, t[e]) : F(t, e) }, nt = function (t, e, n) { return e = v(e), !(tt(t, e) && x(n) && _(n, "value")) || _(n, "get") || _(n, "set") || n.configurable || _(n, "writable") && !n.writable || _(n, "enumerable") && !n.enumerable ? z(t, e, n) : (t[e] = n.value, t) }; o ? (H || (P.f = et, L.f = nt, Q(q, "buffer"), Q(q, "byteOffset"), Q(q, "byteLength"), Q(q, "length")), r({ target: "Object", stat: !0, forced: !H }, { getOwnPropertyDescriptor: et, defineProperty: nt }), t.exports = function (t, e, n) { var o = t.match(/\d+$/)[0] / 8, l = t + (n ? "Clamped" : "") + "Array", c = "get" + t, h = "set" + t, f = i[l], v = f, _ = v && v.prototype, y = {}, b = function (t, e) { z(t, e, { get: function () { return function (t, e) { var n = I(t); return n.view[c](e * o + n.byteOffset, !0) }(this, e) }, set: function (t) { return function (t, e, r) { var i = I(t); n && (r = (r = U(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r), i.view[h](e * o + i.byteOffset, r, !0) }(this, e, t) }, enumerable: !0 }) }; H ? s && (v = e((function (t, e, n, r) { return u(t, _), D(x(e) ? $(e) ? void 0 !== r ? new f(e, g(n, o), r) : void 0 !== n ? new f(e, g(n, o)) : new f(e) : Y(e) ? J(v, e) : a(E, v, e) : new f(m(e)), t, v) })), S && S(v, j), A(T(f), (function (t) { t in v || d(v, t, f[t]) })), v.prototype = _) : (v = e((function (t, e, n, r) { u(t, _); var i, s, l, c = 0, h = 0; if (x(e)) { if (!$(e)) return Y(e) ? J(v, e) : a(E, v, e); i = e, h = g(n, o); var d = e.byteLength; if (void 0 === r) { if (d % o) throw k(K); if ((s = d - h) < 0) throw k(K) } else if ((s = p(r) * o) + h > d) throw k(K); l = s / o } else l = m(e), i = new B(s = l * o); for (O(t, { buffer: i, byteOffset: h, byteLength: s, length: l, view: new G(i) }); c < l;)b(t, c++) })), S && S(v, j), _ = v.prototype = M(q)), _.constructor !== v && d(_, "constructor", v), N(_).TypedArrayConstructor = v, W && d(_, W, l); var w = v != f; y[l] = v, r({ global: !0, constructor: !0, forced: w, sham: !H }, y), Z in v || d(v, Z, o), Z in _ || d(_, Z, o), C(l) }) : t.exports = function () { } }, 3832: function (t, e, n) { var r = n(7854), i = n(7293), a = n(7072), o = n(260).NATIVE_ARRAY_BUFFER_VIEWS, s = r.ArrayBuffer, l = r.Int8Array; t.exports = !o || !i((function () { l(1) })) || !i((function () { new l(-1) })) || !a((function (t) { new l, new l(null), new l(1.5), new l(t) }), !0) || i((function () { return 1 !== new l(new s(2), 1, void 0).length })) }, 3074: function (t, e, n) { var r = n(7745), i = n(6304); t.exports = function (t, e) { return r(i(t), e) } }, 7321: function (t, e, n) { var r = n(9974), i = n(6916), a = n(9483), o = n(7908), s = n(6244), l = n(4121), c = n(1246), u = n(7659), h = n(260).aTypedArrayConstructor; t.exports = function (t) { var e, n, d, f, p, m, g = a(this), v = o(t), _ = arguments.length, y = _ > 1 ? arguments[1] : void 0, x = void 0 !== y, b = c(v); if (b && !u(b)) for (m = (p = l(v, b)).next, v = []; !(f = i(m, p)).done;)v.push(f.value); for (x && _ > 2 && (y = r(y, arguments[2])), n = s(v), d = new (h(g))(n), e = 0; n > e; e++)d[e] = x ? y(v[e], e) : v[e]; return d } }, 6304: function (t, e, n) { var r = n(260), i = n(6707), a = r.aTypedArrayConstructor, o = r.getTypedArrayConstructor; t.exports = function (t) { return a(i(t, o(t))) } }, 9711: function (t, e, n) { var r = n(1702), i = 0, a = Math.random(), o = r(1..toString); t.exports = function (t) { return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++i + a, 36) } }, 3307: function (t, e, n) { var r = n(6293); t.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator }, 3353: function (t, e, n) { var r = n(9781), i = n(7293); t.exports = r && i((function () { return 42 != Object.defineProperty((function () { }), "prototype", { value: 42, writable: !1 }).prototype })) }, 8053: function (t) { var e = TypeError; t.exports = function (t, n) { if (t < n) throw e("Not enough arguments"); return t } }, 4811: function (t, e, n) { var r = n(7854), i = n(614), a = r.WeakMap; t.exports = i(a) && /native code/.test(String(a)) }, 6800: function (t, e, n) { var r = n(857), i = n(2597), a = n(6061), o = n(3070).f; t.exports = function (t) { var e = r.Symbol || (r.Symbol = {}); i(e, t) || o(e, t, { value: a.f(t) }) } }, 6061: function (t, e, n) { var r = n(5112); e.f = r }, 5112: function (t, e, n) { var r = n(7854), i = n(2309), a = n(2597), o = n(9711), s = n(6293), l = n(3307), c = i("wks"), u = r.Symbol, h = u && u.for, d = l ? u : u && u.withoutSetter || o; t.exports = function (t) { if (!a(c, t) || !s && "string" != typeof c[t]) { var e = "Symbol." + t; s && a(u, t) ? c[t] = u[t] : c[t] = l && h ? h(e) : d(e) } return c[t] } }, 1361: function (t) { t.exports = "\t\n\v\f\r                　\u2028\u2029\ufeff" }, 3290: function (t, e, n) { var r = n(2109), i = n(1285), a = n(1223); r({ target: "Array", proto: !0 }, { fill: i }), a("fill") }, 6992: function (t, e, n) { "use strict"; var r = n(5656), i = n(1223), a = n(7497), o = n(9909), s = n(3070).f, l = n(1656), c = n(1913), u = n(9781), h = "Array Iterator", d = o.set, f = o.getterFor(h); t.exports = l(Array, "Array", (function (t, e) { d(this, { type: h, target: r(t), index: 0, kind: e }) }), (function () { var t = f(this), e = t.target, n = t.kind, r = t.index++; return !e || r >= e.length ? (t.target = void 0, { value: void 0, done: !0 }) : "keys" == n ? { value: r, done: !1 } : "values" == n ? { value: e[r], done: !1 } : { value: [r, e[r]], done: !1 } }), "values"); var p = a.Arguments = a.Array; if (i("keys"), i("values"), i("entries"), !c && u && "values" !== p.name) try { s(p, "name", { value: "values" }) } catch (t) { } }, 1249: function (t, e, n) { "use strict"; var r = n(2109), i = n(2092).map; r({ target: "Array", proto: !0, forced: !n(1194)("map") }, { map: function (t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0) } }) }, 7042: function (t, e, n) { "use strict"; var r = n(2109), i = n(3157), a = n(4411), o = n(111), s = n(1400), l = n(6244), c = n(5656), u = n(6135), h = n(5112), d = n(1194), f = n(206), p = d("slice"), m = h("species"), g = Array, v = Math.max; r({ target: "Array", proto: !0, forced: !p }, { slice: function (t, e) { var n, r, h, d = c(this), p = l(d), _ = s(t, p), y = s(void 0 === e ? p : e, p); if (i(d) && (n = d.constructor, (a(n) && (n === g || i(n.prototype)) || o(n) && null === (n = n[m])) && (n = void 0), n === g || void 0 === n)) return f(d, _, y); for (r = new (void 0 === n ? g : n)(v(y - _, 0)), h = 0; _ < y; _++, h++)_ in d && u(r, h, d[_]); return r.length = h, r } }) }, 8309: function (t, e, n) { var r = n(9781), i = n(6530).EXISTS, a = n(1702), o = n(3070).f, s = Function.prototype, l = a(s.toString), c = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/, u = a(c.exec); r && !i && o(s, "name", { configurable: !0, get: function () { try { return u(c, l(this))[1] } catch (t) { return "" } } }) }, 8862: function (t, e, n) { var r = n(2109), i = n(5005), a = n(2104), o = n(6916), s = n(1702), l = n(7293), c = n(3157), u = n(614), h = n(111), d = n(2190), f = n(206), p = n(6293), m = i("JSON", "stringify"), g = s(/./.exec), v = s("".charAt), _ = s("".charCodeAt), y = s("".replace), x = s(1..toString), b = /[\uD800-\uDFFF]/g, M = /^[\uD800-\uDBFF]$/, w = /^[\uDC00-\uDFFF]$/, S = !p || l((function () { var t = i("Symbol")(); return "[null]" != m([t]) || "{}" != m({ a: t }) || "{}" != m(Object(t)) })), T = l((function () { return '"\\udf06\\ud834"' !== m("\udf06\ud834") || '"\\udead"' !== m("\udead") })), E = function (t, e) { var n = f(arguments), r = e; if ((h(e) || void 0 !== t) && !d(t)) return c(e) || (e = function (t, e) { if (u(r) && (e = o(r, this, t, e)), !d(e)) return e }), n[1] = e, a(m, null, n) }, A = function (t, e, n) { var r = v(n, e - 1), i = v(n, e + 1); return g(M, t) && !g(w, i) || g(w, t) && !g(M, r) ? "\\u" + x(_(t, 0), 16) : t }; m && r({ target: "JSON", stat: !0, arity: 3, forced: S || T }, { stringify: function (t, e, n) { var r = f(arguments), i = a(S ? E : m, null, r); return T && "string" == typeof i ? y(i, b, A) : i } }) }, 3706: function (t, e, n) { var r = n(7854); n(8003)(r.JSON, "JSON", !0) }, 2703: function (t, e, n) { n(8003)(Math, "Math", !0) }, 9653: function (t, e, n) { "use strict"; var r = n(9781), i = n(7854), a = n(1702), o = n(4705), s = n(8052), l = n(2597), c = n(9587), u = n(7976), h = n(2190), d = n(7593), f = n(7293), p = n(8006).f, m = n(1236).f, g = n(3070).f, v = n(863), _ = n(3111).trim, y = "Number", x = i.Number, b = x.prototype, M = i.TypeError, w = a("".slice), S = a("".charCodeAt), T = function (t) { var e = d(t, "number"); return "bigint" == typeof e ? e : E(e) }, E = function (t) { var e, n, r, i, a, o, s, l, c = d(t, "number"); if (h(c)) throw M("Cannot convert a Symbol value to a number"); if ("string" == typeof c && c.length > 2) if (c = _(c), 43 === (e = S(c, 0)) || 45 === e) { if (88 === (n = S(c, 2)) || 120 === n) return NaN } else if (48 === e) { switch (S(c, 1)) { case 66: case 98: r = 2, i = 49; break; case 79: case 111: r = 8, i = 55; break; default: return +c }for (o = (a = w(c, 2)).length, s = 0; s < o; s++)if ((l = S(a, s)) < 48 || l > i) return NaN; return parseInt(a, r) } return +c }; if (o(y, !x(" 0o1") || !x("0b1") || x("+0x1"))) { for (var A, C = function (t) { var e = arguments.length < 1 ? 0 : x(T(t)), n = this; return u(b, n) && f((function () { v(n) })) ? c(Object(e), n, C) : e }, L = r ? p(x) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), P = 0; L.length > P; P++)l(x, A = L[P]) && !l(C, A) && g(C, A, m(x, A)); C.prototype = b, b.constructor = C, s(i, y, C, { constructor: !0 }) } }, 9660: function (t, e, n) { var r = n(2109), i = n(6293), a = n(7293), o = n(5181), s = n(7908); r({ target: "Object", stat: !0, forced: !i || a((function () { o.f(1) })) }, { getOwnPropertySymbols: function (t) { var e = o.f; return e ? e(s(t)) : [] } }) }, 489: function (t, e, n) { var r = n(2109), i = n(7293), a = n(7908), o = n(9518), s = n(8544); r({ target: "Object", stat: !0, forced: i((function () { o(1) })), sham: !s }, { getPrototypeOf: function (t) { return o(a(t)) } }) }, 1539: function (t, e, n) { var r = n(1694), i = n(8052), a = n(288); r || i(Object.prototype, "toString", a, { unsafe: !0 }) }, 821: function (t, e, n) { "use strict"; var r = n(2109), i = n(6916), a = n(9662), o = n(8523), s = n(2534), l = n(408); r({ target: "Promise", stat: !0, forced: n(612) }, { all: function (t) { var e = this, n = o.f(e), r = n.resolve, c = n.reject, u = s((function () { var n = a(e.resolve), o = [], s = 0, u = 1; l(t, (function (t) { var a = s++, l = !1; u++, i(n, e, t).then((function (t) { l || (l = !0, o[a] = t, --u || r(o)) }), c) })), --u || r(o) })); return u.error && c(u.value), n.promise } }) }, 4164: function (t, e, n) { "use strict"; var r = n(2109), i = n(1913), a = n(3702).CONSTRUCTOR, o = n(2492), s = n(5005), l = n(614), c = n(8052), u = o && o.prototype; if (r({ target: "Promise", proto: !0, forced: a, real: !0 }, { catch: function (t) { return this.then(void 0, t) } }), !i && l(o)) { var h = s("Promise").prototype.catch; u.catch !== h && c(u, "catch", h, { unsafe: !0 }) } }, 3401: function (t, e, n) { "use strict"; var r, i, a, o = n(2109), s = n(1913), l = n(5268), c = n(7854), u = n(6916), h = n(8052), d = n(7674), f = n(8003), p = n(6340), m = n(9662), g = n(614), v = n(111), _ = n(5787), y = n(6707), x = n(261).set, b = n(5948), M = n(842), w = n(2534), S = n(8572), T = n(9909), E = n(2492), A = n(3702), C = n(8523), L = "Promise", P = A.CONSTRUCTOR, R = A.REJECTION_EVENT, D = A.SUBCLASSING, I = T.getterFor(L), O = T.set, N = E && E.prototype, z = E, F = N, U = c.TypeError, k = c.document, B = c.process, V = C.f, G = V, H = !!(k && k.createEvent && c.dispatchEvent), W = "unhandledrejection", j = function (t) { var e; return !(!v(t) || !g(e = t.then)) && e }, q = function (t, e) { var n, r, i, a = e.value, o = 1 == e.state, s = o ? t.ok : t.fail, l = t.resolve, c = t.reject, h = t.domain; try { s ? (o || (2 === e.rejection && J(e), e.rejection = 1), !0 === s ? n = a : (h && h.enter(), n = s(a), h && (h.exit(), i = !0)), n === t.promise ? c(U("Promise-chain cycle")) : (r = j(n)) ? u(r, n, l, c) : l(n)) : c(a) } catch (t) { h && !i && h.exit(), c(t) } }, X = function (t, e) { t.notified || (t.notified = !0, b((function () { for (var n, r = t.reactions; n = r.get();)q(n, t); t.notified = !1, e && !t.rejection && Z(t) }))) }, Y = function (t, e, n) { var r, i; H ? ((r = k.createEvent("Event")).promise = e, r.reason = n, r.initEvent(t, !1, !0), c.dispatchEvent(r)) : r = { promise: e, reason: n }, !R && (i = c["on" + t]) ? i(r) : t === W && M("Unhandled promise rejection", n) }, Z = function (t) { u(x, c, (function () { var e, n = t.facade, r = t.value; if (K(t) && (e = w((function () { l ? B.emit("unhandledRejection", r, n) : Y(W, n, r) })), t.rejection = l || K(t) ? 2 : 1, e.error)) throw e.value })) }, K = function (t) { return 1 !== t.rejection && !t.parent }, J = function (t) { u(x, c, (function () { var e = t.facade; l ? B.emit("rejectionHandled", e) : Y("rejectionhandled", e, t.value) })) }, Q = function (t, e, n) { return function (r) { t(e, r, n) } }, $ = function (t, e, n) { t.done || (t.done = !0, n && (t = n), t.value = e, t.state = 2, X(t, !0)) }, tt = function (t, e, n) { if (!t.done) { t.done = !0, n && (t = n); try { if (t.facade === e) throw U("Promise can't be resolved itself"); var r = j(e); r ? b((function () { var n = { done: !1 }; try { u(r, e, Q(tt, n, t), Q($, n, t)) } catch (e) { $(n, e, t) } })) : (t.value = e, t.state = 1, X(t, !1)) } catch (e) { $({ done: !1 }, e, t) } } }; if (P && (F = (z = function (t) { _(this, F), m(t), u(r, this); var e = I(this); try { t(Q(tt, e), Q($, e)) } catch (t) { $(e, t) } }).prototype, (r = function (t) { O(this, { type: L, done: !1, notified: !1, parent: !1, reactions: new S, rejection: !1, state: 0, value: void 0 }) }).prototype = h(F, "then", (function (t, e) { var n = I(this), r = V(y(this, z)); return n.parent = !0, r.ok = !g(t) || t, r.fail = g(e) && e, r.domain = l ? B.domain : void 0, 0 == n.state ? n.reactions.add(r) : b((function () { q(r, n) })), r.promise })), i = function () { var t = new r, e = I(t); this.promise = t, this.resolve = Q(tt, e), this.reject = Q($, e) }, C.f = V = function (t) { return t === z || void 0 === t ? new i(t) : G(t) }, !s && g(E) && N !== Object.prototype)) { a = N.then, D || h(N, "then", (function (t, e) { var n = this; return new z((function (t, e) { u(a, n, t, e) })).then(t, e) }), { unsafe: !0 }); try { delete N.constructor } catch (t) { } d && d(N, F) } o({ global: !0, constructor: !0, wrap: !0, forced: P }, { Promise: z }), f(z, L, !1, !0), p(L) }, 8674: function (t, e, n) { n(3401), n(821), n(4164), n(6027), n(683), n(6294) }, 6027: function (t, e, n) { "use strict"; var r = n(2109), i = n(6916), a = n(9662), o = n(8523), s = n(2534), l = n(408); r({ target: "Promise", stat: !0, forced: n(612) }, { race: function (t) { var e = this, n = o.f(e), r = n.reject, c = s((function () { var o = a(e.resolve); l(t, (function (t) { i(o, e, t).then(n.resolve, r) })) })); return c.error && r(c.value), n.promise } }) }, 683: function (t, e, n) { "use strict"; var r = n(2109), i = n(6916), a = n(8523); r({ target: "Promise", stat: !0, forced: n(3702).CONSTRUCTOR }, { reject: function (t) { var e = a.f(this); return i(e.reject, void 0, t), e.promise } }) }, 6294: function (t, e, n) { "use strict"; var r = n(2109), i = n(5005), a = n(1913), o = n(2492), s = n(3702).CONSTRUCTOR, l = n(9478), c = i("Promise"), u = a && !s; r({ target: "Promise", stat: !0, forced: a || s }, { resolve: function (t) { return l(u && this === c ? o : this, t) } }) }, 8783: function (t, e, n) { "use strict"; var r = n(8710).charAt, i = n(1340), a = n(9909), o = n(1656), s = "String Iterator", l = a.set, c = a.getterFor(s); o(String, "String", (function (t) { l(this, { type: s, string: i(t), index: 0 }) }), (function () { var t, e = c(this), n = e.string, i = e.index; return i >= n.length ? { value: void 0, done: !0 } : (t = r(n, i), e.index += t.length, { value: t, done: !1 }) })) }, 2443: function (t, e, n) { n(6800)("asyncIterator") }, 34: function (t, e, n) { "use strict"; var r = n(2109), i = n(7854), a = n(6916), o = n(1702), s = n(1913), l = n(9781), c = n(6293), u = n(7293), h = n(2597), d = n(7976), f = n(9670), p = n(5656), m = n(4948), g = n(1340), v = n(9114), _ = n(30), y = n(1956), x = n(8006), b = n(1156), M = n(5181), w = n(1236), S = n(3070), T = n(6048), E = n(5296), A = n(8052), C = n(2309), L = n(6200), P = n(3501), R = n(9711), D = n(5112), I = n(6061), O = n(6800), N = n(6532), z = n(8003), F = n(9909), U = n(2092).forEach, k = L("hidden"), B = "Symbol", V = F.set, G = F.getterFor(B), H = Object.prototype, W = i.Symbol, j = W && W.prototype, q = i.TypeError, X = i.QObject, Y = w.f, Z = S.f, K = b.f, J = E.f, Q = o([].push), $ = C("symbols"), tt = C("op-symbols"), et = C("wks"), nt = !X || !X.prototype || !X.prototype.findChild, rt = l && u((function () { return 7 != _(Z({}, "a", { get: function () { return Z(this, "a", { value: 7 }).a } })).a })) ? function (t, e, n) { var r = Y(H, e); r && delete H[e], Z(t, e, n), r && t !== H && Z(H, e, r) } : Z, it = function (t, e) { var n = $[t] = _(j); return V(n, { type: B, tag: t, description: e }), l || (n.description = e), n }, at = function (t, e, n) { t === H && at(tt, e, n), f(t); var r = m(e); return f(n), h($, r) ? (n.enumerable ? (h(t, k) && t[k][r] && (t[k][r] = !1), n = _(n, { enumerable: v(0, !1) })) : (h(t, k) || Z(t, k, v(1, {})), t[k][r] = !0), rt(t, r, n)) : Z(t, r, n) }, ot = function (t, e) { f(t); var n = p(e), r = y(n).concat(ut(n)); return U(r, (function (e) { l && !a(st, n, e) || at(t, e, n[e]) })), t }, st = function (t) { var e = m(t), n = a(J, this, e); return !(this === H && h($, e) && !h(tt, e)) && (!(n || !h(this, e) || !h($, e) || h(this, k) && this[k][e]) || n) }, lt = function (t, e) { var n = p(t), r = m(e); if (n !== H || !h($, r) || h(tt, r)) { var i = Y(n, r); return !i || !h($, r) || h(n, k) && n[k][r] || (i.enumerable = !0), i } }, ct = function (t) { var e = K(p(t)), n = []; return U(e, (function (t) { h($, t) || h(P, t) || Q(n, t) })), n }, ut = function (t) { var e = t === H, n = K(e ? tt : p(t)), r = []; return U(n, (function (t) { !h($, t) || e && !h(H, t) || Q(r, $[t]) })), r }; c || (W = function () { if (d(j, this)) throw q("Symbol is not a constructor"); var t = arguments.length && void 0 !== arguments[0] ? g(arguments[0]) : void 0, e = R(t), n = function (t) { this === H && a(n, tt, t), h(this, k) && h(this[k], e) && (this[k][e] = !1), rt(this, e, v(1, t)) }; return l && nt && rt(H, e, { configurable: !0, set: n }), it(e, t) }, A(j = W.prototype, "toString", (function () { return G(this).tag })), A(W, "withoutSetter", (function (t) { return it(R(t), t) })), E.f = st, S.f = at, T.f = ot, w.f = lt, x.f = b.f = ct, M.f = ut, I.f = function (t) { return it(D(t), t) }, l && (Z(j, "description", { configurable: !0, get: function () { return G(this).description } }), s || A(H, "propertyIsEnumerable", st, { unsafe: !0 }))), r({ global: !0, constructor: !0, wrap: !0, forced: !c, sham: !c }, { Symbol: W }), U(y(et), (function (t) { O(t) })), r({ target: B, stat: !0, forced: !c }, { useSetter: function () { nt = !0 }, useSimple: function () { nt = !1 } }), r({ target: "Object", stat: !0, forced: !c, sham: !l }, { create: function (t, e) { return void 0 === e ? _(t) : ot(_(t), e) }, defineProperty: at, defineProperties: ot, getOwnPropertyDescriptor: lt }), r({ target: "Object", stat: !0, forced: !c }, { getOwnPropertyNames: ct }), N(), z(W, B), P[k] = !0 }, 1817: function (t, e, n) { "use strict"; var r = n(2109), i = n(9781), a = n(7854), o = n(1702), s = n(2597), l = n(614), c = n(7976), u = n(1340), h = n(3070).f, d = n(9920), f = a.Symbol, p = f && f.prototype; if (i && l(f) && (!("description" in p) || void 0 !== f().description)) { var m = {}, g = function () { var t = arguments.length < 1 || void 0 === arguments[0] ? void 0 : u(arguments[0]), e = c(p, this) ? new f(t) : void 0 === t ? f() : f(t); return "" === t && (m[e] = !0), e }; d(g, f), g.prototype = p, p.constructor = g; var v = "Symbol(test)" == String(f("test")), _ = o(p.valueOf), y = o(p.toString), x = /^Symbol\((.*)\)[^)]+$/, b = o("".replace), M = o("".slice); h(p, "description", { configurable: !0, get: function () { var t = _(this); if (s(m, t)) return ""; var e = y(t), n = v ? M(e, 7, -1) : b(e, x, "$1"); return "" === n ? void 0 : n } }), r({ global: !0, constructor: !0, forced: !0 }, { Symbol: g }) } }, 763: function (t, e, n) { var r = n(2109), i = n(5005), a = n(2597), o = n(1340), s = n(2309), l = n(2015), c = s("string-to-symbol-registry"), u = s("symbol-to-string-registry"); r({ target: "Symbol", stat: !0, forced: !l }, { for: function (t) { var e = o(t); if (a(c, e)) return c[e]; var n = i("Symbol")(e); return c[e] = n, u[n] = e, n } }) }, 2165: function (t, e, n) { n(6800)("iterator") }, 2526: function (t, e, n) { n(34), n(763), n(6620), n(8862), n(9660) }, 6620: function (t, e, n) { var r = n(2109), i = n(2597), a = n(2190), o = n(6330), s = n(2309), l = n(2015), c = s("symbol-to-string-registry"); r({ target: "Symbol", stat: !0, forced: !l }, { keyFor: function (t) { if (!a(t)) throw TypeError(o(t) + " is not a symbol"); if (i(c, t)) return c[t] } }) }, 3680: function (t, e, n) { var r = n(5005), i = n(6800), a = n(8003); i("toStringTag"), a(r("Symbol"), "Symbol") }, 2990: function (t, e, n) { "use strict"; var r = n(1702), i = n(260), a = r(n(1048)), o = i.aTypedArray; (0, i.exportTypedArrayMethod)("copyWithin", (function (t, e) { return a(o(this), t, e, arguments.length > 2 ? arguments[2] : void 0) })) }, 8927: function (t, e, n) { "use strict"; var r = n(260), i = n(2092).every, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("every", (function (t) { return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, 3105: function (t, e, n) { "use strict"; var r = n(260), i = n(1285), a = n(4599), o = n(648), s = n(6916), l = n(1702), c = n(7293), u = r.aTypedArray, h = r.exportTypedArrayMethod, d = l("".slice); h("fill", (function (t) { var e = arguments.length; u(this); var n = "Big" === d(o(this), 0, 3) ? a(t) : +t; return s(i, this, n, e > 1 ? arguments[1] : void 0, e > 2 ? arguments[2] : void 0) }), c((function () { var t = 0; return new Int8Array(2).fill({ valueOf: function () { return t++ } }), 1 !== t }))) }, 5035: function (t, e, n) { "use strict"; var r = n(260), i = n(2092).filter, a = n(3074), o = r.aTypedArray; (0, r.exportTypedArrayMethod)("filter", (function (t) { var e = i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); return a(this, e) })) }, 7174: function (t, e, n) { "use strict"; var r = n(260), i = n(2092).findIndex, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("findIndex", (function (t) { return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, 4345: function (t, e, n) { "use strict"; var r = n(260), i = n(2092).find, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("find", (function (t) { return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, 4197: function (t, e, n) { n(9843)("Float32", (function (t) { return function (e, n, r) { return t(this, e, n, r) } })) }, 2846: function (t, e, n) { "use strict"; var r = n(260), i = n(2092).forEach, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("forEach", (function (t) { i(a(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, 4731: function (t, e, n) { "use strict"; var r = n(260), i = n(1318).includes, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("includes", (function (t) { return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, 7209: function (t, e, n) { "use strict"; var r = n(260), i = n(1318).indexOf, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("indexOf", (function (t) { return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, 6319: function (t, e, n) { "use strict"; var r = n(7854), i = n(7293), a = n(1702), o = n(260), s = n(6992), l = n(5112)("iterator"), c = r.Uint8Array, u = a(s.values), h = a(s.keys), d = a(s.entries), f = o.aTypedArray, p = o.exportTypedArrayMethod, m = c && c.prototype, g = !i((function () { m[l].call([1]) })), v = !!m && m.values && m[l] === m.values && "values" === m.values.name, _ = function () { return u(f(this)) }; p("entries", (function () { return d(f(this)) }), g), p("keys", (function () { return h(f(this)) }), g), p("values", _, g || !v, { name: "values" }), p(l, _, g || !v, { name: "values" }) }, 8867: function (t, e, n) { "use strict"; var r = n(260), i = n(1702), a = r.aTypedArray, o = r.exportTypedArrayMethod, s = i([].join); o("join", (function (t) { return s(a(this), t) })) }, 7789: function (t, e, n) { "use strict"; var r = n(260), i = n(2104), a = n(6583), o = r.aTypedArray; (0, r.exportTypedArrayMethod)("lastIndexOf", (function (t) { var e = arguments.length; return i(a, o(this), e > 1 ? [t, arguments[1]] : [t]) })) }, 3739: function (t, e, n) { "use strict"; var r = n(260), i = n(2092).map, a = n(6304), o = r.aTypedArray; (0, r.exportTypedArrayMethod)("map", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0, (function (t, e) { return new (a(t))(e) })) })) }, 4483: function (t, e, n) { "use strict"; var r = n(260), i = n(3671).right, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("reduceRight", (function (t) { var e = arguments.length; return i(a(this), t, e, e > 1 ? arguments[1] : void 0) })) }, 9368: function (t, e, n) { "use strict"; var r = n(260), i = n(3671).left, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("reduce", (function (t) { var e = arguments.length; return i(a(this), t, e, e > 1 ? arguments[1] : void 0) })) }, 2056: function (t, e, n) { "use strict"; var r = n(260), i = r.aTypedArray, a = r.exportTypedArrayMethod, o = Math.floor; a("reverse", (function () { for (var t, e = this, n = i(e).length, r = o(n / 2), a = 0; a < r;)t = e[a], e[a++] = e[--n], e[n] = t; return e })) }, 3462: function (t, e, n) { "use strict"; var r = n(7854), i = n(6916), a = n(260), o = n(6244), s = n(4590), l = n(7908), c = n(7293), u = r.RangeError, h = r.Int8Array, d = h && h.prototype, f = d && d.set, p = a.aTypedArray, m = a.exportTypedArrayMethod, g = !c((function () { var t = new Uint8ClampedArray(2); return i(f, t, { length: 1, 0: 3 }, 1), 3 !== t[1] })), v = g && a.NATIVE_ARRAY_BUFFER_VIEWS && c((function () { var t = new h(2); return t.set(1), t.set("2", 1), 0 !== t[0] || 2 !== t[1] })); m("set", (function (t) { p(this); var e = s(arguments.length > 1 ? arguments[1] : void 0, 1), n = l(t); if (g) return i(f, this, n, e); var r = this.length, a = o(n), c = 0; if (a + e > r) throw u("Wrong length"); for (; c < a;)this[e + c] = n[c++] }), !g || v) }, 678: function (t, e, n) { "use strict"; var r = n(260), i = n(6304), a = n(7293), o = n(206), s = r.aTypedArray; (0, r.exportTypedArrayMethod)("slice", (function (t, e) { for (var n = o(s(this), t, e), r = i(this), a = 0, l = n.length, c = new r(l); l > a;)c[a] = n[a++]; return c }), a((function () { new Int8Array(1).slice() }))) }, 7462: function (t, e, n) { "use strict"; var r = n(260), i = n(2092).some, a = r.aTypedArray; (0, r.exportTypedArrayMethod)("some", (function (t) { return i(a(this), t, arguments.length > 1 ? arguments[1] : void 0) })) }, 3824: function (t, e, n) { "use strict"; var r = n(7854), i = n(1702), a = n(7293), o = n(9662), s = n(4362), l = n(260), c = n(8886), u = n(256), h = n(7392), d = n(8008), f = l.aTypedArray, p = l.exportTypedArrayMethod, m = r.Uint16Array, g = m && i(m.prototype.sort), v = !(!g || a((function () { g(new m(2), null) })) && a((function () { g(new m(2), {}) }))), _ = !!g && !a((function () { if (h) return h < 74; if (c) return c < 67; if (u) return !0; if (d) return d < 602; var t, e, n = new m(516), r = Array(516); for (t = 0; t < 516; t++)e = t % 4, n[t] = 515 - t, r[t] = t - 2 * e + 3; for (g(n, (function (t, e) { return (t / 4 | 0) - (e / 4 | 0) })), t = 0; t < 516; t++)if (n[t] !== r[t]) return !0 })); p("sort", (function (t) { return void 0 !== t && o(t), _ ? g(this, t) : s(f(this), function (t) { return function (e, n) { return void 0 !== t ? +t(e, n) || 0 : n != n ? -1 : e != e ? 1 : 0 === e && 0 === n ? 1 / e > 0 && 1 / n < 0 ? 1 : -1 : e > n } }(t)) }), !_ || v) }, 5021: function (t, e, n) { "use strict"; var r = n(260), i = n(7466), a = n(1400), o = n(6304), s = r.aTypedArray; (0, r.exportTypedArrayMethod)("subarray", (function (t, e) { var n = s(this), r = n.length, l = a(t, r); return new (o(n))(n.buffer, n.byteOffset + l * n.BYTES_PER_ELEMENT, i((void 0 === e ? r : a(e, r)) - l)) })) }, 2974: function (t, e, n) { "use strict"; var r = n(7854), i = n(2104), a = n(260), o = n(7293), s = n(206), l = r.Int8Array, c = a.aTypedArray, u = a.exportTypedArrayMethod, h = [].toLocaleString, d = !!l && o((function () { h.call(new l(1)) })); u("toLocaleString", (function () { return i(h, d ? s(c(this)) : c(this), s(arguments)) }), o((function () { return [1, 2].toLocaleString() != new l([1, 2]).toLocaleString() })) || !o((function () { l.prototype.toLocaleString.call([1, 2]) }))) }, 5016: function (t, e, n) { "use strict"; var r = n(260).exportTypedArrayMethod, i = n(7293), a = n(7854), o = n(1702), s = a.Uint8Array, l = s && s.prototype || {}, c = [].toString, u = o([].join); i((function () { c.call({}) })) && (c = function () { return u(this) }); var h = l.toString != c; r("toString", c, h) }, 4747: function (t, e, n) { var r = n(7854), i = n(8324), a = n(8509), o = n(8533), s = n(8880), l = function (t) { if (t && t.forEach !== o) try { s(t, "forEach", o) } catch (e) { t.forEach = o } }; for (var c in i) i[c] && l(r[c] && r[c].prototype); l(a) }, 3948: function (t, e, n) { var r = n(7854), i = n(8324), a = n(8509), o = n(6992), s = n(8880), l = n(5112), c = l("iterator"), u = l("toStringTag"), h = o.values, d = function (t, e) { if (t) { if (t[c] !== h) try { s(t, c, h) } catch (e) { t[c] = h } if (t[u] || s(t, u, e), i[e]) for (var n in o) if (t[n] !== o[n]) try { s(t, n, o[n]) } catch (e) { t[n] = o[n] } } }; for (var f in i) d(r[f] && r[f].prototype, f); d(a, "DOMTokenList") }, 7882: function (t, e) { "use strict"; e.__esModule = !0; var n = function () { function t() { this.handlers = {} } return t.prototype.on = function (t, e) { var n = this.handlers[t]; return n || (n = [], this.handlers[t] = n), this.handlers[t].push(e), e }, t.prototype.off = function (t, e) { var n = this.handlers[t]; if (e) { var r = n.indexOf(e); -1 !== r && this.handlers[t].splice(r, 1) } }, t.prototype.offAll = function () { this.handlers = {} }, t.prototype.emit = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; var r = this.handlers[t]; r && r.forEach((function (t) { return t.apply(void 0, e) })) }, t }(); e.EventEmitter = n }, 7265: function (t, e, n) { "use strict"; e.__esModule = !0, function (t) { for (var n in t) e.hasOwnProperty(n) || (e[n] = t[n]) }(n(7882)) } }, e = {}; function n(r) { var i = e[r]; if (void 0 !== i) return i.exports; var a = e[r] = { exports: {} }; return t[r](a, a.exports, n), a.exports } n.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (t) { if ("object" == typeof window) return window } }(), n.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }; var r = {}; return function () { "use strict"; n.r(r), n(3290), n(1539), n(4747), n(9653), n(8674), n(2526), n(1817), n(2165), n(6992), n(8783), n(3948), n(2443), n(3680), n(3706), n(2703), n(489), n(8309), n(7042); const t = 100, e = 301, i = 302, a = 306, o = 1e3, s = 1001, l = 1002, c = 1003, u = 1006, h = 1008, d = 1009, f = 1014, p = 1015, m = 1016, g = 1020, v = 1023, _ = 1026, y = 1027, x = 33776, b = 33777, M = 33778, w = 33779, S = 2300, T = 2301, E = 2302, A = 3e3, C = 3001, L = "srgb", P = "srgb-linear", R = 7680, D = "300 es", I = 1035; class O { addEventListener(t, e) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e) } hasEventListener(t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) } removeEventListener(t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); -1 !== t && n.splice(t, 1) } } dispatchEvent(t) { if (void 0 === this._listeners) return; const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; const n = e.slice(0); for (let e = 0, r = n.length; e < r; e++)n[e].call(this, t); t.target = null } } } const N = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], z = Math.PI / 180, F = 180 / Math.PI; function U() { const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (N[255 & t] + N[t >> 8 & 255] + N[t >> 16 & 255] + N[t >> 24 & 255] + "-" + N[255 & e] + N[e >> 8 & 255] + "-" + N[e >> 16 & 15 | 64] + N[e >> 24 & 255] + "-" + N[63 & n | 128] + N[n >> 8 & 255] + "-" + N[n >> 16 & 255] + N[n >> 24 & 255] + N[255 & r] + N[r >> 8 & 255] + N[r >> 16 & 255] + N[r >> 24 & 255]).toLowerCase() } function k(t, e, n) { return Math.max(e, Math.min(n, t)) } function B(t, e, n) { return (1 - n) * t + n * e } function V(t) { return 0 == (t & t - 1) && 0 !== t } function G(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) } class H { constructor(t = 0, e = 0) { H.prototype.isVector2 = !0, this.x = t, this.y = e } get width() { return this.x } set width(t) { this.x = t } get height() { return this.y } set height(t) { this.y = t } set(t, e) { return this.x = t, this.y = e, this } setScalar(t) { return this.x = t, this.y = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y) } copy(t) { return this.x = t.x, this.y = t.y, this } add(t) { return this.x += t.x, this.y += t.y, this } addScalar(t) { return this.x += t, this.y += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this } sub(t) { return this.x -= t.x, this.y -= t.y, this } subScalar(t) { return this.x -= t, this.y -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this } divide(t) { return this.x /= t.x, this.y /= t.y, this } divideScalar(t) { return this.multiplyScalar(1 / t) } applyMatrix3(t) { const e = this.x, n = this.y, r = t.elements; return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(t) { return this.x * t.x + this.y * t.y } cross(t) { return this.x * t.y - this.y * t.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y; return e * e + n * n } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this } equals(t) { return t.x === this.x && t.y === this.y } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t } fromBufferAttribute(t, e) { return this.x = t.getX(e), this.y = t.getY(e), this } rotateAround(t, e) { const n = Math.cos(e), r = Math.sin(e), i = this.x - t.x, a = this.y - t.y; return this.x = i * n - a * r + t.x, this.y = i * r + a * n + t.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class W { constructor() { W.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1] } set(t, e, n, r, i, a, o, s, l) { const c = this.elements; return c[0] = t, c[1] = r, c[2] = o, c[3] = e, c[4] = i, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this } extractBasis(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply(t) { return this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, r = e.elements, i = this.elements, a = n[0], o = n[3], s = n[6], l = n[1], c = n[4], u = n[7], h = n[2], d = n[5], f = n[8], p = r[0], m = r[3], g = r[6], v = r[1], _ = r[4], y = r[7], x = r[2], b = r[5], M = r[8]; return i[0] = a * p + o * v + s * x, i[3] = a * m + o * _ + s * b, i[6] = a * g + o * y + s * M, i[1] = l * p + c * v + u * x, i[4] = l * m + c * _ + u * b, i[7] = l * g + c * y + u * M, i[2] = h * p + d * v + f * x, i[5] = h * m + d * _ + f * b, i[8] = h * g + d * y + f * M, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], o = t[5], s = t[6], l = t[7], c = t[8]; return e * a * c - e * o * l - n * i * c + n * o * s + r * i * l - r * a * s } invert() { const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], o = t[5], s = t[6], l = t[7], c = t[8], u = c * a - o * l, h = o * s - c * i, d = l * i - a * s, f = e * u + n * h + r * d; if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const p = 1 / f; return t[0] = u * p, t[1] = (r * l - c * n) * p, t[2] = (o * n - r * a) * p, t[3] = h * p, t[4] = (c * e - r * s) * p, t[5] = (r * i - o * e) * p, t[6] = d * p, t[7] = (n * s - l * e) * p, t[8] = (a * e - n * i) * p, this } transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this } getNormalMatrix(t) { return this.setFromMatrix4(t).invert().transpose() } transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this } setUvTransform(t, e, n, r, i, a, o) { const s = Math.cos(i), l = Math.sin(i); return this.set(n * s, n * l, -n * (s * a + l * o) + a + t, -r * l, r * s, -r * (-l * a + s * o) + o + e, 0, 0, 1), this } scale(t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this } rotate(t) { const e = Math.cos(t), n = Math.sin(t), r = this.elements, i = r[0], a = r[3], o = r[6], s = r[1], l = r[4], c = r[7]; return r[0] = e * i + n * s, r[3] = e * a + n * l, r[6] = e * o + n * c, r[1] = -n * i + e * s, r[4] = -n * a + e * l, r[7] = -n * o + e * c, this } translate(t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this } equals(t) { const e = this.elements, n = t.elements; for (let t = 0; t < 9; t++)if (e[t] !== n[t]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } clone() { return (new this.constructor).fromArray(this.elements) } } function j(t) { for (let e = t.length - 1; e >= 0; --e)if (t[e] > 65535) return !0; return !1 } function q(t) { return document.createElementNS("http://www.w3.org/1999/xhtml", t) } function X(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function Y(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array; const Z = { [L]: { [P]: X }, [P]: { [L]: Y } }, K = { legacyMode: !0, get workingColorSpace() { return P }, set workingColorSpace(t) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (t, e, n) { if (this.legacyMode || e === n || !e || !n) return t; if (Z[e] && void 0 !== Z[e][n]) { const r = Z[e][n]; return t.r = r(t.r), t.g = r(t.g), t.b = r(t.b), t } throw new Error("Unsupported color space conversion.") }, fromWorkingColorSpace: function (t, e) { return this.convert(t, this.workingColorSpace, e) }, toWorkingColorSpace: function (t, e) { return this.convert(t, e, this.workingColorSpace) } }, J = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Q = { r: 0, g: 0, b: 0 }, $ = { h: 0, s: 0, l: 0 }, tt = { h: 0, s: 0, l: 0 }; function et(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } function nt(t, e) { return e.r = t.r, e.g = t.g, e.b = t.b, e } class rt { constructor(t, e, n) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this } setScalar(t) { return this.r = t, this.g = t, this.b = t, this } setHex(t, e = "srgb") { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, K.toWorkingColorSpace(this, e), this } setRGB(t, e, n, r = "srgb-linear") { return this.r = t, this.g = e, this.b = n, K.toWorkingColorSpace(this, r), this } setHSL(t, e, n, r = "srgb-linear") { if (t = function (t, e) { return (t % e + e) % e }(t, 1), e = k(e, 0, 1), n = k(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else { const r = n <= .5 ? n * (1 + e) : n + e - n * e, i = 2 * n - r; this.r = et(i, r, t + 1 / 3), this.g = et(i, r, t), this.b = et(i, r, t - 1 / 3) } return K.toWorkingColorSpace(this, r), this } setStyle(t, e = "srgb") { function n(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let r; if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) { let t; const i = r[1], a = r[2]; switch (i) { case "rgb": case "rgba": if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, K.toWorkingColorSpace(this, e), n(t[4]), this; if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, K.toWorkingColorSpace(this, e), n(t[4]), this; break; case "hsl": case "hsla": if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) { const r = parseFloat(t[1]) / 360, i = parseInt(t[2], 10) / 100, a = parseInt(t[3], 10) / 100; return n(t[4]), this.setHSL(r, i, a, e) } } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) { const t = r[1], n = t.length; if (3 === n) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, K.toWorkingColorSpace(this, e), this; if (6 === n) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, K.toWorkingColorSpace(this, e), this } return t && t.length > 0 ? this.setColorName(t, e) : this } setColorName(t, e = "srgb") { const n = J[t.toLowerCase()]; return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this } copySRGBToLinear(t) { return this.r = X(t.r), this.g = X(t.g), this.b = X(t.b), this } copyLinearToSRGB(t) { return this.r = Y(t.r), this.g = Y(t.g), this.b = Y(t.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(t = "srgb") { return K.fromWorkingColorSpace(nt(this, Q), t), k(255 * Q.r, 0, 255) << 16 ^ k(255 * Q.g, 0, 255) << 8 ^ k(255 * Q.b, 0, 255) << 0 } getHexString(t = "srgb") { return ("000000" + this.getHex(t).toString(16)).slice(-6) } getHSL(t, e = "srgb-linear") { K.fromWorkingColorSpace(nt(this, Q), e); const n = Q.r, r = Q.g, i = Q.b, a = Math.max(n, r, i), o = Math.min(n, r, i); let s, l; const c = (o + a) / 2; if (o === a) s = 0, l = 0; else { const t = a - o; switch (l = c <= .5 ? t / (a + o) : t / (2 - a - o), a) { case n: s = (r - i) / t + (r < i ? 6 : 0); break; case r: s = (i - n) / t + 2; break; case i: s = (n - r) / t + 4 }s /= 6 } return t.h = s, t.s = l, t.l = c, t } getRGB(t, e = "srgb-linear") { return K.fromWorkingColorSpace(nt(this, Q), e), t.r = Q.r, t.g = Q.g, t.b = Q.b, t } getStyle(t = "srgb") { return K.fromWorkingColorSpace(nt(this, Q), t), t !== L ? `color(${t} ${Q.r} ${Q.g} ${Q.b})` : `rgb(${255 * Q.r | 0},${255 * Q.g | 0},${255 * Q.b | 0})` } offsetHSL(t, e, n) { return this.getHSL($), $.h += t, $.s += e, $.l += n, this.setHSL($.h, $.s, $.l), this } add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this } addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this } addScalar(t) { return this.r += t, this.g += t, this.b += t, this } sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this } multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this } multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this } lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this } lerpColors(t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this } lerpHSL(t, e) { this.getHSL($), t.getHSL(tt); const n = B($.h, tt.h, e), r = B($.s, tt.s, e), i = B($.l, tt.l, e); return this.setHSL(n, r, i), this } equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b } fromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t } fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } let it; rt.NAMES = J; class at { static getDataURL(t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === it && (it = q("canvas")), it.width = t.width, it.height = t.height; const n = it.getContext("2d"); t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = it } return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png") } static sRGBToLinear(t) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const e = q("canvas"); e.width = t.width, e.height = t.height; const n = e.getContext("2d"); n.drawImage(t, 0, 0, t.width, t.height); const r = n.getImageData(0, 0, t.width, t.height), i = r.data; for (let t = 0; t < i.length; t++)i[t] = 255 * X(i[t] / 255); return n.putImageData(r, 0, 0), e } if (t.data) { const e = t.data.slice(0); for (let t = 0; t < e.length; t++)e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * X(e[t] / 255)) : e[t] = X(e[t]); return { data: e, width: t.width, height: t.height } } return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t } } class ot { constructor(t = null) { this.isSource = !0, this.uuid = U(), this.data = t, this.version = 0 } set needsUpdate(t) { !0 === t && this.version++ } toJSON(t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid]; const n = { uuid: this.uuid, url: "" }, r = this.data; if (null !== r) { let t; if (Array.isArray(r)) { t = []; for (let e = 0, n = r.length; e < n; e++)r[e].isDataTexture ? t.push(st(r[e].image)) : t.push(st(r[e])) } else t = st(r); n.url = t } return e || (t.images[this.uuid] = n), n } } function st(t) { return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? at.getDataURL(t) : t.data ? { data: Array.from(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let lt = 0; class ct extends O { constructor(t = ct.DEFAULT_IMAGE, e = ct.DEFAULT_MAPPING, n = 1001, r = 1001, i = 1006, a = 1008, o = 1023, s = 1009, l = 1, c = 3e3) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: lt++ }), this.uuid = U(), this.name = "", this.source = new ot(t), this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = s, this.offset = new H(0, 0), this.repeat = new H(1, 1), this.center = new H(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new W, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(t) { this.source.data = t } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this } toJSON(t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(t).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case o: t.x = t.x - Math.floor(t.x); break; case s: t.x = t.x < 0 ? 0 : 1; break; case l: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case o: t.y = t.y - Math.floor(t.y); break; case s: t.y = t.y < 0 ? 0 : 1; break; case l: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } set needsUpdate(t) { !0 === t && (this.version++, this.source.needsUpdate = !0) } } ct.DEFAULT_IMAGE = null, ct.DEFAULT_MAPPING = 300; class ut { constructor(t = 0, e = 0, n = 0, r = 1) { ut.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = r } get width() { return this.z } set width(t) { this.z = t } get height() { return this.w } set height(t) { this.w = t } set(t, e, n, r) { return this.x = t, this.y = e, this.z = n, this.w = r, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setW(t) { return this.w = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this } add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this } addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this } sub(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this } applyMatrix4(t) { const e = this.x, n = this.y, r = this.z, i = this.w, a = t.elements; return this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * i, this } divideScalar(t) { return this.multiplyScalar(1 / t) } setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this } setAxisAngleFromRotationMatrix(t) { let e, n, r, i; const a = .01, o = .1, s = t.elements, l = s[0], c = s[4], u = s[8], h = s[1], d = s[5], f = s[9], p = s[2], m = s[6], g = s[10]; if (Math.abs(c - h) < a && Math.abs(u - p) < a && Math.abs(f - m) < a) { if (Math.abs(c + h) < o && Math.abs(u + p) < o && Math.abs(f + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this; e = Math.PI; const t = (l + 1) / 2, s = (d + 1) / 2, v = (g + 1) / 2, _ = (c + h) / 4, y = (u + p) / 4, x = (f + m) / 4; return t > s && t > v ? t < a ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = _ / n, i = y / n) : s > v ? s < a ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(s), n = _ / r, i = x / r) : v < a ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = y / i, r = x / i), this.set(n, r, i, e), this } let v = Math.sqrt((m - f) * (m - f) + (u - p) * (u - p) + (h - c) * (h - c)); return Math.abs(v) < .001 && (v = 1), this.x = (m - f) / v, this.y = (u - p) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t } fromBufferAttribute(t, e) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class ht extends O { constructor(t, e, n = {}) { super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new ut(0, 0, t, e), this.scissorTest = !1, this.viewport = new ut(0, 0, t, e); const r = { width: t, height: e, depth: 1 }; this.texture = new ct(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : u, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0 } setSize(t, e, n = 1) { this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) } clone() { return (new this.constructor).copy(this) } copy(t) { this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0; const e = Object.assign({}, t.texture.image); return this.texture.source = new ot(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class dt extends ct { constructor(t = null, e = 1, n = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = c, this.minFilter = c, this.wrapR = s, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class ft extends ct { constructor(t = null, e = 1, n = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = c, this.minFilter = c, this.wrapR = s, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class pt { constructor(t = 0, e = 0, n = 0, r = 1) { this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = r } static slerpFlat(t, e, n, r, i, a, o) { let s = n[r + 0], l = n[r + 1], c = n[r + 2], u = n[r + 3]; const h = i[a + 0], d = i[a + 1], f = i[a + 2], p = i[a + 3]; if (0 === o) return t[e + 0] = s, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = u); if (1 === o) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = f, void (t[e + 3] = p); if (u !== p || s !== h || l !== d || c !== f) { let t = 1 - o; const e = s * h + l * d + c * f + u * p, n = e >= 0 ? 1 : -1, r = 1 - e * e; if (r > Number.EPSILON) { const i = Math.sqrt(r), a = Math.atan2(i, e * n); t = Math.sin(t * a) / i, o = Math.sin(o * a) / i } const i = o * n; if (s = s * t + h * i, l = l * t + d * i, c = c * t + f * i, u = u * t + p * i, t === 1 - o) { const t = 1 / Math.sqrt(s * s + l * l + c * c + u * u); s *= t, l *= t, c *= t, u *= t } } t[e] = s, t[e + 1] = l, t[e + 2] = c, t[e + 3] = u } static multiplyQuaternionsFlat(t, e, n, r, i, a) { const o = n[r], s = n[r + 1], l = n[r + 2], c = n[r + 3], u = i[a], h = i[a + 1], d = i[a + 2], f = i[a + 3]; return t[e] = o * f + c * u + s * d - l * h, t[e + 1] = s * f + c * h + l * u - o * d, t[e + 2] = l * f + c * d + o * h - s * u, t[e + 3] = c * f - o * u - s * h - l * d, t } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get w() { return this._w } set w(t) { this._w = t, this._onChangeCallback() } set(t, e, n, r) { return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this } setFromEuler(t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = t._x, r = t._y, i = t._z, a = t._order, o = Math.cos, s = Math.sin, l = o(n / 2), c = o(r / 2), u = o(i / 2), h = s(n / 2), d = s(r / 2), f = s(i / 2); switch (a) { case "XYZ": this._x = h * c * u + l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u - h * d * f; break; case "YXZ": this._x = h * c * u + l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u + h * d * f; break; case "ZXY": this._x = h * c * u - l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u - h * d * f; break; case "ZYX": this._x = h * c * u - l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u + h * d * f; break; case "YZX": this._x = h * c * u + l * d * f, this._y = l * d * u + h * c * f, this._z = l * c * f - h * d * u, this._w = l * c * u - h * d * f; break; case "XZY": this._x = h * c * u - l * d * f, this._y = l * d * u - h * c * f, this._z = l * c * f + h * d * u, this._w = l * c * u + h * d * f; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a) }return !1 !== e && this._onChangeCallback(), this } setFromAxisAngle(t, e) { const n = e / 2, r = Math.sin(n); return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(t) { const e = t.elements, n = e[0], r = e[4], i = e[8], a = e[1], o = e[5], s = e[9], l = e[2], c = e[6], u = e[10], h = n + o + u; if (h > 0) { const t = .5 / Math.sqrt(h + 1); this._w = .25 / t, this._x = (c - s) * t, this._y = (i - l) * t, this._z = (a - r) * t } else if (n > o && n > u) { const t = 2 * Math.sqrt(1 + n - o - u); this._w = (c - s) / t, this._x = .25 * t, this._y = (r + a) / t, this._z = (i + l) / t } else if (o > u) { const t = 2 * Math.sqrt(1 + o - n - u); this._w = (i - l) / t, this._x = (r + a) / t, this._y = .25 * t, this._z = (s + c) / t } else { const t = 2 * Math.sqrt(1 + u - n - o); this._w = (a - r) / t, this._x = (i + l) / t, this._y = (s + c) / t, this._z = .25 * t } return this._onChangeCallback(), this } setFromUnitVectors(t, e) { let n = t.dot(e) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() } angleTo(t) { return 2 * Math.acos(Math.abs(k(this.dot(t), -1, 1))) } rotateTowards(t, e) { const n = this.angleTo(t); if (0 === n) return this; const r = Math.min(1, e / n); return this.slerp(t, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this } multiply(t) { return this.multiplyQuaternions(this, t) } premultiply(t) { return this.multiplyQuaternions(t, this) } multiplyQuaternions(t, e) { const n = t._x, r = t._y, i = t._z, a = t._w, o = e._x, s = e._y, l = e._z, c = e._w; return this._x = n * c + a * o + r * l - i * s, this._y = r * c + a * s + i * o - n * l, this._z = i * c + a * l + n * s - r * o, this._w = a * c - n * o - r * s - i * l, this._onChangeCallback(), this } slerp(t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); const n = this._x, r = this._y, i = this._z, a = this._w; let o = a * t._w + n * t._x + r * t._y + i * t._z; if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this; const s = 1 - o * o; if (s <= Number.EPSILON) { const t = 1 - e; return this._w = t * a + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this } const l = Math.sqrt(s), c = Math.atan2(l, o), u = Math.sin((1 - e) * c) / l, h = Math.sin(e * c) / l; return this._w = a * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this } slerpQuaternions(t, e, n) { return this.copy(t).slerp(e, n) } random() { const t = Math.random(), e = Math.sqrt(1 - t), n = Math.sqrt(t), r = 2 * Math.PI * Math.random(), i = 2 * Math.PI * Math.random(); return this.set(e * Math.cos(r), n * Math.sin(i), n * Math.cos(i), e * Math.sin(r)) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w } fromArray(t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t } fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class mt { constructor(t = 0, e = 0, n = 0) { mt.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n } set(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this } add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this } addScalar(t) { return this.x += t, this.y += t, this.z += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this } sub(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this } multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this } applyEuler(t) { return this.applyQuaternion(vt.setFromEuler(t)) } applyAxisAngle(t, e) { return this.applyQuaternion(vt.setFromAxisAngle(t, e)) } applyMatrix3(t) { const e = this.x, n = this.y, r = this.z, i = t.elements; return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this } applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() } applyMatrix4(t) { const e = this.x, n = this.y, r = this.z, i = t.elements, a = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]); return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * a, this } applyQuaternion(t) { const e = this.x, n = this.y, r = this.z, i = t.x, a = t.y, o = t.z, s = t.w, l = s * e + a * r - o * n, c = s * n + o * e - i * r, u = s * r + i * n - a * e, h = -i * e - a * n - o * r; return this.x = l * s + h * -i + c * -o - u * -a, this.y = c * s + h * -a + u * -i - l * -o, this.z = u * s + h * -o + l * -a - c * -i, this } project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) } unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) } transformDirection(t) { const e = this.x, n = this.y, r = this.z, i = t.elements; return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize() } divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this } divideScalar(t) { return this.multiplyScalar(1 / t) } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this } cross(t) { return this.crossVectors(this, t) } crossVectors(t, e) { const n = t.x, r = t.y, i = t.z, a = e.x, o = e.y, s = e.z; return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this } projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) } projectOnPlane(t) { return gt.copy(this).projectOnVector(t), this.sub(gt) } reflect(t) { return this.sub(gt.copy(t).multiplyScalar(2 * this.dot(t))) } angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(k(n, -1, 1)) } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y, r = this.z - t.z; return e * e + n * n + r * r } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) } setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) } setFromSphericalCoords(t, e, n) { const r = Math.sin(e) * t; return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this } setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) } setFromCylindricalCoords(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this } setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale(t) { const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), r = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = r, this } setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) } setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) } setFromEuler(t) { return this.x = t._x, this.y = t._y, this.z = t._z, this } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t } fromBufferAttribute(t, e) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const t = 2 * (Math.random() - .5), e = Math.random() * Math.PI * 2, n = Math.sqrt(1 - t ** 2); return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const gt = new mt, vt = new pt; class _t { constructor(t = new mt(1 / 0, 1 / 0, 1 / 0), e = new mt(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = t, this.max = e } set(t, e) { return this.min.copy(t), this.max.copy(e), this } setFromArray(t) { let e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0; for (let s = 0, l = t.length; s < l; s += 3) { const l = t[s], c = t[s + 1], u = t[s + 2]; l < e && (e = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > a && (a = c), u > o && (o = u) } return this.min.set(e, n, r), this.max.set(i, a, o), this } setFromBufferAttribute(t) { let e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0; for (let s = 0, l = t.count; s < l; s++) { const l = t.getX(s), c = t.getY(s), u = t.getZ(s); l < e && (e = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > a && (a = c), u > o && (o = u) } return this.min.set(e, n, r), this.max.set(i, a, o), this } setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize(t, e) { const n = xt.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } setFromObject(t, e = !1) { return this.makeEmpty(), this.expandByObject(t, e) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(t) { return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) } expandByPoint(t) { return this.min.min(t), this.max.max(t), this } expandByVector(t) { return this.min.sub(t), this.max.add(t), this } expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this } expandByObject(t, e = !1) { t.updateWorldMatrix(!1, !1); const n = t.geometry; if (void 0 !== n) if (e && null != n.attributes && void 0 !== n.attributes.position) { const e = n.attributes.position; for (let n = 0, r = e.count; n < r; n++)xt.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(xt) } else null === n.boundingBox && n.computeBoundingBox(), bt.copy(n.boundingBox), bt.applyMatrix4(t.matrixWorld), this.union(bt); const r = t.children; for (let t = 0, n = r.length; t < n; t++)this.expandByObject(r[t], e); return this } containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) } containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z } getParameter(t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) } intersectsSphere(t) { return this.clampPoint(t.center, xt), xt.distanceToSquared(t.center) <= t.radius * t.radius } intersectsPlane(t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant } intersectsTriangle(t) { if (this.isEmpty()) return !1; this.getCenter(Ct), Lt.subVectors(this.max, Ct), Mt.subVectors(t.a, Ct), wt.subVectors(t.b, Ct), St.subVectors(t.c, Ct), Tt.subVectors(wt, Mt), Et.subVectors(St, wt), At.subVectors(Mt, St); let e = [0, -Tt.z, Tt.y, 0, -Et.z, Et.y, 0, -At.z, At.y, Tt.z, 0, -Tt.x, Et.z, 0, -Et.x, At.z, 0, -At.x, -Tt.y, Tt.x, 0, -Et.y, Et.x, 0, -At.y, At.x, 0]; return !!Dt(e, Mt, wt, St, Lt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Dt(e, Mt, wt, St, Lt) && (Pt.crossVectors(Tt, Et), e = [Pt.x, Pt.y, Pt.z], Dt(e, Mt, wt, St, Lt))) } clampPoint(t, e) { return e.copy(t).clamp(this.min, this.max) } distanceToPoint(t) { return xt.copy(t).clamp(this.min, this.max).sub(t).length() } getBoundingSphere(t) { return this.getCenter(t.center), t.radius = .5 * this.getSize(xt).length(), t } intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this } union(t) { return this.min.min(t.min), this.max.max(t.max), this } applyMatrix4(t) { return this.isEmpty() || (yt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), yt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), yt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), yt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), yt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), yt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), yt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), yt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(yt)), this } translate(t) { return this.min.add(t), this.max.add(t), this } equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) } } const yt = [new mt, new mt, new mt, new mt, new mt, new mt, new mt, new mt], xt = new mt, bt = new _t, Mt = new mt, wt = new mt, St = new mt, Tt = new mt, Et = new mt, At = new mt, Ct = new mt, Lt = new mt, Pt = new mt, Rt = new mt; function Dt(t, e, n, r, i) { for (let a = 0, o = t.length - 3; a <= o; a += 3) { Rt.fromArray(t, a); const o = i.x * Math.abs(Rt.x) + i.y * Math.abs(Rt.y) + i.z * Math.abs(Rt.z), s = e.dot(Rt), l = n.dot(Rt), c = r.dot(Rt); if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > o) return !1 } return !0 } const It = new _t, Ot = new mt, Nt = new mt, zt = new mt; class Ft { constructor(t = new mt, e = -1) { this.center = t, this.radius = e } set(t, e) { return this.center.copy(t), this.radius = e, this } setFromPoints(t, e) { const n = this.center; void 0 !== e ? n.copy(e) : It.setFromPoints(t).getCenter(n); let r = 0; for (let e = 0, i = t.length; e < i; e++)r = Math.max(r, n.distanceToSquared(t[e])); return this.radius = Math.sqrt(r), this } copy(t) { return this.center.copy(t.center), this.radius = t.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(t) { return t.distanceTo(this.center) - this.radius } intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e } intersectsBox(t) { return t.intersectsSphere(this) } intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius } clampPoint(t, e) { const n = this.center.distanceToSquared(t); return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e } getBoundingBox(t) { return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) } applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this } translate(t) { return this.center.add(t), this } expandByPoint(t) { zt.subVectors(t, this.center); const e = zt.lengthSq(); if (e > this.radius * this.radius) { const t = Math.sqrt(e), n = .5 * (t - this.radius); this.center.add(zt.multiplyScalar(n / t)), this.radius += n } return this } union(t) { return !0 === this.center.equals(t.center) ? Nt.set(0, 0, 1).multiplyScalar(t.radius) : Nt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Ot.copy(t.center).add(Nt)), this.expandByPoint(Ot.copy(t.center).sub(Nt)), this } equals(t) { return t.center.equals(this.center) && t.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const Ut = new mt, kt = new mt, Bt = new mt, Vt = new mt, Gt = new mt, Ht = new mt, Wt = new mt; class jt { constructor(t = new mt, e = new mt(0, 0, -1)) { this.origin = t, this.direction = e } set(t, e) { return this.origin.copy(t), this.direction.copy(e), this } copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this } at(t, e) { return e.copy(this.direction).multiplyScalar(t).add(this.origin) } lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this } recast(t) { return this.origin.copy(this.at(t, Ut)), this } closestPointToPoint(t, e) { e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) } distanceSqToPoint(t) { const e = Ut.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Ut.copy(this.direction).multiplyScalar(e).add(this.origin), Ut.distanceToSquared(t)) } distanceSqToSegment(t, e, n, r) { kt.copy(t).add(e).multiplyScalar(.5), Bt.copy(e).sub(t).normalize(), Vt.copy(this.origin).sub(kt); const i = .5 * t.distanceTo(e), a = -this.direction.dot(Bt), o = Vt.dot(this.direction), s = -Vt.dot(Bt), l = Vt.lengthSq(), c = Math.abs(1 - a * a); let u, h, d, f; if (c > 0) if (u = a * s - o, h = a * o - s, f = i * c, u >= 0) if (h >= -f) if (h <= f) { const t = 1 / c; u *= t, h *= t, d = u * (u + a * h + 2 * o) + h * (a * u + h + 2 * s) + l } else h = i, u = Math.max(0, -(a * h + o)), d = -u * u + h * (h + 2 * s) + l; else h = -i, u = Math.max(0, -(a * h + o)), d = -u * u + h * (h + 2 * s) + l; else h <= -f ? (u = Math.max(0, -(-a * i + o)), h = u > 0 ? -i : Math.min(Math.max(-i, -s), i), d = -u * u + h * (h + 2 * s) + l) : h <= f ? (u = 0, h = Math.min(Math.max(-i, -s), i), d = h * (h + 2 * s) + l) : (u = Math.max(0, -(a * i + o)), h = u > 0 ? i : Math.min(Math.max(-i, -s), i), d = -u * u + h * (h + 2 * s) + l); else h = a > 0 ? -i : i, u = Math.max(0, -(a * h + o)), d = -u * u + h * (h + 2 * s) + l; return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(Bt).multiplyScalar(h).add(kt), d } intersectSphere(t, e) { Ut.subVectors(t.center, this.origin); const n = Ut.dot(this.direction), r = Ut.dot(Ut) - n * n, i = t.radius * t.radius; if (r > i) return null; const a = Math.sqrt(i - r), o = n - a, s = n + a; return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e) } intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius } distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null } intersectPlane(t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) } intersectsPlane(t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 } intersectBox(t, e) { let n, r, i, a, o, s; const l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin; return l >= 0 ? (n = (t.min.x - h.x) * l, r = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l, r = (t.min.x - h.x) * l), c >= 0 ? (i = (t.min.y - h.y) * c, a = (t.max.y - h.y) * c) : (i = (t.max.y - h.y) * c, a = (t.min.y - h.y) * c), n > a || i > r ? null : ((i > n || n != n) && (n = i), (a < r || r != r) && (r = a), u >= 0 ? (o = (t.min.z - h.z) * u, s = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, s = (t.min.z - h.z) * u), n > s || o > r ? null : ((o > n || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, e))) } intersectsBox(t) { return null !== this.intersectBox(t, Ut) } intersectTriangle(t, e, n, r, i) { Gt.subVectors(e, t), Ht.subVectors(n, t), Wt.crossVectors(Gt, Ht); let a, o = this.direction.dot(Wt); if (o > 0) { if (r) return null; a = 1 } else { if (!(o < 0)) return null; a = -1, o = -o } Vt.subVectors(this.origin, t); const s = a * this.direction.dot(Ht.crossVectors(Vt, Ht)); if (s < 0) return null; const l = a * this.direction.dot(Gt.cross(Vt)); if (l < 0) return null; if (s + l > o) return null; const c = -a * Vt.dot(Wt); return c < 0 ? null : this.at(c / o, i) } applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this } equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class qt { constructor() { qt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } set(t, e, n, r, i, a, o, s, l, c, u, h, d, f, p, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = f, g[11] = p, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new qt).fromArray(this.elements) } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this } copyPosition(t) { const e = this.elements, n = t.elements; return e[12] = n[12], e[13] = n[13], e[14] = n[14], this } setFromMatrix3(t) { const e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this } extractBasis(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(t) { const e = this.elements, n = t.elements, r = 1 / Xt.setFromMatrixColumn(t, 0).length(), i = 1 / Xt.setFromMatrixColumn(t, 1).length(), a = 1 / Xt.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromEuler(t) { const e = this.elements, n = t.x, r = t.y, i = t.z, a = Math.cos(n), o = Math.sin(n), s = Math.cos(r), l = Math.sin(r), c = Math.cos(i), u = Math.sin(i); if ("XYZ" === t.order) { const t = a * c, n = a * u, r = o * c, i = o * u; e[0] = s * c, e[4] = -s * u, e[8] = l, e[1] = n + r * l, e[5] = t - i * l, e[9] = -o * s, e[2] = i - t * l, e[6] = r + n * l, e[10] = a * s } else if ("YXZ" === t.order) { const t = s * c, n = s * u, r = l * c, i = l * u; e[0] = t + i * o, e[4] = r * o - n, e[8] = a * l, e[1] = a * u, e[5] = a * c, e[9] = -o, e[2] = n * o - r, e[6] = i + t * o, e[10] = a * s } else if ("ZXY" === t.order) { const t = s * c, n = s * u, r = l * c, i = l * u; e[0] = t - i * o, e[4] = -a * u, e[8] = r + n * o, e[1] = n + r * o, e[5] = a * c, e[9] = i - t * o, e[2] = -a * l, e[6] = o, e[10] = a * s } else if ("ZYX" === t.order) { const t = a * c, n = a * u, r = o * c, i = o * u; e[0] = s * c, e[4] = r * l - n, e[8] = t * l + i, e[1] = s * u, e[5] = i * l + t, e[9] = n * l - r, e[2] = -l, e[6] = o * s, e[10] = a * s } else if ("YZX" === t.order) { const t = a * s, n = a * l, r = o * s, i = o * l; e[0] = s * c, e[4] = i - t * u, e[8] = r * u + n, e[1] = u, e[5] = a * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * u + r, e[10] = t - i * u } else if ("XZY" === t.order) { const t = a * s, n = a * l, r = o * s, i = o * l; e[0] = s * c, e[4] = -u, e[8] = l * c, e[1] = t * u + i, e[5] = a * c, e[9] = n * u - r, e[2] = r * u - n, e[6] = o * c, e[10] = i * u + t } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromQuaternion(t) { return this.compose(Zt, t, Kt) } lookAt(t, e, n) { const r = this.elements; return $t.subVectors(t, e), 0 === $t.lengthSq() && ($t.z = 1), $t.normalize(), Jt.crossVectors(n, $t), 0 === Jt.lengthSq() && (1 === Math.abs(n.z) ? $t.x += 1e-4 : $t.z += 1e-4, $t.normalize(), Jt.crossVectors(n, $t)), Jt.normalize(), Qt.crossVectors($t, Jt), r[0] = Jt.x, r[4] = Qt.x, r[8] = $t.x, r[1] = Jt.y, r[5] = Qt.y, r[9] = $t.y, r[2] = Jt.z, r[6] = Qt.z, r[10] = $t.z, this } multiply(t) { return this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, r = e.elements, i = this.elements, a = n[0], o = n[4], s = n[8], l = n[12], c = n[1], u = n[5], h = n[9], d = n[13], f = n[2], p = n[6], m = n[10], g = n[14], v = n[3], _ = n[7], y = n[11], x = n[15], b = r[0], M = r[4], w = r[8], S = r[12], T = r[1], E = r[5], A = r[9], C = r[13], L = r[2], P = r[6], R = r[10], D = r[14], I = r[3], O = r[7], N = r[11], z = r[15]; return i[0] = a * b + o * T + s * L + l * I, i[4] = a * M + o * E + s * P + l * O, i[8] = a * w + o * A + s * R + l * N, i[12] = a * S + o * C + s * D + l * z, i[1] = c * b + u * T + h * L + d * I, i[5] = c * M + u * E + h * P + d * O, i[9] = c * w + u * A + h * R + d * N, i[13] = c * S + u * C + h * D + d * z, i[2] = f * b + p * T + m * L + g * I, i[6] = f * M + p * E + m * P + g * O, i[10] = f * w + p * A + m * R + g * N, i[14] = f * S + p * C + m * D + g * z, i[3] = v * b + _ * T + y * L + x * I, i[7] = v * M + _ * E + y * P + x * O, i[11] = v * w + _ * A + y * R + x * N, i[15] = v * S + _ * C + y * D + x * z, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[4], r = t[8], i = t[12], a = t[1], o = t[5], s = t[9], l = t[13], c = t[2], u = t[6], h = t[10], d = t[14]; return t[3] * (+i * s * u - r * l * u - i * o * h + n * l * h + r * o * d - n * s * d) + t[7] * (+e * s * d - e * l * h + i * a * h - r * a * d + r * l * c - i * s * c) + t[11] * (+e * l * u - e * o * d - i * a * u + n * a * d + i * o * c - n * l * c) + t[15] * (-r * o * c - e * s * u + e * o * h + r * a * u - n * a * h + n * s * c) } transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } setPosition(t, e, n) { const r = this.elements; return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this } invert() { const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], o = t[5], s = t[6], l = t[7], c = t[8], u = t[9], h = t[10], d = t[11], f = t[12], p = t[13], m = t[14], g = t[15], v = u * m * l - p * h * l + p * s * d - o * m * d - u * s * g + o * h * g, _ = f * h * l - c * m * l - f * s * d + a * m * d + c * s * g - a * h * g, y = c * p * l - f * u * l + f * o * d - a * p * d - c * o * g + a * u * g, x = f * u * s - c * p * s - f * o * h + a * p * h + c * o * m - a * u * m, b = e * v + n * _ + r * y + i * x; if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const M = 1 / b; return t[0] = v * M, t[1] = (p * h * i - u * m * i - p * r * d + n * m * d + u * r * g - n * h * g) * M, t[2] = (o * m * i - p * s * i + p * r * l - n * m * l - o * r * g + n * s * g) * M, t[3] = (u * s * i - o * h * i - u * r * l + n * h * l + o * r * d - n * s * d) * M, t[4] = _ * M, t[5] = (c * m * i - f * h * i + f * r * d - e * m * d - c * r * g + e * h * g) * M, t[6] = (f * s * i - a * m * i - f * r * l + e * m * l + a * r * g - e * s * g) * M, t[7] = (a * h * i - c * s * i + c * r * l - e * h * l - a * r * d + e * s * d) * M, t[8] = y * M, t[9] = (f * u * i - c * p * i - f * n * d + e * p * d + c * n * g - e * u * g) * M, t[10] = (a * p * i - f * o * i + f * n * l - e * p * l - a * n * g + e * o * g) * M, t[11] = (c * o * i - a * u * i - c * n * l + e * u * l + a * n * d - e * o * d) * M, t[12] = x * M, t[13] = (c * p * r - f * u * r + f * n * h - e * p * h - c * n * m + e * u * m) * M, t[14] = (f * o * r - a * p * r - f * n * s + e * p * s + a * n * m - e * o * m) * M, t[15] = (a * u * r - c * o * r + c * n * s - e * u * s - a * n * h + e * o * h) * M, this } scale(t) { const e = this.elements, n = t.x, r = t.y, i = t.z; return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this } getMaxScaleOnAxis() { const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, n, r)) } makeTranslation(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this } makeRotationY(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this } makeRotationZ(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(t, e) { const n = Math.cos(e), r = Math.sin(e), i = 1 - n, a = t.x, o = t.y, s = t.z, l = i * a, c = i * o; return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, c * o + n, c * s - r * a, 0, l * s - r * o, c * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this } makeScale(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(t, e, n, r, i, a) { return this.set(1, n, i, 0, t, 1, a, 0, e, r, 1, 0, 0, 0, 0, 1), this } compose(t, e, n) { const r = this.elements, i = e._x, a = e._y, o = e._z, s = e._w, l = i + i, c = a + a, u = o + o, h = i * l, d = i * c, f = i * u, p = a * c, m = a * u, g = o * u, v = s * l, _ = s * c, y = s * u, x = n.x, b = n.y, M = n.z; return r[0] = (1 - (p + g)) * x, r[1] = (d + y) * x, r[2] = (f - _) * x, r[3] = 0, r[4] = (d - y) * b, r[5] = (1 - (h + g)) * b, r[6] = (m + v) * b, r[7] = 0, r[8] = (f + _) * M, r[9] = (m - v) * M, r[10] = (1 - (h + p)) * M, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this } decompose(t, e, n) { const r = this.elements; let i = Xt.set(r[0], r[1], r[2]).length(); const a = Xt.set(r[4], r[5], r[6]).length(), o = Xt.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], Yt.copy(this); const s = 1 / i, l = 1 / a, c = 1 / o; return Yt.elements[0] *= s, Yt.elements[1] *= s, Yt.elements[2] *= s, Yt.elements[4] *= l, Yt.elements[5] *= l, Yt.elements[6] *= l, Yt.elements[8] *= c, Yt.elements[9] *= c, Yt.elements[10] *= c, e.setFromRotationMatrix(Yt), n.x = i, n.y = a, n.z = o, this } makePerspective(t, e, n, r, i, a) { const o = this.elements, s = 2 * i / (e - t), l = 2 * i / (n - r), c = (e + t) / (e - t), u = (n + r) / (n - r), h = -(a + i) / (a - i), d = -2 * a * i / (a - i); return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(t, e, n, r, i, a) { const o = this.elements, s = 1 / (e - t), l = 1 / (n - r), c = 1 / (a - i), u = (e + t) * s, h = (n + r) * l, d = (a + i) * c; return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(t) { const e = this.elements, n = t.elements; for (let t = 0; t < 16; t++)if (e[t] !== n[t]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } } const Xt = new mt, Yt = new qt, Zt = new mt(0, 0, 0), Kt = new mt(1, 1, 1), Jt = new mt, Qt = new mt, $t = new mt, te = new qt, ee = new pt; class ne { constructor(t = 0, e = 0, n = 0, r = ne.DefaultOrder) { this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = r } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get order() { return this._order } set order(t) { this._order = t, this._onChangeCallback() } set(t, e, n, r = this._order) { return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this } setFromRotationMatrix(t, e = this._order, n = !0) { const r = t.elements, i = r[0], a = r[4], o = r[8], s = r[1], l = r[5], c = r[9], u = r[2], h = r[6], d = r[10]; switch (e) { case "XYZ": this._y = Math.asin(k(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(h, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-k(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, i), this._z = 0); break; case "ZXY": this._x = Math.asin(k(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, i)); break; case "ZYX": this._y = Math.asin(-k(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-a, l)); break; case "YZX": this._z = Math.asin(k(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, d)); break; case "XZY": this._z = Math.asin(-k(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, !0 === n && this._onChangeCallback(), this } setFromQuaternion(t, e, n) { return te.makeRotationFromQuaternion(t), this.setFromRotationMatrix(te, e, n) } setFromVector3(t, e = this._order) { return this.set(t.x, t.y, t.z, e) } reorder(t) { return ee.setFromEuler(this), this.setFromQuaternion(ee, t) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order } fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } toVector3() { console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead") } } ne.DefaultOrder = "XYZ", ne.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class re { constructor() { this.mask = 1 } set(t) { this.mask = (1 << t | 0) >>> 0 } enable(t) { this.mask |= 1 << t | 0 } enableAll() { this.mask = -1 } toggle(t) { this.mask ^= 1 << t | 0 } disable(t) { this.mask &= ~(1 << t | 0) } disableAll() { this.mask = 0 } test(t) { return 0 != (this.mask & t.mask) } isEnabled(t) { return 0 != (this.mask & (1 << t | 0)) } } let ie = 0; const ae = new mt, oe = new pt, se = new qt, le = new mt, ce = new mt, ue = new mt, he = new pt, de = new mt(1, 0, 0), fe = new mt(0, 1, 0), pe = new mt(0, 0, 1), me = { type: "added" }, ge = { type: "removed" }; class ve extends O { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: ie++ }), this.uuid = U(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ve.DefaultUp.clone(); const t = new mt, e = new ne, n = new pt, r = new mt(1, 1, 1); e._onChange((function () { n.setFromEuler(e, !1) })), n._onChange((function () { e.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new qt }, normalMatrix: { value: new W } }), this.matrix = new qt, this.matrixWorld = new qt, this.matrixAutoUpdate = ve.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new re, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(t) { return this.quaternion.premultiply(t), this } setRotationFromAxisAngle(t, e) { this.quaternion.setFromAxisAngle(t, e) } setRotationFromEuler(t) { this.quaternion.setFromEuler(t, !0) } setRotationFromMatrix(t) { this.quaternion.setFromRotationMatrix(t) } setRotationFromQuaternion(t) { this.quaternion.copy(t) } rotateOnAxis(t, e) { return oe.setFromAxisAngle(t, e), this.quaternion.multiply(oe), this } rotateOnWorldAxis(t, e) { return oe.setFromAxisAngle(t, e), this.quaternion.premultiply(oe), this } rotateX(t) { return this.rotateOnAxis(de, t) } rotateY(t) { return this.rotateOnAxis(fe, t) } rotateZ(t) { return this.rotateOnAxis(pe, t) } translateOnAxis(t, e) { return ae.copy(t).applyQuaternion(this.quaternion), this.position.add(ae.multiplyScalar(e)), this } translateX(t) { return this.translateOnAxis(de, t) } translateY(t) { return this.translateOnAxis(fe, t) } translateZ(t) { return this.translateOnAxis(pe, t) } localToWorld(t) { return t.applyMatrix4(this.matrixWorld) } worldToLocal(t) { return t.applyMatrix4(se.copy(this.matrixWorld).invert()) } lookAt(t, e, n) { t.isVector3 ? le.copy(t) : le.set(t, e, n); const r = this.parent; this.updateWorldMatrix(!0, !1), ce.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? se.lookAt(ce, le, this.up) : se.lookAt(le, ce, this.up), this.quaternion.setFromRotationMatrix(se), r && (se.extractRotation(r.matrixWorld), oe.setFromRotationMatrix(se), this.quaternion.premultiply(oe.invert())) } add(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(me)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) } remove(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(ge)), this } removeFromParent() { const t = this.parent; return null !== t && t.remove(this), this } clear() { for (let t = 0; t < this.children.length; t++) { const e = this.children[t]; e.parent = null, e.dispatchEvent(ge) } return this.children.length = 0, this } attach(t) { return this.updateWorldMatrix(!0, !1), se.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), se.multiply(t.parent.matrixWorld)), t.applyMatrix4(se), this.add(t), t.updateWorldMatrix(!1, !0), this } getObjectById(t) { return this.getObjectByProperty("id", t) } getObjectByName(t) { return this.getObjectByProperty("name", t) } getObjectByProperty(t, e) { if (this[t] === e) return this; for (let n = 0, r = this.children.length; n < r; n++) { const r = this.children[n].getObjectByProperty(t, e); if (void 0 !== r) return r } } getWorldPosition(t) { return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ce, t, ue), t } getWorldScale(t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ce, he, t), t } getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() } raycast() { } traverse(t) { t(this); const e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].traverse(t) } traverseVisible(t) { if (!1 === this.visible) return; t(this); const e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].traverseVisible(t) } traverseAncestors(t) { const e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].updateMatrixWorld(t) } updateWorldMatrix(t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++)t[e].updateWorldMatrix(!1, !0) } } toJSON(t) { const e = void 0 === t || "string" == typeof t, n = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const r = {}; function i(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = i(t.geometries, this.geometry); const e = this.geometry.parameters; if (void 0 !== e && void 0 !== e.shapes) { const n = e.shapes; if (Array.isArray(n)) for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; i(t.shapes, r) } else i(t.shapes, n) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const e = []; for (let n = 0, r = this.material.length; n < r; n++)e.push(i(t.materials, this.material[n])); r.material = e } else r.material = i(t.materials, this.material); if (this.children.length > 0) { r.children = []; for (let e = 0; e < this.children.length; e++)r.children.push(this.children[e].toJSON(t).object) } if (this.animations.length > 0) { r.animations = []; for (let e = 0; e < this.animations.length; e++) { const n = this.animations[e]; r.animations.push(i(t.animations, n)) } } if (e) { const e = a(t.geometries), r = a(t.materials), i = a(t.textures), o = a(t.images), s = a(t.shapes), l = a(t.skeletons), c = a(t.animations), u = a(t.nodes); e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), s.length > 0 && (n.shapes = s), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u) } return n.object = r, n; function a(t) { const e = []; for (const n in t) { const r = t[n]; delete r.metadata, e.push(r) } return e } } clone(t) { return (new this.constructor).copy(this, t) } copy(t, e = !0) { if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) { const n = t.children[e]; this.add(n.clone()) } return this } } ve.DefaultUp = new mt(0, 1, 0), ve.DefaultMatrixAutoUpdate = !0; const _e = new mt, ye = new mt, xe = new mt, be = new mt, Me = new mt, we = new mt, Se = new mt, Te = new mt, Ee = new mt, Ae = new mt; class Ce { constructor(t = new mt, e = new mt, n = new mt) { this.a = t, this.b = e, this.c = n } static getNormal(t, e, n, r) { r.subVectors(n, e), _e.subVectors(t, e), r.cross(_e); const i = r.lengthSq(); return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0) } static getBarycoord(t, e, n, r, i) { _e.subVectors(r, e), ye.subVectors(n, e), xe.subVectors(t, e); const a = _e.dot(_e), o = _e.dot(ye), s = _e.dot(xe), l = ye.dot(ye), c = ye.dot(xe), u = a * l - o * o; if (0 === u) return i.set(-2, -1, -1); const h = 1 / u, d = (l * s - o * c) * h, f = (a * c - o * s) * h; return i.set(1 - d - f, f, d) } static containsPoint(t, e, n, r) { return this.getBarycoord(t, e, n, r, be), be.x >= 0 && be.y >= 0 && be.x + be.y <= 1 } static getUV(t, e, n, r, i, a, o, s) { return this.getBarycoord(t, e, n, r, be), s.set(0, 0), s.addScaledVector(i, be.x), s.addScaledVector(a, be.y), s.addScaledVector(o, be.z), s } static isFrontFacing(t, e, n, r) { return _e.subVectors(n, e), ye.subVectors(t, e), _e.cross(ye).dot(r) < 0 } set(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this } setFromPointsAndIndices(t, e, n, r) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this } setFromAttributeAndIndices(t, e, n, r) { return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this } getArea() { return _e.subVectors(this.c, this.b), ye.subVectors(this.a, this.b), .5 * _e.cross(ye).length() } getMidpoint(t) { return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(t) { return Ce.getNormal(this.a, this.b, this.c, t) } getPlane(t) { return t.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(t, e) { return Ce.getBarycoord(t, this.a, this.b, this.c, e) } getUV(t, e, n, r, i) { return Ce.getUV(t, this.a, this.b, this.c, e, n, r, i) } containsPoint(t) { return Ce.containsPoint(t, this.a, this.b, this.c) } isFrontFacing(t) { return Ce.isFrontFacing(this.a, this.b, this.c, t) } intersectsBox(t) { return t.intersectsTriangle(this) } closestPointToPoint(t, e) { const n = this.a, r = this.b, i = this.c; let a, o; Me.subVectors(r, n), we.subVectors(i, n), Te.subVectors(t, n); const s = Me.dot(Te), l = we.dot(Te); if (s <= 0 && l <= 0) return e.copy(n); Ee.subVectors(t, r); const c = Me.dot(Ee), u = we.dot(Ee); if (c >= 0 && u <= c) return e.copy(r); const h = s * u - c * l; if (h <= 0 && s >= 0 && c <= 0) return a = s / (s - c), e.copy(n).addScaledVector(Me, a); Ae.subVectors(t, i); const d = Me.dot(Ae), f = we.dot(Ae); if (f >= 0 && d <= f) return e.copy(i); const p = d * l - s * f; if (p <= 0 && l >= 0 && f <= 0) return o = l / (l - f), e.copy(n).addScaledVector(we, o); const m = c * f - d * u; if (m <= 0 && u - c >= 0 && d - f >= 0) return Se.subVectors(i, r), o = (u - c) / (u - c + (d - f)), e.copy(r).addScaledVector(Se, o); const g = 1 / (m + p + h); return a = p * g, o = h * g, e.copy(n).addScaledVector(Me, a).addScaledVector(we, o) } equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } } let Le = 0; class Pe extends O { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Le++ }), this.uuid = U(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = t, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = R, this.stencilZFail = R, this.stencilZPass = R, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(t) { this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(t) { if (void 0 !== t) for (const e in t) { const n = t[e]; if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; continue } const r = this[e]; void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } } toJSON(t) { const e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function r(t) { const e = []; for (const n in t) { const r = t[n]; delete r.metadata, e.push(r) } return e } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) { const e = r(t.textures), i = r(t.images); e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i) } return n } clone() { return (new this.constructor).copy(this) } copy(t) { this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const e = t.clippingPlanes; let n = null; if (null !== e) { const t = e.length; n = new Array(t); for (let r = 0; r !== t; ++r)n[r] = e[r].clone() } return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(t) { !0 === t && this.version++ } } class Re extends Pe { constructor(t) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this } } const De = new mt, Ie = new H; class Oe { constructor(t, e, n) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(t) { !0 === t && this.version++ } setUsage(t) { return this.usage = t, this } copy(t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this } copyAt(t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let r = 0, i = this.itemSize; r < i; r++)this.array[t + r] = e.array[n + r]; return this } copyArray(t) { return this.array.set(t), this } copyColorsArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new rt), e[n++] = i.r, e[n++] = i.g, e[n++] = i.b } return this } copyVector2sArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new H), e[n++] = i.x, e[n++] = i.y } return this } copyVector3sArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new mt), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z } return this } copyVector4sArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new ut), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z, e[n++] = i.w } return this } applyMatrix3(t) { if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)Ie.fromBufferAttribute(this, e), Ie.applyMatrix3(t), this.setXY(e, Ie.x, Ie.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)De.fromBufferAttribute(this, e), De.applyMatrix3(t), this.setXYZ(e, De.x, De.y, De.z); return this } applyMatrix4(t) { for (let e = 0, n = this.count; e < n; e++)De.fromBufferAttribute(this, e), De.applyMatrix4(t), this.setXYZ(e, De.x, De.y, De.z); return this } applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++)De.fromBufferAttribute(this, e), De.applyNormalMatrix(t), this.setXYZ(e, De.x, De.y, De.z); return this } transformDirection(t) { for (let e = 0, n = this.count; e < n; e++)De.fromBufferAttribute(this, e), De.transformDirection(t), this.setXYZ(e, De.x, De.y, De.z); return this } set(t, e = 0) { return this.array.set(t, e), this } getX(t) { return this.array[t * this.itemSize] } setX(t, e) { return this.array[t * this.itemSize] = e, this } getY(t) { return this.array[t * this.itemSize + 1] } setY(t, e) { return this.array[t * this.itemSize + 1] = e, this } getZ(t) { return this.array[t * this.itemSize + 2] } setZ(t, e) { return this.array[t * this.itemSize + 2] = e, this } getW(t) { return this.array[t * this.itemSize + 3] } setW(t, e) { return this.array[t * this.itemSize + 3] = e, this } setXY(t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this } setXYZ(t, e, n, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this } setXYZW(t, e, n, r, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this } onUpload(t) { return this.onUploadCallback = t, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t } } class Ne extends Oe { constructor(t, e, n) { super(new Uint16Array(t), e, n) } } class ze extends Oe { constructor(t, e, n) { super(new Uint32Array(t), e, n) } } class Fe extends Oe { constructor(t, e, n) { super(new Float32Array(t), e, n) } } let Ue = 0; const ke = new qt, Be = new ve, Ve = new mt, Ge = new _t, He = new _t, We = new mt; class je extends O { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Ue++ }), this.uuid = U(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(t) { return Array.isArray(t) ? this.index = new (j(t) ? ze : Ne)(t, 1) : this.index = t, this } getAttribute(t) { return this.attributes[t] } setAttribute(t, e) { return this.attributes[t] = e, this } deleteAttribute(t) { return delete this.attributes[t], this } hasAttribute(t) { return void 0 !== this.attributes[t] } addGroup(t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(t, e) { this.drawRange.start = t, this.drawRange.count = e } applyMatrix4(t) { const e = this.attributes.position; void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const e = (new W).getNormalMatrix(t); n.applyNormalMatrix(e), n.needsUpdate = !0 } const r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(t) { return ke.makeRotationFromQuaternion(t), this.applyMatrix4(ke), this } rotateX(t) { return ke.makeRotationX(t), this.applyMatrix4(ke), this } rotateY(t) { return ke.makeRotationY(t), this.applyMatrix4(ke), this } rotateZ(t) { return ke.makeRotationZ(t), this.applyMatrix4(ke), this } translate(t, e, n) { return ke.makeTranslation(t, e, n), this.applyMatrix4(ke), this } scale(t, e, n) { return ke.makeScale(t, e, n), this.applyMatrix4(ke), this } lookAt(t) { return Be.lookAt(t), Be.updateMatrix(), this.applyMatrix4(Be.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Ve).negate(), this.translate(Ve.x, Ve.y, Ve.z), this } setFromPoints(t) { const e = []; for (let n = 0, r = t.length; n < r; n++) { const r = t[n]; e.push(r.x, r.y, r.z || 0) } return this.setAttribute("position", new Fe(e, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new _t); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new mt(-1 / 0, -1 / 0, -1 / 0), new mt(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; Ge.setFromBufferAttribute(n), this.morphTargetsRelative ? (We.addVectors(this.boundingBox.min, Ge.min), this.boundingBox.expandByPoint(We), We.addVectors(this.boundingBox.max, Ge.max), this.boundingBox.expandByPoint(We)) : (this.boundingBox.expandByPoint(Ge.min), this.boundingBox.expandByPoint(Ge.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new Ft); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new mt, 1 / 0); if (t) { const n = this.boundingSphere.center; if (Ge.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; He.setFromBufferAttribute(n), this.morphTargetsRelative ? (We.addVectors(Ge.min, He.min), Ge.expandByPoint(We), We.addVectors(Ge.max, He.max), Ge.expandByPoint(We)) : (Ge.expandByPoint(He.min), Ge.expandByPoint(He.max)) } Ge.getCenter(n); let r = 0; for (let e = 0, i = t.count; e < i; e++)We.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(We)); if (e) for (let i = 0, a = e.length; i < a; i++) { const a = e[i], o = this.morphTargetsRelative; for (let e = 0, i = a.count; e < i; e++)We.fromBufferAttribute(a, e), o && (Ve.fromBufferAttribute(t, e), We.add(Ve)), r = Math.max(r, n.distanceToSquared(We)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const t = this.index, e = this.attributes; if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = t.array, r = e.position.array, i = e.normal.array, a = e.uv.array, o = r.length / 3; !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Oe(new Float32Array(4 * o), 4)); const s = this.getAttribute("tangent").array, l = [], c = []; for (let t = 0; t < o; t++)l[t] = new mt, c[t] = new mt; const u = new mt, h = new mt, d = new mt, f = new H, p = new H, m = new H, g = new mt, v = new mt; function _(t, e, n) { u.fromArray(r, 3 * t), h.fromArray(r, 3 * e), d.fromArray(r, 3 * n), f.fromArray(a, 2 * t), p.fromArray(a, 2 * e), m.fromArray(a, 2 * n), h.sub(u), d.sub(u), p.sub(f), m.sub(f); const i = 1 / (p.x * m.y - m.x * p.y); isFinite(i) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -p.y).multiplyScalar(i), v.copy(d).multiplyScalar(p.x).addScaledVector(h, -m.x).multiplyScalar(i), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v)) } let y = this.groups; 0 === y.length && (y = [{ start: 0, count: n.length }]); for (let t = 0, e = y.length; t < e; ++t) { const e = y[t], r = e.start; for (let t = r, i = r + e.count; t < i; t += 3)_(n[t + 0], n[t + 1], n[t + 2]) } const x = new mt, b = new mt, M = new mt, w = new mt; function S(t) { M.fromArray(i, 3 * t), w.copy(M); const e = l[t]; x.copy(e), x.sub(M.multiplyScalar(M.dot(e))).normalize(), b.crossVectors(w, e); const n = b.dot(c[t]) < 0 ? -1 : 1; s[4 * t] = x.x, s[4 * t + 1] = x.y, s[4 * t + 2] = x.z, s[4 * t + 3] = n } for (let t = 0, e = y.length; t < e; ++t) { const e = y[t], r = e.start; for (let t = r, i = r + e.count; t < i; t += 3)S(n[t + 0]), S(n[t + 1]), S(n[t + 2]) } } computeVertexNormals() { const t = this.index, e = this.getAttribute("position"); if (void 0 !== e) { let n = this.getAttribute("normal"); if (void 0 === n) n = new Oe(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++)n.setXYZ(t, 0, 0, 0); const r = new mt, i = new mt, a = new mt, o = new mt, s = new mt, l = new mt, c = new mt, u = new mt; if (t) for (let h = 0, d = t.count; h < d; h += 3) { const d = t.getX(h + 0), f = t.getX(h + 1), p = t.getX(h + 2); r.fromBufferAttribute(e, d), i.fromBufferAttribute(e, f), a.fromBufferAttribute(e, p), c.subVectors(a, i), u.subVectors(r, i), c.cross(u), o.fromBufferAttribute(n, d), s.fromBufferAttribute(n, f), l.fromBufferAttribute(n, p), o.add(c), s.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(f, s.x, s.y, s.z), n.setXYZ(p, l.x, l.y, l.z) } else for (let t = 0, o = e.count; t < o; t += 3)r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), a.fromBufferAttribute(e, t + 2), c.subVectors(a, i), u.subVectors(r, i), c.cross(u), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge(t, e) { if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t); void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const r in n) { if (void 0 === t.attributes[r]) continue; const i = n[r].array, a = t.attributes[r], o = a.array, s = a.itemSize * e, l = Math.min(o.length, i.length - s); for (let t = 0, e = s; t < l; t++, e++)i[e] = o[t] } return this } normalizeNormals() { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++)We.fromBufferAttribute(t, e), We.normalize(), t.setXYZ(e, We.x, We.y, We.z) } toNonIndexed() { function t(t, e) { const n = t.array, r = t.itemSize, i = t.normalized, a = new n.constructor(e.length * r); let o = 0, s = 0; for (let i = 0, l = e.length; i < l; i++) { o = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r; for (let t = 0; t < r; t++)a[s++] = n[o++] } return new Oe(a, r, i) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const e = new je, n = this.index.array, r = this.attributes; for (const i in r) { const a = t(r[i], n); e.setAttribute(i, a) } const i = this.morphAttributes; for (const r in i) { const a = [], o = i[r]; for (let e = 0, r = o.length; e < r; e++) { const r = t(o[e], n); a.push(r) } e.morphAttributes[r] = a } e.morphTargetsRelative = this.morphTargetsRelative; const a = this.groups; for (let t = 0, n = a.length; t < n; t++) { const n = a[t]; e.addGroup(n.start, n.count, n.materialIndex) } return e } toJSON() { const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } t.data = { attributes: {} }; const e = this.index; null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); const n = this.attributes; for (const e in n) { const r = n[e]; t.data.attributes[e] = r.toJSON(t.data) } const r = {}; let i = !1; for (const e in this.morphAttributes) { const n = this.morphAttributes[e], a = []; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; a.push(r.toJSON(t.data)) } a.length > 0 && (r[e] = a, i = !0) } i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative); const a = this.groups; a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a))); const o = this.boundingSphere; return null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t } clone() { return (new this.constructor).copy(this) } copy(t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const e = {}; this.name = t.name; const n = t.index; null !== n && this.setIndex(n.clone(e)); const r = t.attributes; for (const t in r) { const n = r[t]; this.setAttribute(t, n.clone(e)) } const i = t.morphAttributes; for (const t in i) { const n = [], r = i[t]; for (let t = 0, i = r.length; t < i; t++)n.push(r[t].clone(e)); this.morphAttributes[t] = n } this.morphTargetsRelative = t.morphTargetsRelative; const a = t.groups; for (let t = 0, e = a.length; t < e; t++) { const e = a[t]; this.addGroup(e.start, e.count, e.materialIndex) } const o = t.boundingBox; null !== o && (this.boundingBox = o.clone()); const s = t.boundingSphere; return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const qe = new qt, Xe = new jt, Ye = new Ft, Ze = new mt, Ke = new mt, Je = new mt, Qe = new mt, $e = new mt, tn = new mt, en = new mt, nn = new mt, rn = new mt, an = new H, on = new H, sn = new H, ln = new mt, cn = new mt; class un extends ve { constructor(t = new je, e = new Re) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t, e) { return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this } updateMorphTargets() { const t = this.geometry.morphAttributes, e = Object.keys(t); if (e.length > 0) { const n = t[e[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, e = n.length; t < e; t++) { const e = n[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t } } } } raycast(t, e) { const n = this.geometry, r = this.material, i = this.matrixWorld; if (void 0 === r) return; if (null === n.boundingSphere && n.computeBoundingSphere(), Ye.copy(n.boundingSphere), Ye.applyMatrix4(i), !1 === t.ray.intersectsSphere(Ye)) return; if (qe.copy(i).invert(), Xe.copy(t.ray).applyMatrix4(qe), null !== n.boundingBox && !1 === Xe.intersectsBox(n.boundingBox)) return; let a; const o = n.index, s = n.attributes.position, l = n.morphAttributes.position, c = n.morphTargetsRelative, u = n.attributes.uv, h = n.attributes.uv2, d = n.groups, f = n.drawRange; if (null !== o) if (Array.isArray(r)) for (let n = 0, i = d.length; n < i; n++) { const i = d[n], p = r[i.materialIndex]; for (let n = Math.max(i.start, f.start), r = Math.min(o.count, Math.min(i.start + i.count, f.start + f.count)); n < r; n += 3) { const r = o.getX(n), d = o.getX(n + 1), f = o.getX(n + 2); a = hn(this, p, t, Xe, s, l, c, u, h, r, d, f), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = i.materialIndex, e.push(a)) } } else for (let n = Math.max(0, f.start), i = Math.min(o.count, f.start + f.count); n < i; n += 3) { const i = o.getX(n), d = o.getX(n + 1), f = o.getX(n + 2); a = hn(this, r, t, Xe, s, l, c, u, h, i, d, f), a && (a.faceIndex = Math.floor(n / 3), e.push(a)) } else if (void 0 !== s) if (Array.isArray(r)) for (let n = 0, i = d.length; n < i; n++) { const i = d[n], o = r[i.materialIndex]; for (let n = Math.max(i.start, f.start), r = Math.min(s.count, Math.min(i.start + i.count, f.start + f.count)); n < r; n += 3)a = hn(this, o, t, Xe, s, l, c, u, h, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = i.materialIndex, e.push(a)) } else for (let n = Math.max(0, f.start), i = Math.min(s.count, f.start + f.count); n < i; n += 3)a = hn(this, r, t, Xe, s, l, c, u, h, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), e.push(a)) } } function hn(t, e, n, r, i, a, o, s, l, c, u, h) { Ze.fromBufferAttribute(i, c), Ke.fromBufferAttribute(i, u), Je.fromBufferAttribute(i, h); const d = t.morphTargetInfluences; if (a && d) { en.set(0, 0, 0), nn.set(0, 0, 0), rn.set(0, 0, 0); for (let t = 0, e = a.length; t < e; t++) { const e = d[t], n = a[t]; 0 !== e && (Qe.fromBufferAttribute(n, c), $e.fromBufferAttribute(n, u), tn.fromBufferAttribute(n, h), o ? (en.addScaledVector(Qe, e), nn.addScaledVector($e, e), rn.addScaledVector(tn, e)) : (en.addScaledVector(Qe.sub(Ze), e), nn.addScaledVector($e.sub(Ke), e), rn.addScaledVector(tn.sub(Je), e))) } Ze.add(en), Ke.add(nn), Je.add(rn) } t.isSkinnedMesh && (t.boneTransform(c, Ze), t.boneTransform(u, Ke), t.boneTransform(h, Je)); const f = function (t, e, n, r, i, a, o, s) { let l; if (l = 1 === e.side ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, 2 !== e.side, s), null === l) return null; cn.copy(s), cn.applyMatrix4(t.matrixWorld); const c = n.ray.origin.distanceTo(cn); return c < n.near || c > n.far ? null : { distance: c, point: cn.clone(), object: t } }(t, e, n, r, Ze, Ke, Je, ln); if (f) { s && (an.fromBufferAttribute(s, c), on.fromBufferAttribute(s, u), sn.fromBufferAttribute(s, h), f.uv = Ce.getUV(ln, Ze, Ke, Je, an, on, sn, new H)), l && (an.fromBufferAttribute(l, c), on.fromBufferAttribute(l, u), sn.fromBufferAttribute(l, h), f.uv2 = Ce.getUV(ln, Ze, Ke, Je, an, on, sn, new H)); const t = { a: c, b: u, c: h, normal: new mt, materialIndex: 0 }; Ce.getNormal(Ze, Ke, Je, t.normal), f.face = t } return f } class dn extends je { constructor(t = 1, e = 1, n = 1, r = 1, i = 1, a = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: r, heightSegments: i, depthSegments: a }; const o = this; r = Math.floor(r), i = Math.floor(i), a = Math.floor(a); const s = [], l = [], c = [], u = []; let h = 0, d = 0; function f(t, e, n, r, i, a, f, p, m, g, v) { const _ = a / m, y = f / g, x = a / 2, b = f / 2, M = p / 2, w = m + 1, S = g + 1; let T = 0, E = 0; const A = new mt; for (let a = 0; a < S; a++) { const o = a * y - b; for (let s = 0; s < w; s++) { const h = s * _ - x; A[t] = h * r, A[e] = o * i, A[n] = M, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = p > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(s / m), u.push(1 - a / g), T += 1 } } for (let t = 0; t < g; t++)for (let e = 0; e < m; e++) { const n = h + e + w * t, r = h + e + w * (t + 1), i = h + (e + 1) + w * (t + 1), a = h + (e + 1) + w * t; s.push(n, r, a), s.push(r, i, a), E += 6 } o.addGroup(d, E, v), d += E, h += T } f("z", "y", "x", -1, -1, n, e, t, a, i, 0), f("z", "y", "x", 1, -1, n, e, -t, a, i, 1), f("x", "z", "y", 1, 1, t, n, e, r, a, 2), f("x", "z", "y", 1, -1, t, n, -e, r, a, 3), f("x", "y", "z", 1, -1, t, e, n, r, i, 4), f("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(s), this.setAttribute("position", new Fe(l, 3)), this.setAttribute("normal", new Fe(c, 3)), this.setAttribute("uv", new Fe(u, 2)) } static fromJSON(t) { return new dn(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments) } } function fn(t) { const e = {}; for (const n in t) { e[n] = {}; for (const r in t[n]) { const i = t[n][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i } } return e } function pn(t) { const e = {}; for (let n = 0; n < t.length; n++) { const r = fn(t[n]); for (const t in r) e[t] = r[t] } return e } const mn = { clone: fn, merge: pn }; class gn extends Pe { constructor(t) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } copy(t) { return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = fn(t.uniforms), this.uniformsGroups = function (t) { const e = []; for (let n = 0; n < t.length; n++)e.push(t[n].clone()); return e }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this } toJSON(t) { const e = super.toJSON(t); e.glslVersion = this.glslVersion, e.uniforms = {}; for (const n in this.uniforms) { const r = this.uniforms[n].value; r && r.isTexture ? e.uniforms[n] = { type: "t", value: r.toJSON(t).uuid } : r && r.isColor ? e.uniforms[n] = { type: "c", value: r.getHex() } : r && r.isVector2 ? e.uniforms[n] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? e.uniforms[n] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? e.uniforms[n] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? e.uniforms[n] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? e.uniforms[n] = { type: "m4", value: r.toArray() } : e.uniforms[n] = { value: r } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; const n = {}; for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0); return Object.keys(n).length > 0 && (e.extensions = n), e } } class vn extends ve { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new qt, this.projectionMatrix = new qt, this.projectionMatrixInverse = new qt } copy(t, e) { return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this } getWorldDirection(t) { this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() } updateMatrixWorld(t) { super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(t, e) { super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } class _n extends vn { constructor(t = 50, e = 1, n = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(t, e) { return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this } setFocalLength(t) { const e = .5 * this.getFilmHeight() / t; this.fov = 2 * F * Math.atan(e), this.updateProjectionMatrix() } getFocalLength() { const t = Math.tan(.5 * z * this.fov); return .5 * this.getFilmHeight() / t } getEffectiveFOV() { return 2 * F * Math.atan(Math.tan(.5 * z * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(t, e, n, r, i, a) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const t = this.near; let e = t * Math.tan(.5 * z * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, i = -.5 * r; const a = this.view; if (null !== this.view && this.view.enabled) { const t = a.fullWidth, o = a.fullHeight; i += a.offsetX * r / t, e -= a.offsetY * n / o, r *= a.width / t, n *= a.height / o } const o = this.filmOffset; 0 !== o && (i += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(t) { const e = super.toJSON(t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } } const yn = 90; class xn extends ve { constructor(t, e, n) { if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const r = new _n(yn, 1, t, e); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new mt(1, 0, 0)), this.add(r); const i = new _n(yn, 1, t, e); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new mt(-1, 0, 0)), this.add(i); const a = new _n(yn, 1, t, e); a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new mt(0, 1, 0)), this.add(a); const o = new _n(yn, 1, t, e); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new mt(0, -1, 0)), this.add(o); const s = new _n(yn, 1, t, e); s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new mt(0, 0, 1)), this.add(s); const l = new _n(yn, 1, t, e); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new mt(0, 0, -1)), this.add(l) } update(t, e) { null === this.parent && this.updateMatrixWorld(); const n = this.renderTarget, [r, i, a, o, s, l] = this.children, c = t.getRenderTarget(), u = t.toneMapping, h = t.xr.enabled; t.toneMapping = 0, t.xr.enabled = !1; const d = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, s), n.texture.generateMipmaps = d, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(c), t.toneMapping = u, t.xr.enabled = h, n.texture.needsPMREMUpdate = !0 } } class bn extends ct { constructor(t, n, r, i, a, o, s, l, c, u) { super(t = void 0 !== t ? t : [], n = void 0 !== n ? n : e, r, i, a, o, s, l, c, u), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(t) { this.image = t } } class Mn extends ht { constructor(t, e = {}) { super(t, t, e), this.isWebGLCubeRenderTarget = !0; const n = { width: t, height: t, depth: 1 }, r = [n, n, n, n, n, n]; this.texture = new bn(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : u } fromEquirectangularTexture(t, e) { this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; const n = { tEquirect: { value: null } }, r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t", a = new dn(5, 5, 5), o = new gn({ name: "CubemapFromEquirect", uniforms: fn(n), vertexShader: r, fragmentShader: i, side: 1, blending: 0 }); o.uniforms.tEquirect.value = e; const s = new un(a, o), l = e.minFilter; return e.minFilter === h && (e.minFilter = u), new xn(1, 10, this).update(t, s), e.minFilter = l, s.geometry.dispose(), s.material.dispose(), this } clear(t, e, n, r) { const i = t.getRenderTarget(); for (let i = 0; i < 6; i++)t.setRenderTarget(this, i), t.clear(e, n, r); t.setRenderTarget(i) } } const wn = new mt, Sn = new mt, Tn = new W; class En { constructor(t = new mt(1, 0, 0), e = 0) { this.isPlane = !0, this.normal = t, this.constant = e } set(t, e) { return this.normal.copy(t), this.constant = e, this } setComponents(t, e, n, r) { return this.normal.set(t, e, n), this.constant = r, this } setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this } setFromCoplanarPoints(t, e, n) { const r = wn.subVectors(n, e).cross(Sn.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(r, t), this } copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this } normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(t) { return this.normal.dot(t) + this.constant } distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius } projectPoint(t, e) { return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) } intersectLine(t, e) { const n = t.delta(wn), r = this.normal.dot(n); if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null; const i = -(t.start.dot(this.normal) + this.constant) / r; return i < 0 || i > 1 ? null : e.copy(n).multiplyScalar(i).add(t.start) } intersectsLine(t) { const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end); return e < 0 && n > 0 || n < 0 && e > 0 } intersectsBox(t) { return t.intersectsPlane(this) } intersectsSphere(t) { return t.intersectsPlane(this) } coplanarPoint(t) { return t.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(t, e) { const n = e || Tn.getNormalMatrix(t), r = this.coplanarPoint(wn).applyMatrix4(t), i = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(i), this } translate(t) { return this.constant -= t.dot(this.normal), this } equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant } clone() { return (new this.constructor).copy(this) } } const An = new Ft, Cn = new mt; class Ln { constructor(t = new En, e = new En, n = new En, r = new En, i = new En, a = new En) { this.planes = [t, e, n, r, i, a] } set(t, e, n, r, i, a) { const o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this } copy(t) { const e = this.planes; for (let n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this } setFromProjectionMatrix(t) { const e = this.planes, n = t.elements, r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], l = n[5], c = n[6], u = n[7], h = n[8], d = n[9], f = n[10], p = n[11], m = n[12], g = n[13], v = n[14], _ = n[15]; return e[0].setComponents(o - r, u - s, p - h, _ - m).normalize(), e[1].setComponents(o + r, u + s, p + h, _ + m).normalize(), e[2].setComponents(o + i, u + l, p + d, _ + g).normalize(), e[3].setComponents(o - i, u - l, p - d, _ - g).normalize(), e[4].setComponents(o - a, u - c, p - f, _ - v).normalize(), e[5].setComponents(o + a, u + c, p + f, _ + v).normalize(), this } intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), An.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(An) } intersectsSprite(t) { return An.center.set(0, 0, 0), An.radius = .7071067811865476, An.applyMatrix4(t.matrixWorld), this.intersectsSphere(An) } intersectsSphere(t) { const e = this.planes, n = t.center, r = -t.radius; for (let t = 0; t < 6; t++)if (e[t].distanceToPoint(n) < r) return !1; return !0 } intersectsBox(t) { const e = this.planes; for (let n = 0; n < 6; n++) { const r = e[n]; if (Cn.x = r.normal.x > 0 ? t.max.x : t.min.x, Cn.y = r.normal.y > 0 ? t.max.y : t.min.y, Cn.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Cn) < 0) return !1 } return !0 } containsPoint(t) { const e = this.planes; for (let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function Pn() { let t = null, e = !1, n = null, r = null; function i(e, a) { n(e, a), r = t.requestAnimationFrame(i) } return { start: function () { !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0) }, stop: function () { t.cancelAnimationFrame(r), e = !1 }, setAnimationLoop: function (t) { n = t }, setContext: function (e) { t = e } } } function Rn(t, e) { const n = e.isWebGL2, r = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), r.get(t) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); const n = r.get(e); n && (t.deleteBuffer(n.buffer), r.delete(e)) }, update: function (e, i) { if (e.isGLBufferAttribute) { const t = r.get(e); return void ((!t || t.version < e.version) && r.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) } e.isInterleavedBufferAttribute && (e = e.data); const a = r.get(e); void 0 === a ? r.set(e, function (e, r) { const i = e.array, a = e.usage, o = t.createBuffer(); let s; if (t.bindBuffer(r, o), t.bufferData(r, i, a), e.onUploadCallback(), i instanceof Float32Array) s = 5126; else if (i instanceof Uint16Array) if (e.isFloat16BufferAttribute) { if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); s = 5131 } else s = 5123; else if (i instanceof Int16Array) s = 5122; else if (i instanceof Uint32Array) s = 5125; else if (i instanceof Int32Array) s = 5124; else if (i instanceof Int8Array) s = 5120; else if (i instanceof Uint8Array) s = 5121; else { if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i); s = 5121 } return { buffer: o, type: s, bytesPerElement: i.BYTES_PER_ELEMENT, version: e.version } }(e, i)) : a.version < e.version && (function (e, r, i) { const a = r.array, o = r.updateRange; t.bindBuffer(i, e), -1 === o.count ? t.bufferSubData(i, 0, a) : (n ? t.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : t.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1) }(a.buffer, e, i), a.version = e.version) } } } class Dn extends je { constructor(t = 1, e = 1, n = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: r }; const i = t / 2, a = e / 2, o = Math.floor(n), s = Math.floor(r), l = o + 1, c = s + 1, u = t / o, h = e / s, d = [], f = [], p = [], m = []; for (let t = 0; t < c; t++) { const e = t * h - a; for (let n = 0; n < l; n++) { const r = n * u - i; f.push(r, -e, 0), p.push(0, 0, 1), m.push(n / o), m.push(1 - t / s) } } for (let t = 0; t < s; t++)for (let e = 0; e < o; e++) { const n = e + l * t, r = e + l * (t + 1), i = e + 1 + l * (t + 1), a = e + 1 + l * t; d.push(n, r, a), d.push(r, i, a) } this.setIndex(d), this.setAttribute("position", new Fe(f, 3)), this.setAttribute("normal", new Fe(p, 3)), this.setAttribute("uv", new Fe(m, 2)) } static fromJSON(t) { return new Dn(t.width, t.height, t.widthSegments, t.heightSegments) } } const In = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}" }, On = { common: { diffuse: { value: new rt(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new W }, uv2Transform: { value: new W }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new H(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new rt(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new rt(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new W } }, sprite: { diffuse: { value: new rt(16777215) }, opacity: { value: 1 }, center: { value: new H(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new W } } }, Nn = { basic: { uniforms: pn([On.common, On.specularmap, On.envmap, On.aomap, On.lightmap, On.fog]), vertexShader: In.meshbasic_vert, fragmentShader: In.meshbasic_frag }, lambert: { uniforms: pn([On.common, On.specularmap, On.envmap, On.aomap, On.lightmap, On.emissivemap, On.fog, On.lights, { emissive: { value: new rt(0) } }]), vertexShader: In.meshlambert_vert, fragmentShader: In.meshlambert_frag }, phong: { uniforms: pn([On.common, On.specularmap, On.envmap, On.aomap, On.lightmap, On.emissivemap, On.bumpmap, On.normalmap, On.displacementmap, On.fog, On.lights, { emissive: { value: new rt(0) }, specular: { value: new rt(1118481) }, shininess: { value: 30 } }]), vertexShader: In.meshphong_vert, fragmentShader: In.meshphong_frag }, standard: { uniforms: pn([On.common, On.envmap, On.aomap, On.lightmap, On.emissivemap, On.bumpmap, On.normalmap, On.displacementmap, On.roughnessmap, On.metalnessmap, On.fog, On.lights, { emissive: { value: new rt(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: In.meshphysical_vert, fragmentShader: In.meshphysical_frag }, toon: { uniforms: pn([On.common, On.aomap, On.lightmap, On.emissivemap, On.bumpmap, On.normalmap, On.displacementmap, On.gradientmap, On.fog, On.lights, { emissive: { value: new rt(0) } }]), vertexShader: In.meshtoon_vert, fragmentShader: In.meshtoon_frag }, matcap: { uniforms: pn([On.common, On.bumpmap, On.normalmap, On.displacementmap, On.fog, { matcap: { value: null } }]), vertexShader: In.meshmatcap_vert, fragmentShader: In.meshmatcap_frag }, points: { uniforms: pn([On.points, On.fog]), vertexShader: In.points_vert, fragmentShader: In.points_frag }, dashed: { uniforms: pn([On.common, On.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: In.linedashed_vert, fragmentShader: In.linedashed_frag }, depth: { uniforms: pn([On.common, On.displacementmap]), vertexShader: In.depth_vert, fragmentShader: In.depth_frag }, normal: { uniforms: pn([On.common, On.bumpmap, On.normalmap, On.displacementmap, { opacity: { value: 1 } }]), vertexShader: In.meshnormal_vert, fragmentShader: In.meshnormal_frag }, sprite: { uniforms: pn([On.sprite, On.fog]), vertexShader: In.sprite_vert, fragmentShader: In.sprite_frag }, background: { uniforms: { uvTransform: { value: new W }, t2D: { value: null } }, vertexShader: In.background_vert, fragmentShader: In.background_frag }, cube: { uniforms: pn([On.envmap, { opacity: { value: 1 } }]), vertexShader: In.cube_vert, fragmentShader: In.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: In.equirect_vert, fragmentShader: In.equirect_frag }, distanceRGBA: { uniforms: pn([On.common, On.displacementmap, { referencePosition: { value: new mt }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: In.distanceRGBA_vert, fragmentShader: In.distanceRGBA_frag }, shadow: { uniforms: pn([On.lights, On.fog, { color: { value: new rt(0) }, opacity: { value: 1 } }]), vertexShader: In.shadow_vert, fragmentShader: In.shadow_frag } }; function zn(t, e, n, r, i, o) { const s = new rt(0); let l, c, u = !0 === i ? 0 : 1, h = null, d = 0, f = null; function p(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, o) } return { getClearColor: function () { return s }, setClearColor: function (t, e = 1) { s.set(t), u = e, p(s, u) }, getClearAlpha: function () { return u }, setClearAlpha: function (t) { u = t, p(s, u) }, render: function (n, i) { let o = !1, m = !0 === i.isScene ? i.background : null; m && m.isTexture && (m = e.get(m)); const g = t.xr, v = g.getSession && g.getSession(); v && "additive" === v.environmentBlendMode && (m = null), null === m ? p(s, u) : m && m.isColor && (p(m, 1), o = !0), (t.autoClear || o) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.mapping === a) ? (void 0 === c && (c = new un(new dn(1, 1, 1), new gn({ name: "BackgroundCubeMaterial", uniforms: fn(Nn.cube.uniforms), vertexShader: Nn.cube.vertexShader, fragmentShader: Nn.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(c.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(c)), c.material.uniforms.envMap.value = m, c.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, h === m && d === m.version && f === t.toneMapping || (c.material.needsUpdate = !0, h = m, d = m.version, f = t.toneMapping), c.layers.enableAll(), n.unshift(c, c.geometry, c.material, 0, 0, null)) : m && m.isTexture && (void 0 === l && (l = new un(new Dn(2, 2), new gn({ name: "BackgroundMaterial", uniforms: fn(Nn.background.uniforms), vertexShader: Nn.background.vertexShader, fragmentShader: Nn.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(l)), l.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), l.material.uniforms.uvTransform.value.copy(m.matrix), h === m && d === m.version && f === t.toneMapping || (l.material.needsUpdate = !0, h = m, d = m.version, f = t.toneMapping), l.layers.enableAll(), n.unshift(l, l.geometry, l.material, 0, 0, null)) } } } function Fn(t, e, n, r) { const i = t.getParameter(34921), a = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = r.isWebGL2 || null !== a, s = {}, l = f(null); let c = l, u = !1; function h(e) { return r.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e) } function d(e) { return r.isWebGL2 ? t.deleteVertexArray(e) : a.deleteVertexArrayOES(e) } function f(t) { const e = [], n = [], r = []; for (let t = 0; t < i; t++)e[t] = 0, n[t] = 0, r[t] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: r, object: t, attributes: {}, index: null } } function p() { const t = c.newAttributes; for (let e = 0, n = t.length; e < n; e++)t[e] = 0 } function m(t) { g(t, 0) } function g(n, i) { const a = c.newAttributes, o = c.enabledAttributes, s = c.attributeDivisors; a[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), s[n] !== i && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i) } function v() { const e = c.newAttributes, n = c.enabledAttributes; for (let r = 0, i = n.length; r < i; r++)n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0) } function _(e, n, i, a, o, s) { !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, a, o, s) : t.vertexAttribIPointer(e, n, i, o, s) } function y() { x(), u = !0, c !== l && (c = l, h(c.object)) } function x() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (i, l, d, y, x) { let b = !1; if (o) { const e = function (e, n, i) { const o = !0 === i.wireframe; let l = s[e.id]; void 0 === l && (l = {}, s[e.id] = l); let c = l[n.id]; void 0 === c && (c = {}, l[n.id] = c); let u = c[o]; return void 0 === u && (u = f(r.isWebGL2 ? t.createVertexArray() : a.createVertexArrayOES()), c[o] = u), u }(y, d, l); c !== e && (c = e, h(c.object)), b = function (t, e, n, r) { const i = c.attributes, a = e.attributes; let o = 0; const s = n.getAttributes(); for (const e in s) if (s[e].location >= 0) { const n = i[e]; let r = a[e]; if (void 0 === r && ("instanceMatrix" === e && t.instanceMatrix && (r = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (r = t.instanceColor)), void 0 === n) return !0; if (n.attribute !== r) return !0; if (r && n.data !== r.data) return !0; o++ } return c.attributesNum !== o || c.index !== r }(i, y, d, x), b && function (t, e, n, r) { const i = {}, a = e.attributes; let o = 0; const s = n.getAttributes(); for (const e in s) if (s[e].location >= 0) { let n = a[e]; void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor)); const r = {}; r.attribute = n, n && n.data && (r.data = n.data), i[e] = r, o++ } c.attributes = i, c.attributesNum = o, c.index = r }(i, y, d, x) } else { const t = !0 === l.wireframe; c.geometry === y.id && c.program === d.id && c.wireframe === t || (c.geometry = y.id, c.program = d.id, c.wireframe = t, b = !0) } null !== x && n.update(x, 34963), (b || u) && (u = !1, function (i, a, o, s) { if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return; p(); const l = s.attributes, c = o.getAttributes(), u = a.defaultAttributeValues; for (const e in c) { const r = c[e]; if (r.location >= 0) { let a = l[e]; if (void 0 === a && ("instanceMatrix" === e && i.instanceMatrix && (a = i.instanceMatrix), "instanceColor" === e && i.instanceColor && (a = i.instanceColor)), void 0 !== a) { const e = a.normalized, o = a.itemSize, l = n.get(a); if (void 0 === l) continue; const c = l.buffer, u = l.type, h = l.bytesPerElement; if (a.isInterleavedBufferAttribute) { const n = a.data, l = n.stride, d = a.offset; if (n.isInstancedInterleavedBuffer) { for (let t = 0; t < r.locationSize; t++)g(r.location + t, n.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count) } else for (let t = 0; t < r.locationSize; t++)m(r.location + t); t.bindBuffer(34962, c); for (let t = 0; t < r.locationSize; t++)_(r.location + t, o / r.locationSize, u, e, l * h, (d + o / r.locationSize * t) * h) } else { if (a.isInstancedBufferAttribute) { for (let t = 0; t < r.locationSize; t++)g(r.location + t, a.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count) } else for (let t = 0; t < r.locationSize; t++)m(r.location + t); t.bindBuffer(34962, c); for (let t = 0; t < r.locationSize; t++)_(r.location + t, o / r.locationSize, u, e, o * h, o / r.locationSize * t * h) } } else if (void 0 !== u) { const n = u[e]; if (void 0 !== n) switch (n.length) { case 2: t.vertexAttrib2fv(r.location, n); break; case 3: t.vertexAttrib3fv(r.location, n); break; case 4: t.vertexAttrib4fv(r.location, n); break; default: t.vertexAttrib1fv(r.location, n) } } } } v() }(i, l, d, y), null !== x && t.bindBuffer(34963, n.get(x).buffer)) }, reset: y, resetDefaultState: x, dispose: function () { y(); for (const t in s) { const e = s[t]; for (const t in e) { const n = e[t]; for (const t in n) d(n[t].object), delete n[t]; delete e[t] } delete s[t] } }, releaseStatesOfGeometry: function (t) { if (void 0 === s[t.id]) return; const e = s[t.id]; for (const t in e) { const n = e[t]; for (const t in n) d(n[t].object), delete n[t]; delete e[t] } delete s[t.id] }, releaseStatesOfProgram: function (t) { for (const e in s) { const n = s[e]; if (void 0 === n[t.id]) continue; const r = n[t.id]; for (const t in r) d(r[t].object), delete r[t]; delete n[t.id] } }, initAttributes: p, enableAttribute: m, disableUnusedAttributes: v } } function Un(t, e, n, r) { const i = r.isWebGL2; let a; this.setMode = function (t) { a = t }, this.render = function (e, r) { t.drawArrays(a, e, r), n.update(r, a, 1) }, this.renderInstances = function (r, o, s) { if (0 === s) return; let l, c; if (i) l = t, c = "drawArraysInstanced"; else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](a, r, o, s), n.update(o, a, s) } } function kn(t, e, n) { let r; function i(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let o = void 0 !== n.precision ? n.precision : "highp"; const s = i(o); s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); const l = a || e.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, u = t.getParameter(34930), h = t.getParameter(35660), d = t.getParameter(3379), f = t.getParameter(34076), p = t.getParameter(34921), m = t.getParameter(36347), g = t.getParameter(36348), v = t.getParameter(36349), _ = h > 0, y = a || e.has("OES_texture_float"); return { isWebGL2: a, drawBuffers: l, getMaxAnisotropy: function () { if (void 0 !== r) return r; if (!0 === e.has("EXT_texture_filter_anisotropic")) { const n = e.get("EXT_texture_filter_anisotropic"); r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r }, getMaxPrecision: i, precision: o, logarithmicDepthBuffer: c, maxTextures: u, maxVertexTextures: h, maxTextureSize: d, maxCubemapSize: f, maxAttributes: p, maxVertexUniforms: m, maxVaryings: g, maxFragmentUniforms: v, vertexTextures: _, floatFragmentTextures: y, floatVertexTextures: _ && y, maxSamples: a ? t.getParameter(36183) : 0 } } function Bn(t) { const e = this; let n = null, r = 0, i = !1, a = !1; const o = new En, s = new W, l = { value: null, needsUpdate: !1 }; function c() { l.value !== n && (l.value = n, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0 } function u(t, n, r, i) { const a = null !== t ? t.length : 0; let c = null; if (0 !== a) { if (c = l.value, !0 !== i || null === c) { const e = r + 4 * a, i = n.matrixWorldInverse; s.getNormalMatrix(i), (null === c || c.length < e) && (c = new Float32Array(e)); for (let e = 0, n = r; e !== a; ++e, n += 4)o.copy(t[e]).applyMatrix4(i, s), o.normal.toArray(c, n), c[n + 3] = o.constant } l.value = c, l.needsUpdate = !0 } return e.numPlanes = a, e.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, a) { const o = 0 !== t.length || e || 0 !== r || i; return i = e, n = u(t, a, 0), r = t.length, o }, this.beginShadows = function () { a = !0, u(null) }, this.endShadows = function () { a = !1, c() }, this.setState = function (e, o, s) { const h = e.clippingPlanes, d = e.clipIntersection, f = e.clipShadows, p = t.get(e); if (!i || null === h || 0 === h.length || a && !f) a ? u(null) : c(); else { const t = a ? 0 : r, e = 4 * t; let i = p.clippingState || null; l.value = i, i = u(h, o, e, s); for (let t = 0; t !== e; ++t)i[t] = n[t]; p.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t } } } function Vn(t) { let n = new WeakMap; function r(t, n) { return 303 === n ? t.mapping = e : 304 === n && (t.mapping = i), t } function a(t) { const e = t.target; e.removeEventListener("dispose", a); const r = n.get(e); void 0 !== r && (n.delete(e), r.dispose()) } return { get: function (e) { if (e && e.isTexture && !1 === e.isRenderTargetTexture) { const i = e.mapping; if (303 === i || 304 === i) { if (n.has(e)) return r(n.get(e).texture, e.mapping); { const i = e.image; if (i && i.height > 0) { const o = new Mn(i.height / 2); return o.fromEquirectangularTexture(t, e), n.set(e, o), e.addEventListener("dispose", a), r(o.texture, e.mapping) } return null } } } return e }, dispose: function () { n = new WeakMap } } } Nn.physical = { uniforms: pn([Nn.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new H(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new rt(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new H }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new rt(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new rt(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: In.meshphysical_vert, fragmentShader: In.meshphysical_frag }; class Gn extends vn { constructor(t = -1, e = 1, n = 1, r = -1, i = .1, a = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = a, this.updateProjectionMatrix() } copy(t, e) { return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this } setViewOffset(t, e, n, r, i, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let i = n - t, a = n + t, o = r + e, s = r - e; if (null !== this.view && this.view.enabled) { const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom; i += t * this.view.offsetX, a = i + t * this.view.width, o -= e * this.view.offsetY, s = o - e * this.view.height } this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(t) { const e = super.toJSON(t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } } const Hn = [.125, .215, .35, .446, .526, .582], Wn = new Gn, jn = new rt; let qn = null; const Xn = (1 + Math.sqrt(5)) / 2, Yn = 1 / Xn, Zn = [new mt(1, 1, 1), new mt(-1, 1, 1), new mt(1, 1, -1), new mt(-1, 1, -1), new mt(0, Xn, Yn), new mt(0, Xn, -Yn), new mt(Yn, 0, Xn), new mt(-Yn, 0, Xn), new mt(Xn, Yn, 0), new mt(-Xn, Yn, 0)]; class Kn { constructor(t) { this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(t, e = 0, n = .1, r = 100) { qn = this._renderer.getRenderTarget(), this._setSize(256); const i = this._allocateTargets(); return i.depthBuffer = !0, this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i } fromEquirectangular(t, e = null) { return this._fromTexture(t, e) } fromCubemap(t, e = null) { return this._fromTexture(t, e) } compileCubemapShader() { null === this._cubemapMaterial && (this._cubemapMaterial = tr(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { null === this._equirectMaterial && (this._equirectMaterial = $n(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose() } _setSize(t) { this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(); for (let t = 0; t < this._lodPlanes.length; t++)this._lodPlanes[t].dispose() } _cleanup(t) { this._renderer.setRenderTarget(qn), t.scissorTest = !1, Qn(t, 0, 0, t.width, t.height) } _fromTexture(t, n) { t.mapping === e || t.mapping === i ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), qn = this._renderer.getRenderTarget(); const r = n || this._allocateTargets(); return this._textureToCubeUV(t, r), this._applyPMREM(r), this._cleanup(r), r } _allocateTargets() { const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = { magFilter: u, minFilter: u, generateMipmaps: !1, type: m, format: v, encoding: A, depthBuffer: !1 }, r = Jn(t, e, n); if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t) { null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Jn(t, e, n); const { _lodMax: r } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (t) { const e = [], n = [], r = []; let i = t; const a = t - 4 + 1 + Hn.length; for (let o = 0; o < a; o++) { const a = Math.pow(2, i); n.push(a); let s = 1 / a; o > t - 4 ? s = Hn[o - t + 4 - 1] : 0 === o && (s = 0), r.push(s); const l = 1 / (a - 2), c = -l, u = 1 + l, h = [c, c, u, c, u, u, c, c, u, u, c, u], d = 6, f = 6, p = 3, m = 2, g = 1, v = new Float32Array(p * f * d), _ = new Float32Array(m * f * d), y = new Float32Array(g * f * d); for (let t = 0; t < d; t++) { const e = t % 3 * 2 / 3 - 1, n = t > 2 ? 0 : -1, r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0]; v.set(r, p * f * t), _.set(h, m * f * t); const i = [t, t, t, t, t, t]; y.set(i, g * f * t) } const x = new je; x.setAttribute("position", new Oe(v, p)), x.setAttribute("uv", new Oe(_, m)), x.setAttribute("faceIndex", new Oe(y, g)), e.push(x), i > 4 && i-- } return { lodPlanes: e, sizeLods: n, sigmas: r } }(r)), this._blurMaterial = function (t, e, n) { const r = new Float32Array(20), i = new mt(0, 1, 0); return new gn({ name: "SphericalGaussianBlur", defines: { n: 20, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / n, CUBEUV_MAX_MIP: `${t}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: r }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) }(r, t, e) } return r } _compileMaterial(t) { const e = new un(this._lodPlanes[0], t); this._renderer.compile(e, Wn) } _sceneToCubeUV(t, e, n, r) { const i = new _n(90, 1, e, n), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], s = this._renderer, l = s.autoClear, c = s.toneMapping; s.getClearColor(jn), s.toneMapping = 0, s.autoClear = !1; const u = new Re({ name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1 }), h = new un(new dn, u); let d = !1; const f = t.background; f ? f.isColor && (u.color.copy(f), t.background = null, d = !0) : (u.color.copy(jn), d = !0); for (let e = 0; e < 6; e++) { const n = e % 3; 0 === n ? (i.up.set(0, a[e], 0), i.lookAt(o[e], 0, 0)) : 1 === n ? (i.up.set(0, 0, a[e]), i.lookAt(0, o[e], 0)) : (i.up.set(0, a[e], 0), i.lookAt(0, 0, o[e])); const l = this._cubeSize; Qn(r, n * l, e > 2 ? l : 0, l, l), s.setRenderTarget(r), d && s.render(h, i), s.render(t, i) } h.geometry.dispose(), h.material.dispose(), s.toneMapping = c, s.autoClear = l, t.background = f } _textureToCubeUV(t, n) { const r = this._renderer, a = t.mapping === e || t.mapping === i; a ? (null === this._cubemapMaterial && (this._cubemapMaterial = tr()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = $n()); const o = a ? this._cubemapMaterial : this._equirectMaterial, s = new un(this._lodPlanes[0], o); o.uniforms.envMap.value = t; const l = this._cubeSize; Qn(n, 0, 0, 3 * l, 2 * l), r.setRenderTarget(n), r.render(s, Wn) } _applyPMREM(t) { const e = this._renderer, n = e.autoClear; e.autoClear = !1; for (let e = 1; e < this._lodPlanes.length; e++) { const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]), r = Zn[(e - 1) % Zn.length]; this._blur(t, e - 1, e, n, r) } e.autoClear = n } _blur(t, e, n, r, i) { const a = this._pingPongRenderTarget; this._halfBlur(t, a, e, n, r, "latitudinal", i), this._halfBlur(a, t, n, n, r, "longitudinal", i) } _halfBlur(t, e, n, r, i, a, o) { const s = this._renderer, l = this._blurMaterial; "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"); const c = new un(this._lodPlanes[r], l), u = l.uniforms, h = this._sizeLods[n] - 1, d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39, f = i / d, p = isFinite(i) ? 1 + Math.floor(3 * f) : 20; p > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`); const m = []; let g = 0; for (let t = 0; t < 20; ++t) { const e = t / f, n = Math.exp(-e * e / 2); m.push(n), 0 === t ? g += n : t < p && (g += 2 * n) } for (let t = 0; t < m.length; t++)m[t] = m[t] / g; u.envMap.value = t.texture, u.samples.value = p, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, o && (u.poleAxis.value = o); const { _lodMax: v } = this; u.dTheta.value = d, u.mipInt.value = v - n; const _ = this._sizeLods[r]; Qn(e, 3 * _ * (r > v - 4 ? r - v + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _), s.setRenderTarget(e), s.render(c, Wn) } } function Jn(t, e, n) { const r = new ht(t, e, n); return r.texture.mapping = a, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r } function Qn(t, e, n, r, i) { t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i) } function $n() { return new gn({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function tr() { return new gn({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function er(t) { let n = new WeakMap, r = null; function a(t) { const e = t.target; e.removeEventListener("dispose", a); const r = n.get(e); void 0 !== r && (n.delete(e), r.dispose()) } return { get: function (o) { if (o && o.isTexture) { const s = o.mapping, l = 303 === s || 304 === s, c = s === e || s === i; if (l || c) { if (o.isRenderTargetTexture && !0 === o.needsPMREMUpdate) { o.needsPMREMUpdate = !1; let e = n.get(o); return null === r && (r = new Kn(t)), e = l ? r.fromEquirectangular(o, e) : r.fromCubemap(o, e), n.set(o, e), e.texture } if (n.has(o)) return n.get(o).texture; { const e = o.image; if (l && e && e.height > 0 || c && e && function (t) { let e = 0; for (let n = 0; n < 6; n++)void 0 !== t[n] && e++; return 6 === e }(e)) { null === r && (r = new Kn(t)); const e = l ? r.fromEquirectangular(o) : r.fromCubemap(o); return n.set(o, e), o.addEventListener("dispose", a), e.texture } return null } } } return o }, dispose: function () { n = new WeakMap, null !== r && (r.dispose(), r = null) } } } function nr(t) { const e = {}; function n(n) { if (void 0 !== e[n]) return e[n]; let r; switch (n) { case "WEBGL_depth_texture": r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = t.getExtension(n) }return e[n] = r, r } return { has: function (t) { return null !== n(t) }, init: function (t) { t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture") }, get: function (t) { const e = n(t); return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e } } } function rr(t, e, n, r) { const i = {}, a = new WeakMap; function o(t) { const s = t.target; null !== s.index && e.remove(s.index); for (const t in s.attributes) e.remove(s.attributes[t]); s.removeEventListener("dispose", o), delete i[s.id]; const l = a.get(s); l && (e.remove(l), a.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries-- } function s(t) { const n = [], r = t.index, i = t.attributes.position; let o = 0; if (null !== r) { const t = r.array; o = r.version; for (let e = 0, r = t.length; e < r; e += 3) { const r = t[e + 0], i = t[e + 1], a = t[e + 2]; n.push(r, i, i, a, a, r) } } else { const t = i.array; o = i.version; for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) { const t = e + 0, r = e + 1, i = e + 2; n.push(t, r, r, i, i, t) } } const s = new (j(n) ? ze : Ne)(n, 1); s.version = o; const l = a.get(t); l && e.remove(l), a.set(t, s) } return { get: function (t, e) { return !0 === i[e.id] || (e.addEventListener("dispose", o), i[e.id] = !0, n.memory.geometries++), e }, update: function (t) { const n = t.attributes; for (const t in n) e.update(n[t], 34962); const r = t.morphAttributes; for (const t in r) { const n = r[t]; for (let t = 0, r = n.length; t < r; t++)e.update(n[t], 34962) } }, getWireframeAttribute: function (t) { const e = a.get(t); if (e) { const n = t.index; null !== n && e.version < n.version && s(t) } else s(t); return a.get(t) } } } function ir(t, e, n, r) { const i = r.isWebGL2; let a, o, s; this.setMode = function (t) { a = t }, this.setIndex = function (t) { o = t.type, s = t.bytesPerElement }, this.render = function (e, r) { t.drawElements(a, r, o, e * s), n.update(r, a, 1) }, this.renderInstances = function (r, l, c) { if (0 === c) return; let u, h; if (i) u = t, h = "drawElementsInstanced"; else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); u[h](a, l, o, r * s, c), n.update(l, a, c) } } function ar(t) { const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, n, r) { switch (e.calls++, n) { case 4: e.triangles += r * (t / 3); break; case 1: e.lines += r * (t / 2); break; case 3: e.lines += r * (t - 1); break; case 2: e.lines += r * t; break; case 0: e.points += r * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function or(t, e) { return t[0] - e[0] } function sr(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function lr(t, e) { let n = 1; const r = e.isInterleavedBufferAttribute ? e.data.array : e.array; r instanceof Int8Array ? n = 127 : r instanceof Uint8Array ? n = 255 : r instanceof Uint16Array ? n = 65535 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), t.divideScalar(n) } function cr(t, e, n) { const r = {}, i = new Float32Array(8), a = new WeakMap, o = new ut, s = []; for (let t = 0; t < 8; t++)s[t] = [t, 0]; return { update: function (l, c, u, h) { const d = l.morphTargetInfluences; if (!0 === e.isWebGL2) { const f = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, m = void 0 !== f ? f.length : 0; let g = a.get(c); if (void 0 === g || g.count !== m) { void 0 !== g && g.texture.dispose(); const y = void 0 !== c.morphAttributes.position, x = void 0 !== c.morphAttributes.normal, b = void 0 !== c.morphAttributes.color, M = c.morphAttributes.position || [], w = c.morphAttributes.normal || [], S = c.morphAttributes.color || []; let T = 0; !0 === y && (T = 1), !0 === x && (T = 2), !0 === b && (T = 3); let E = c.attributes.position.count * T, A = 1; E > e.maxTextureSize && (A = Math.ceil(E / e.maxTextureSize), E = e.maxTextureSize); const C = new Float32Array(E * A * 4 * m), L = new dt(C, E, A, m); L.type = p, L.needsUpdate = !0; const P = 4 * T; for (let D = 0; D < m; D++) { const I = M[D], O = w[D], N = S[D], z = E * A * 4 * D; for (let F = 0; F < I.count; F++) { const U = F * P; !0 === y && (o.fromBufferAttribute(I, F), !0 === I.normalized && lr(o, I), C[z + U + 0] = o.x, C[z + U + 1] = o.y, C[z + U + 2] = o.z, C[z + U + 3] = 0), !0 === x && (o.fromBufferAttribute(O, F), !0 === O.normalized && lr(o, O), C[z + U + 4] = o.x, C[z + U + 5] = o.y, C[z + U + 6] = o.z, C[z + U + 7] = 0), !0 === b && (o.fromBufferAttribute(N, F), !0 === N.normalized && lr(o, N), C[z + U + 8] = o.x, C[z + U + 9] = o.y, C[z + U + 10] = o.z, C[z + U + 11] = 4 === N.itemSize ? o.w : 1) } } function R() { L.dispose(), a.delete(c), c.removeEventListener("dispose", R) } g = { count: m, texture: L, size: new H(E, A) }, a.set(c, g), c.addEventListener("dispose", R) } let v = 0; for (let k = 0; k < d.length; k++)v += d[k]; const _ = c.morphTargetsRelative ? 1 : 1 - v; h.getUniforms().setValue(t, "morphTargetBaseInfluence", _), h.getUniforms().setValue(t, "morphTargetInfluences", d), h.getUniforms().setValue(t, "morphTargetsTexture", g.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", g.size) } else { const B = void 0 === d ? 0 : d.length; let V = r[c.id]; if (void 0 === V || V.length !== B) { V = []; for (let X = 0; X < B; X++)V[X] = [X, 0]; r[c.id] = V } for (let Y = 0; Y < B; Y++) { const Z = V[Y]; Z[0] = Y, Z[1] = d[Y] } V.sort(sr); for (let K = 0; K < 8; K++)K < B && V[K][1] ? (s[K][0] = V[K][0], s[K][1] = V[K][1]) : (s[K][0] = Number.MAX_SAFE_INTEGER, s[K][1] = 0); s.sort(or); const G = c.morphAttributes.position, W = c.morphAttributes.normal; let j = 0; for (let J = 0; J < 8; J++) { const Q = s[J], $ = Q[0], tt = Q[1]; $ !== Number.MAX_SAFE_INTEGER && tt ? (G && c.getAttribute("morphTarget" + J) !== G[$] && c.setAttribute("morphTarget" + J, G[$]), W && c.getAttribute("morphNormal" + J) !== W[$] && c.setAttribute("morphNormal" + J, W[$]), i[J] = tt, j += tt) : (G && !0 === c.hasAttribute("morphTarget" + J) && c.deleteAttribute("morphTarget" + J), W && !0 === c.hasAttribute("morphNormal" + J) && c.deleteAttribute("morphNormal" + J), i[J] = 0) } const q = c.morphTargetsRelative ? 1 : 1 - j; h.getUniforms().setValue(t, "morphTargetBaseInfluence", q), h.getUniforms().setValue(t, "morphTargetInfluences", i) } } } } function ur(t, e, n, r) { let i = new WeakMap; function a(t) { const e = t.target; e.removeEventListener("dispose", a), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor) } return { update: function (t) { const o = r.render.frame, s = t.geometry, l = e.get(t, s); return i.get(l) !== o && (e.update(l), i.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", a) && t.addEventListener("dispose", a), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l }, dispose: function () { i = new WeakMap } } } const hr = new ct, dr = new dt, fr = new ft, pr = new bn, mr = [], gr = [], vr = new Float32Array(16), _r = new Float32Array(9), yr = new Float32Array(4); function xr(t, e, n) { const r = t[0]; if (r <= 0 || r > 0) return t; const i = e * n; let a = mr[i]; if (void 0 === a && (a = new Float32Array(i), mr[i] = a), 0 !== e) { r.toArray(a, 0); for (let r = 1, i = 0; r !== e; ++r)i += n, t[r].toArray(a, i) } return a } function br(t, e) { if (t.length !== e.length) return !1; for (let n = 0, r = t.length; n < r; n++)if (t[n] !== e[n]) return !1; return !0 } function Mr(t, e) { for (let n = 0, r = e.length; n < r; n++)t[n] = e[n] } function wr(t, e) { let n = gr[e]; void 0 === n && (n = new Int32Array(e), gr[e] = n); for (let r = 0; r !== e; ++r)n[r] = t.allocateTextureUnit(); return n } function Sr(t, e) { const n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function Tr(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (br(n, e)) return; t.uniform2fv(this.addr, e), Mr(n, e) } } function Er(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else { if (br(n, e)) return; t.uniform3fv(this.addr, e), Mr(n, e) } } function Ar(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (br(n, e)) return; t.uniform4fv(this.addr, e), Mr(n, e) } } function Cr(t, e) { const n = this.cache, r = e.elements; if (void 0 === r) { if (br(n, e)) return; t.uniformMatrix2fv(this.addr, !1, e), Mr(n, e) } else { if (br(n, r)) return; yr.set(r), t.uniformMatrix2fv(this.addr, !1, yr), Mr(n, r) } } function Lr(t, e) { const n = this.cache, r = e.elements; if (void 0 === r) { if (br(n, e)) return; t.uniformMatrix3fv(this.addr, !1, e), Mr(n, e) } else { if (br(n, r)) return; _r.set(r), t.uniformMatrix3fv(this.addr, !1, _r), Mr(n, r) } } function Pr(t, e) { const n = this.cache, r = e.elements; if (void 0 === r) { if (br(n, e)) return; t.uniformMatrix4fv(this.addr, !1, e), Mr(n, e) } else { if (br(n, r)) return; vr.set(r), t.uniformMatrix4fv(this.addr, !1, vr), Mr(n, r) } } function Rr(t, e) { const n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function Dr(t, e) { const n = this.cache; br(n, e) || (t.uniform2iv(this.addr, e), Mr(n, e)) } function Ir(t, e) { const n = this.cache; br(n, e) || (t.uniform3iv(this.addr, e), Mr(n, e)) } function Or(t, e) { const n = this.cache; br(n, e) || (t.uniform4iv(this.addr, e), Mr(n, e)) } function Nr(t, e) { const n = this.cache; n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e) } function zr(t, e) { const n = this.cache; br(n, e) || (t.uniform2uiv(this.addr, e), Mr(n, e)) } function Fr(t, e) { const n = this.cache; br(n, e) || (t.uniform3uiv(this.addr, e), Mr(n, e)) } function Ur(t, e) { const n = this.cache; br(n, e) || (t.uniform4uiv(this.addr, e), Mr(n, e)) } function kr(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(e || hr, i) } function Br(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || fr, i) } function Vr(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || pr, i) } function Gr(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || dr, i) } function Hr(t, e) { t.uniform1fv(this.addr, e) } function Wr(t, e) { const n = xr(e, this.size, 2); t.uniform2fv(this.addr, n) } function jr(t, e) { const n = xr(e, this.size, 3); t.uniform3fv(this.addr, n) } function qr(t, e) { const n = xr(e, this.size, 4); t.uniform4fv(this.addr, n) } function Xr(t, e) { const n = xr(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, n) } function Yr(t, e) { const n = xr(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, n) } function Zr(t, e) { const n = xr(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, n) } function Kr(t, e) { t.uniform1iv(this.addr, e) } function Jr(t, e) { t.uniform2iv(this.addr, e) } function Qr(t, e) { t.uniform3iv(this.addr, e) } function $r(t, e) { t.uniform4iv(this.addr, e) } function ti(t, e) { t.uniform1uiv(this.addr, e) } function ei(t, e) { t.uniform2uiv(this.addr, e) } function ni(t, e) { t.uniform3uiv(this.addr, e) } function ri(t, e) { t.uniform4uiv(this.addr, e) } function ii(t, e, n) { const r = e.length, i = wr(n, r); t.uniform1iv(this.addr, i); for (let t = 0; t !== r; ++t)n.setTexture2D(e[t] || hr, i[t]) } function ai(t, e, n) { const r = e.length, i = wr(n, r); t.uniform1iv(this.addr, i); for (let t = 0; t !== r; ++t)n.setTexture3D(e[t] || fr, i[t]) } function oi(t, e, n) { const r = e.length, i = wr(n, r); t.uniform1iv(this.addr, i); for (let t = 0; t !== r; ++t)n.setTextureCube(e[t] || pr, i[t]) } function si(t, e, n) { const r = e.length, i = wr(n, r); t.uniform1iv(this.addr, i); for (let t = 0; t !== r; ++t)n.setTexture2DArray(e[t] || dr, i[t]) } class li { constructor(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return Sr; case 35664: return Tr; case 35665: return Er; case 35666: return Ar; case 35674: return Cr; case 35675: return Lr; case 35676: return Pr; case 5124: case 35670: return Rr; case 35667: case 35671: return Dr; case 35668: case 35672: return Ir; case 35669: case 35673: return Or; case 5125: return Nr; case 36294: return zr; case 36295: return Fr; case 36296: return Ur; case 35678: case 36198: case 36298: case 36306: case 35682: return kr; case 35679: case 36299: case 36307: return Br; case 35680: case 36300: case 36308: case 36293: return Vr; case 36289: case 36303: case 36311: case 36292: return Gr } }(e.type) } } class ci { constructor(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return Hr; case 35664: return Wr; case 35665: return jr; case 35666: return qr; case 35674: return Xr; case 35675: return Yr; case 35676: return Zr; case 5124: case 35670: return Kr; case 35667: case 35671: return Jr; case 35668: case 35672: return Qr; case 35669: case 35673: return $r; case 5125: return ti; case 36294: return ei; case 36295: return ni; case 36296: return ri; case 35678: case 36198: case 36298: case 36306: case 35682: return ii; case 35679: case 36299: case 36307: return ai; case 35680: case 36300: case 36308: case 36293: return oi; case 36289: case 36303: case 36311: case 36292: return si } }(e.type) } } class ui { constructor(t) { this.id = t, this.seq = [], this.map = {} } setValue(t, e, n) { const r = this.seq; for (let i = 0, a = r.length; i !== a; ++i) { const a = r[i]; a.setValue(t, e[a.id], n) } } } const hi = /(\w+)(\])?(\[|\.)?/g; function di(t, e) { t.seq.push(e), t.map[e.id] = e } function fi(t, e, n) { const r = t.name, i = r.length; for (hi.lastIndex = 0; ;) { const a = hi.exec(r), o = hi.lastIndex; let s = a[1]; const l = "]" === a[2], c = a[3]; if (l && (s |= 0), void 0 === c || "[" === c && o + 2 === i) { di(n, void 0 === c ? new li(s, t, e) : new ci(s, t, e)); break } { let t = n.map[s]; void 0 === t && (t = new ui(s), di(n, t)), n = t } } } class pi { constructor(t, e) { this.seq = [], this.map = {}; const n = t.getProgramParameter(e, 35718); for (let r = 0; r < n; ++r) { const n = t.getActiveUniform(e, r); fi(n, t.getUniformLocation(e, n.name), this) } } setValue(t, e, n, r) { const i = this.map[e]; void 0 !== i && i.setValue(t, n, r) } setOptional(t, e, n) { const r = e[n]; void 0 !== r && this.setValue(t, n, r) } static upload(t, e, n, r) { for (let i = 0, a = e.length; i !== a; ++i) { const a = e[i], o = n[a.id]; !1 !== o.needsUpdate && a.setValue(t, o.value, r) } } static seqWithValue(t, e) { const n = []; for (let r = 0, i = t.length; r !== i; ++r) { const i = t[r]; i.id in e && n.push(i) } return n } } function mi(t, e, n) { const r = t.createShader(e); return t.shaderSource(r, n), t.compileShader(r), r } let gi = 0; function vi(t, e, n) { const r = t.getShaderParameter(e, 35713), i = t.getShaderInfoLog(e).trim(); if (r && "" === i) return ""; const a = /ERROR: 0:(\d+)/.exec(i); if (a) { const r = parseInt(a[1]); return n.toUpperCase() + "\n\n" + i + "\n\n" + function (t, e) { const n = t.split("\n"), r = [], i = Math.max(e - 6, 0), a = Math.min(e + 6, n.length); for (let t = i; t < a; t++) { const i = t + 1; r.push(`${i === e ? ">" : " "} ${i}: ${n[t]}`) } return r.join("\n") }(t.getShaderSource(e), r) } return i } function _i(t, e) { const n = function (t) { switch (t) { case A: return ["Linear", "( value )"]; case C: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"] } }(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function yi(t, e) { let n; switch (e) { case 1: n = "Linear"; break; case 2: n = "Reinhard"; break; case 3: n = "OptimizedCineon"; break; case 4: n = "ACESFilmic"; break; case 5: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function xi(t) { return "" !== t } function bi(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function Mi(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const wi = /^[ \t]*#include +<([\w\d./]+)>/gm; function Si(t) { return t.replace(wi, Ti) } function Ti(t, e) { const n = In[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return Si(n) } const Ei = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Ai = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Ci(t) { return t.replace(Ai, Pi).replace(Ei, Li) } function Li(t, e, n, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Pi(0, e, n, r) } function Pi(t, e, n, r) { let i = ""; for (let t = parseInt(e); t < parseInt(n); t++)i += r.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return i } function Ri(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function Di(t, n, r, o) { const s = t.getContext(), l = r.defines; let c = r.vertexShader, u = r.fragmentShader; const h = function (t) { let e = "SHADOWMAP_TYPE_BASIC"; return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e }(r), d = function (t) { let n = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case e: case i: n = "ENVMAP_TYPE_CUBE"; break; case a: n = "ENVMAP_TYPE_CUBE_UV" }return n }(r), f = function (t) { let e = "ENVMAP_MODE_REFLECTION"; return t.envMap && t.envMapMode === i && (e = "ENVMAP_MODE_REFRACTION"), e }(r), p = function (t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case 0: e = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: e = "ENVMAP_BLENDING_MIX"; break; case 2: e = "ENVMAP_BLENDING_ADD" }return e }(r), m = function (t) { const e = t.envMapCubeUVHeight; if (null === e) return null; const n = Math.log2(e) - 2, r = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)), texelHeight: r, maxMip: n } }(r), g = r.isWebGL2 ? "" : function (t) { return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xi).join("\n") }(r), v = function (t) { const e = []; for (const n in t) { const r = t[n]; !1 !== r && e.push("#define " + n + " " + r) } return e.join("\n") }(l), _ = s.createProgram(); let y, x, b = r.glslVersion ? "#version " + r.glslVersion + "\n" : ""; r.isRawShaderMaterial ? (y = [v].filter(xi).join("\n"), y.length > 0 && (y += "\n"), x = [g, v].filter(xi).join("\n"), x.length > 0 && (x += "\n")) : (y = [Ri(r), "#define SHADER_NAME " + r.shaderName, v, r.instancing ? "#define USE_INSTANCING" : "", r.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + f : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", r.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.morphColors && r.isWebGL2 ? "#define USE_MORPHCOLORS" : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + r.morphTextureStride : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_COUNT " + r.morphTargetsCount : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + h : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(xi).join("\n"), x = [g, Ri(r), "#define SHADER_NAME " + r.shaderName, v, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + d : "", r.envMap ? "#define " + f : "", r.envMap ? "#define " + p : "", m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "", m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "", m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoat ? "#define USE_CLEARCOAT" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.iridescence ? "#define USE_IRIDESCENCE" : "", r.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", r.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.alphaTest ? "#define USE_ALPHATEST" : "", r.sheen ? "#define USE_SHEEN" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + h : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== r.toneMapping ? "#define TONE_MAPPING" : "", 0 !== r.toneMapping ? In.tonemapping_pars_fragment : "", 0 !== r.toneMapping ? yi("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", r.opaque ? "#define OPAQUE" : "", In.encodings_pars_fragment, _i("linearToOutputTexel", r.outputEncoding), r.useDepthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(xi).join("\n")), c = Si(c), c = bi(c, r), c = Mi(c, r), u = Si(u), u = bi(u, r), u = Mi(u, r), c = Ci(c), u = Ci(u), r.isWebGL2 && !0 !== r.isRawShaderMaterial && (b = "#version 300 es\n", y = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, x = ["#define varying in", r.glslVersion === D ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", r.glslVersion === D ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x); const M = b + x + u, w = mi(s, 35633, b + y + c), S = mi(s, 35632, M); if (s.attachShader(_, w), s.attachShader(_, S), void 0 !== r.index0AttributeName ? s.bindAttribLocation(_, 0, r.index0AttributeName) : !0 === r.morphTargets && s.bindAttribLocation(_, 0, "position"), s.linkProgram(_), t.debug.checkShaderErrors) { const t = s.getProgramInfoLog(_).trim(), e = s.getShaderInfoLog(w).trim(), n = s.getShaderInfoLog(S).trim(); let r = !0, i = !0; if (!1 === s.getProgramParameter(_, 35714)) { r = !1; const e = vi(s, w, "vertex"), n = vi(s, S, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(_, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n) } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (i = !1); i && (this.diagnostics = { runnable: r, programLog: t, vertexShader: { log: e, prefix: y }, fragmentShader: { log: n, prefix: x } }) } let T, E; return s.deleteShader(w), s.deleteShader(S), this.getUniforms = function () { return void 0 === T && (T = new pi(s, _)), T }, this.getAttributes = function () { return void 0 === E && (E = function (t, e) { const n = {}, r = t.getProgramParameter(e, 35721); for (let i = 0; i < r; i++) { const r = t.getActiveAttrib(e, i), a = r.name; let o = 1; 35674 === r.type && (o = 2), 35675 === r.type && (o = 3), 35676 === r.type && (o = 4), n[a] = { type: r.type, location: t.getAttribLocation(e, a), locationSize: o } } return n }(s, _)), E }, this.destroy = function () { o.releaseStatesOfProgram(this), s.deleteProgram(_), this.program = void 0 }, this.name = r.shaderName, this.id = gi++, this.cacheKey = n, this.usedTimes = 1, this.program = _, this.vertexShader = w, this.fragmentShader = S, this } let Ii = 0; class Oi { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(t) { const e = t.vertexShader, n = t.fragmentShader, r = this._getShaderStage(e), i = this._getShaderStage(n), a = this._getShaderCacheForMaterial(t); return !1 === a.has(r) && (a.add(r), r.usedTimes++), !1 === a.has(i) && (a.add(i), i.usedTimes++), this } remove(t) { const e = this.materialCache.get(t); for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code); return this.materialCache.delete(t), this } getVertexShaderID(t) { return this._getShaderStage(t.vertexShader).id } getFragmentShaderID(t) { return this._getShaderStage(t.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(t) { const e = this.materialCache; return !1 === e.has(t) && e.set(t, new Set), e.get(t) } _getShaderStage(t) { const e = this.shaderCache; if (!1 === e.has(t)) { const n = new Ni(t); e.set(t, n) } return e.get(t) } } class Ni { constructor(t) { this.id = Ii++, this.code = t, this.usedTimes = 0 } } function zi(t, e, n, r, i, o, s) { const l = new re, c = new Oi, u = [], h = i.isWebGL2, d = i.logarithmicDepthBuffer, f = i.vertexTextures; let p = i.precision; const m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; return { getParameters: function (o, l, u, g, v) { const _ = g.fog, y = v.geometry, x = o.isMeshStandardMaterial ? g.environment : null, b = (o.isMeshStandardMaterial ? n : e).get(o.envMap || x), M = b && b.mapping === a ? b.image.height : null, w = m[o.type]; null !== o.precision && (p = i.getMaxPrecision(o.precision), p !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", p, "instead.")); const S = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color, T = void 0 !== S ? S.length : 0; let E, L, P, R, D = 0; if (void 0 !== y.morphAttributes.position && (D = 1), void 0 !== y.morphAttributes.normal && (D = 2), void 0 !== y.morphAttributes.color && (D = 3), w) { const t = Nn[w]; E = t.vertexShader, L = t.fragmentShader } else E = o.vertexShader, L = o.fragmentShader, c.update(o), P = c.getVertexShaderID(o), R = c.getFragmentShaderID(o); const I = t.getRenderTarget(), O = o.alphaTest > 0, N = o.clearcoat > 0, z = o.iridescence > 0; return { isWebGL2: h, shaderID: w, shaderName: o.type, vertexShader: E, fragmentShader: L, defines: o.defines, customVertexShaderID: P, customFragmentShaderID: R, isRawShaderMaterial: !0 === o.isRawShaderMaterial, glslVersion: o.glslVersion, precision: p, instancing: !0 === v.isInstancedMesh, instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: f, outputEncoding: null === I ? t.outputEncoding : !0 === I.isXRRenderTarget ? I.texture.encoding : A, map: !!o.map, matcap: !!o.matcap, envMap: !!b, envMapMode: b && b.mapping, envMapCubeUVHeight: M, lightMap: !!o.lightMap, aoMap: !!o.aoMap, emissiveMap: !!o.emissiveMap, bumpMap: !!o.bumpMap, normalMap: !!o.normalMap, objectSpaceNormalMap: 1 === o.normalMapType, tangentSpaceNormalMap: 0 === o.normalMapType, decodeVideoTexture: !!o.map && !0 === o.map.isVideoTexture && o.map.encoding === C, clearcoat: N, clearcoatMap: N && !!o.clearcoatMap, clearcoatRoughnessMap: N && !!o.clearcoatRoughnessMap, clearcoatNormalMap: N && !!o.clearcoatNormalMap, iridescence: z, iridescenceMap: z && !!o.iridescenceMap, iridescenceThicknessMap: z && !!o.iridescenceThicknessMap, displacementMap: !!o.displacementMap, roughnessMap: !!o.roughnessMap, metalnessMap: !!o.metalnessMap, specularMap: !!o.specularMap, specularIntensityMap: !!o.specularIntensityMap, specularColorMap: !!o.specularColorMap, opaque: !1 === o.transparent && 1 === o.blending, alphaMap: !!o.alphaMap, alphaTest: O, gradientMap: !!o.gradientMap, sheen: o.sheen > 0, sheenColorMap: !!o.sheenColorMap, sheenRoughnessMap: !!o.sheenRoughnessMap, transmission: o.transmission > 0, transmissionMap: !!o.transmissionMap, thicknessMap: !!o.thicknessMap, combine: o.combine, vertexTangents: !!o.normalMap && !!y.attributes.tangent, vertexColors: o.vertexColors, vertexAlphas: !0 === o.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize, vertexUvs: !!(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatMap || o.clearcoatRoughnessMap || o.clearcoatNormalMap || o.iridescenceMap || o.iridescenceThicknessMap || o.displacementMap || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularColorMap || o.sheenColorMap || o.sheenRoughnessMap), uvsVertexOnly: !(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatNormalMap || o.iridescenceMap || o.iridescenceThicknessMap || o.transmission > 0 || o.transmissionMap || o.thicknessMap || o.specularIntensityMap || o.specularColorMap || o.sheen > 0 || o.sheenColorMap || o.sheenRoughnessMap || !o.displacementMap), fog: !!_, useFog: !0 === o.fog, fogExp2: _ && _.isFogExp2, flatShading: !!o.flatShading, sizeAttenuation: o.sizeAttenuation, logarithmicDepthBuffer: d, skinning: !0 === v.isSkinnedMesh, morphTargets: void 0 !== y.morphAttributes.position, morphNormals: void 0 !== y.morphAttributes.normal, morphColors: void 0 !== y.morphAttributes.color, morphTargetsCount: T, morphTextureStride: D, numDirLights: l.directional.length, numPointLights: l.point.length, numSpotLights: l.spot.length, numRectAreaLights: l.rectArea.length, numHemiLights: l.hemi.length, numDirLightShadows: l.directionalShadowMap.length, numPointLightShadows: l.pointShadowMap.length, numSpotLightShadows: l.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: o.dithering, shadowMapEnabled: t.shadowMap.enabled && u.length > 0, shadowMapType: t.shadowMap.type, toneMapping: o.toneMapped ? t.toneMapping : 0, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: o.premultipliedAlpha, doubleSided: 2 === o.side, flipSided: 1 === o.side, useDepthPacking: !!o.depthPacking, depthPacking: o.depthPacking || 0, index0AttributeName: o.index0AttributeName, extensionDerivatives: o.extensions && o.extensions.derivatives, extensionFragDepth: o.extensions && o.extensions.fragDepth, extensionDrawBuffers: o.extensions && o.extensions.drawBuffers, extensionShaderTextureLOD: o.extensions && o.extensions.shaderTextureLOD, rendererExtensionFragDepth: h || r.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h || r.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h || r.has("EXT_shader_texture_lod"), customProgramCacheKey: o.customProgramCacheKey() } }, getProgramCacheKey: function (e) { const n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]); return !1 === e.isRawShaderMaterial && (function (t, e) { t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking) }(n, e), function (t, e) { l.disableAll(), e.isWebGL2 && l.enable(0), e.supportsVertexTextures && l.enable(1), e.instancing && l.enable(2), e.instancingColor && l.enable(3), e.map && l.enable(4), e.matcap && l.enable(5), e.envMap && l.enable(6), e.lightMap && l.enable(7), e.aoMap && l.enable(8), e.emissiveMap && l.enable(9), e.bumpMap && l.enable(10), e.normalMap && l.enable(11), e.objectSpaceNormalMap && l.enable(12), e.tangentSpaceNormalMap && l.enable(13), e.clearcoat && l.enable(14), e.clearcoatMap && l.enable(15), e.clearcoatRoughnessMap && l.enable(16), e.clearcoatNormalMap && l.enable(17), e.iridescence && l.enable(18), e.iridescenceMap && l.enable(19), e.iridescenceThicknessMap && l.enable(20), e.displacementMap && l.enable(21), e.specularMap && l.enable(22), e.roughnessMap && l.enable(23), e.metalnessMap && l.enable(24), e.gradientMap && l.enable(25), e.alphaMap && l.enable(26), e.alphaTest && l.enable(27), e.vertexColors && l.enable(28), e.vertexAlphas && l.enable(29), e.vertexUvs && l.enable(30), e.vertexTangents && l.enable(31), e.uvsVertexOnly && l.enable(32), e.fog && l.enable(33), t.push(l.mask), l.disableAll(), e.useFog && l.enable(0), e.flatShading && l.enable(1), e.logarithmicDepthBuffer && l.enable(2), e.skinning && l.enable(3), e.morphTargets && l.enable(4), e.morphNormals && l.enable(5), e.morphColors && l.enable(6), e.premultipliedAlpha && l.enable(7), e.shadowMapEnabled && l.enable(8), e.physicallyCorrectLights && l.enable(9), e.doubleSided && l.enable(10), e.flipSided && l.enable(11), e.useDepthPacking && l.enable(12), e.dithering && l.enable(13), e.specularIntensityMap && l.enable(14), e.specularColorMap && l.enable(15), e.transmission && l.enable(16), e.transmissionMap && l.enable(17), e.thicknessMap && l.enable(18), e.sheen && l.enable(19), e.sheenColorMap && l.enable(20), e.sheenRoughnessMap && l.enable(21), e.decodeVideoTexture && l.enable(22), e.opaque && l.enable(23), t.push(l.mask) }(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join() }, getUniforms: function (t) { const e = m[t.type]; let n; if (e) { const t = Nn[e]; n = mn.clone(t.uniforms) } else n = t.uniforms; return n }, acquireProgram: function (e, n) { let r; for (let t = 0, e = u.length; t < e; t++) { const e = u[t]; if (e.cacheKey === n) { r = e, ++r.usedTimes; break } } return void 0 === r && (r = new Di(t, n, e, o), u.push(r)), r }, releaseProgram: function (t) { if (0 == --t.usedTimes) { const e = u.indexOf(t); u[e] = u[u.length - 1], u.pop(), t.destroy() } }, releaseShaderCache: function (t) { c.remove(t) }, programs: u, dispose: function () { c.dispose() } } } function Fi() { let t = new WeakMap; return { get: function (e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function (e) { t.delete(e) }, update: function (e, n, r) { t.get(e)[n] = r }, dispose: function () { t = new WeakMap } } } function Ui(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function ki(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function Bi() { const t = []; let e = 0; const n = [], r = [], i = []; function a(n, r, i, a, o, s) { let l = t[e]; return void 0 === l ? (l = { id: n.id, object: n, geometry: r, material: i, groupOrder: a, renderOrder: n.renderOrder, z: o, group: s }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = o, l.group = s), e++, l } return { opaque: n, transmissive: r, transparent: i, init: function () { e = 0, n.length = 0, r.length = 0, i.length = 0 }, push: function (t, e, o, s, l, c) { const u = a(t, e, o, s, l, c); o.transmission > 0 ? r.push(u) : !0 === o.transparent ? i.push(u) : n.push(u) }, unshift: function (t, e, o, s, l, c) { const u = a(t, e, o, s, l, c); o.transmission > 0 ? r.unshift(u) : !0 === o.transparent ? i.unshift(u) : n.unshift(u) }, finish: function () { for (let n = e, r = t.length; n < r; n++) { const e = t[n]; if (null === e.id) break; e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null } }, sort: function (t, e) { n.length > 1 && n.sort(t || Ui), r.length > 1 && r.sort(e || ki), i.length > 1 && i.sort(e || ki) } } } function Vi() { let t = new WeakMap; return { get: function (e, n) { let r; return !1 === t.has(e) ? (r = new Bi, t.set(e, [r])) : n >= t.get(e).length ? (r = new Bi, t.get(e).push(r)) : r = t.get(e)[n], r }, dispose: function () { t = new WeakMap } } } function Gi() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { direction: new mt, color: new rt }; break; case "SpotLight": n = { position: new mt, direction: new mt, color: new rt, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new mt, color: new rt, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new mt, skyColor: new rt, groundColor: new rt }; break; case "RectAreaLight": n = { color: new rt, position: new mt, halfWidth: new mt, halfHeight: new mt } }return t[e.id] = n, n } } } let Hi = 0; function Wi(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) } function ji(t, e) { const n = new Gi, r = function () { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new H }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new H, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return t[e.id] = n, n } } }(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let t = 0; t < 9; t++)i.probe.push(new mt); const a = new mt, o = new qt, s = new qt; return { setup: function (a, o) { let s = 0, l = 0, c = 0; for (let t = 0; t < 9; t++)i.probe[t].set(0, 0, 0); let u = 0, h = 0, d = 0, f = 0, p = 0, m = 0, g = 0, v = 0; a.sort(Wi); const _ = !0 !== o ? Math.PI : 1; for (let t = 0, e = a.length; t < e; t++) { const e = a[t], o = e.color, y = e.intensity, x = e.distance, b = e.shadow && e.shadow.map ? e.shadow.map.texture : null; if (e.isAmbientLight) s += o.r * y * _, l += o.g * y * _, c += o.b * y * _; else if (e.isLightProbe) for (let t = 0; t < 9; t++)i.probe[t].addScaledVector(e.sh.coefficients[t], y); else if (e.isDirectionalLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity * _), e.castShadow) { const t = e.shadow, n = r.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[u] = n, i.directionalShadowMap[u] = b, i.directionalShadowMatrix[u] = e.shadow.matrix, m++ } i.directional[u] = t, u++ } else if (e.isSpotLight) { const t = n.get(e); if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(o).multiplyScalar(y * _), t.distance = x, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) { const t = e.shadow, n = r.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.spotShadow[d] = n, i.spotShadowMap[d] = b, i.spotShadowMatrix[d] = e.shadow.matrix, v++ } i.spot[d] = t, d++ } else if (e.isRectAreaLight) { const t = n.get(e); t.color.copy(o).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[f] = t, f++ } else if (e.isPointLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity * _), t.distance = e.distance, t.decay = e.decay, e.castShadow) { const t = e.shadow, n = r.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[h] = n, i.pointShadowMap[h] = b, i.pointShadowMatrix[h] = e.shadow.matrix, g++ } i.point[h] = t, h++ } else if (e.isHemisphereLight) { const t = n.get(e); t.skyColor.copy(e.color).multiplyScalar(y * _), t.groundColor.copy(e.groundColor).multiplyScalar(y * _), i.hemi[p] = t, p++ } } f > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = On.LTC_FLOAT_1, i.rectAreaLTC2 = On.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = On.LTC_HALF_1, i.rectAreaLTC2 = On.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = s, i.ambient[1] = l, i.ambient[2] = c; const y = i.hash; y.directionalLength === u && y.pointLength === h && y.spotLength === d && y.rectAreaLength === f && y.hemiLength === p && y.numDirectionalShadows === m && y.numPointShadows === g && y.numSpotShadows === v || (i.directional.length = u, i.spot.length = d, i.rectArea.length = f, i.point.length = h, i.hemi.length = p, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = g, i.spotShadowMatrix.length = v, y.directionalLength = u, y.pointLength = h, y.spotLength = d, y.rectAreaLength = f, y.hemiLength = p, y.numDirectionalShadows = m, y.numPointShadows = g, y.numSpotShadows = v, i.version = Hi++) }, setupView: function (t, e) { let n = 0, r = 0, l = 0, c = 0, u = 0; const h = e.matrixWorldInverse; for (let e = 0, d = t.length; e < d; e++) { const d = t[e]; if (d.isDirectionalLight) { const t = i.directional[n]; t.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(h), n++ } else if (d.isSpotLight) { const t = i.spot[l]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(a), t.direction.transformDirection(h), l++ } else if (d.isRectAreaLight) { const t = i.rectArea[c]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), s.identity(), o.copy(d.matrixWorld), o.premultiply(h), s.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(s), t.halfHeight.applyMatrix4(s), c++ } else if (d.isPointLight) { const t = i.point[r]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), r++ } else if (d.isHemisphereLight) { const t = i.hemi[u]; t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), u++ } } }, state: i } } function qi(t, e) { const n = new ji(t, e), r = [], i = []; return { init: function () { r.length = 0, i.length = 0 }, state: { lightsArray: r, shadowsArray: i, lights: n }, setupLights: function (t) { n.setup(r, t) }, setupLightsView: function (t) { n.setupView(r, t) }, pushLight: function (t) { r.push(t) }, pushShadow: function (t) { i.push(t) } } } function Xi(t, e) { let n = new WeakMap; return { get: function (r, i = 0) { let a; return !1 === n.has(r) ? (a = new qi(t, e), n.set(r, [a])) : i >= n.get(r).length ? (a = new qi(t, e), n.get(r).push(a)) : a = n.get(r)[i], a }, dispose: function () { n = new WeakMap } } } class Yi extends Pe { constructor(t) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t) } copy(t) { return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this } } class Zi extends Pe { constructor(t) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new mt, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t) } copy(t) { return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this } } function Ki(t, e, n) { let r = new Ln; const i = new H, a = new H, o = new ut, s = new Yi({ depthPacking: 3201 }), l = new Zi, u = {}, h = n.maxTextureSize, d = { 0: 1, 1: 0, 2: 2 }, f = new gn({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new H }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p = f.clone(); p.defines.HORIZONTAL_PASS = 1; const m = new je; m.setAttribute("position", new Oe(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const g = new un(m, f), v = this; function _(n, r) { const a = e.update(g); f.defines.VSM_SAMPLES !== n.blurSamples && (f.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, f.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new ht(i.x, i.y)), f.uniforms.shadow_pass.value = n.map.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, a, f, g, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, a, p, g, null) } function y(e, n, r, i, a, o) { let c = null; const h = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial; if (c = void 0 !== h ? h : !0 === r.isPointLight ? l : s, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) { const t = c.uuid, e = n.uuid; let r = u[t]; void 0 === r && (r = {}, u[t] = r); let i = r[e]; void 0 === i && (i = c.clone(), r[e] = i), c = i } return c.visible = n.visible, c.wireframe = n.wireframe, c.side = 3 === o ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], c.alphaMap = n.alphaMap, c.alphaTest = n.alphaTest, c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.displacementMap = n.displacementMap, c.displacementScale = n.displacementScale, c.displacementBias = n.displacementBias, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = i, c.farDistance = a), c } function x(n, i, a, o, s) { if (!1 === n.visible) return; if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || r.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld); const r = e.update(n), i = n.material; if (Array.isArray(i)) { const e = r.groups; for (let l = 0, c = e.length; l < c; l++) { const c = e[l], u = i[c.materialIndex]; if (u && u.visible) { const e = y(n, u, o, a.near, a.far, s); t.renderBufferDirect(a, null, r, e, n, c) } } } else if (i.visible) { const e = y(n, i, o, a.near, a.far, s); t.renderBufferDirect(a, null, r, e, n, null) } } const l = n.children; for (let t = 0, e = l.length; t < e; t++)x(l[t], i, a, o, s) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, n, s) { if (!1 === v.enabled) return; if (!1 === v.autoUpdate && !1 === v.needsUpdate) return; if (0 === e.length) return; const l = t.getRenderTarget(), u = t.getActiveCubeFace(), d = t.getActiveMipmapLevel(), f = t.state; f.setBlending(0), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1); for (let l = 0, u = e.length; l < u; l++) { const u = e[l], d = u.shadow; if (void 0 === d) { console.warn("THREE.WebGLShadowMap:", u, "has no shadow."); continue } if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue; i.copy(d.mapSize); const p = d.getFrameExtents(); if (i.multiply(p), a.copy(d.mapSize), (i.x > h || i.y > h) && (i.x > h && (a.x = Math.floor(h / p.x), i.x = a.x * p.x, d.mapSize.x = a.x), i.y > h && (a.y = Math.floor(h / p.y), i.y = a.y * p.y, d.mapSize.y = a.y)), null === d.map) { const t = 3 !== this.type ? { minFilter: c, magFilter: c } : {}; d.map = new ht(i.x, i.y, t), d.map.texture.name = u.name + ".shadowMap", d.camera.updateProjectionMatrix() } t.setRenderTarget(d.map), t.clear(); const m = d.getViewportCount(); for (let t = 0; t < m; t++) { const e = d.getViewport(t); o.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w), f.viewport(o), d.updateMatrices(u, t), r = d.getFrustum(), x(n, s, d.camera, u, this.type) } !0 !== d.isPointLightShadow && 3 === this.type && _(d, s), d.needsUpdate = !1 } v.needsUpdate = !1, t.setRenderTarget(l, u, d) } } function Ji(e, n, r) { const i = r.isWebGL2, a = new function () { let t = !1; const n = new ut; let r = null; const i = new ut(0, 0, 0, 0); return { setMask: function (n) { r === n || t || (e.colorMask(n, n, n, n), r = n) }, setLocked: function (e) { t = e }, setClear: function (t, r, a, o, s) { !0 === s && (t *= o, r *= o, a *= o), n.set(t, r, a, o), !1 === i.equals(n) && (e.clearColor(t, r, a, o), i.copy(n)) }, reset: function () { t = !1, r = null, i.set(-1, 0, 0, 0) } } }, o = new function () { let t = !1, n = null, r = null, i = null; return { setTest: function (t) { t ? V(2929) : G(2929) }, setMask: function (r) { n === r || t || (e.depthMask(r), n = r) }, setFunc: function (t) { if (r !== t) { if (t) switch (t) { case 0: e.depthFunc(512); break; case 1: e.depthFunc(519); break; case 2: e.depthFunc(513); break; case 3: default: e.depthFunc(515); break; case 4: e.depthFunc(514); break; case 5: e.depthFunc(518); break; case 6: e.depthFunc(516); break; case 7: e.depthFunc(517) } else e.depthFunc(515); r = t } }, setLocked: function (e) { t = e }, setClear: function (t) { i !== t && (e.clearDepth(t), i = t) }, reset: function () { t = !1, n = null, r = null, i = null } } }, s = new function () { let t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, c = null; return { setTest: function (e) { t || (e ? V(2960) : G(2960)) }, setMask: function (r) { n === r || t || (e.stencilMask(r), n = r) }, setFunc: function (t, n, o) { r === t && i === n && a === o || (e.stencilFunc(t, n, o), r = t, i = n, a = o) }, setOp: function (t, n, r) { o === t && s === n && l === r || (e.stencilOp(t, n, r), o = t, s = n, l = r) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, c = null } } }, l = new WeakMap, c = new WeakMap; let u = {}, h = {}, d = new WeakMap, f = [], p = null, m = !1, g = null, v = null, _ = null, y = null, x = null, b = null, M = null, w = !1, S = null, T = null, E = null, A = null, C = null; const L = e.getParameter(35661); let P = !1, R = 0; const D = e.getParameter(7938); -1 !== D.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(D)[1]), P = R >= 1) : -1 !== D.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]), P = R >= 2); let I = null, O = {}; const N = e.getParameter(3088), z = e.getParameter(2978), F = (new ut).fromArray(N), U = (new ut).fromArray(z); function k(t, n, r) { const i = new Uint8Array(4), a = e.createTexture(); e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728); for (let t = 0; t < r; t++)e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, i); return a } const B = {}; function V(t) { !0 !== u[t] && (e.enable(t), u[t] = !0) } function G(t) { !1 !== u[t] && (e.disable(t), u[t] = !1) } B[3553] = k(3553, 3553, 1), B[34067] = k(34067, 34069, 6), a.setClear(0, 0, 0, 1), o.setClear(1), s.setClear(0), V(2929), o.setFunc(3), q(!1), X(1), V(2884), j(0); const H = { [t]: 32774, 101: 32778, 102: 32779 }; if (i) H[103] = 32775, H[104] = 32776; else { const t = n.get("EXT_blend_minmax"); null !== t && (H[103] = t.MIN_EXT, H[104] = t.MAX_EXT) } const W = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; function j(n, r, i, a, o, s, l, c) { if (0 !== n) { if (!1 === m && (V(3042), m = !0), 5 === n) o = o || r, s = s || i, l = l || a, r === v && o === x || (e.blendEquationSeparate(H[r], H[o]), v = r, x = o), i === _ && a === y && s === b && l === M || (e.blendFuncSeparate(W[i], W[a], W[s], W[l]), _ = i, y = a, b = s, M = l), g = n, w = null; else if (n !== g || c !== w) { if (v === t && x === t || (e.blendEquation(32774), v = t, x = t), c) switch (n) { case 1: e.blendFuncSeparate(1, 771, 1, 771); break; case 2: e.blendFunc(1, 1); break; case 3: e.blendFuncSeparate(0, 769, 0, 1); break; case 4: e.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", n) } else switch (n) { case 1: e.blendFuncSeparate(770, 771, 1, 771); break; case 2: e.blendFunc(770, 1); break; case 3: e.blendFuncSeparate(0, 769, 0, 1); break; case 4: e.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", n) }_ = null, y = null, b = null, M = null, g = n, w = c } } else !0 === m && (G(3042), m = !1) } function q(t) { S !== t && (t ? e.frontFace(2304) : e.frontFace(2305), S = t) } function X(t) { 0 !== t ? (V(2884), t !== T && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : G(2884), T = t } function Y(t, n, r) { t ? (V(32823), A === n && C === r || (e.polygonOffset(n, r), A = n, C = r)) : G(32823) } function Z(t) { void 0 === t && (t = 33984 + L - 1), I !== t && (e.activeTexture(t), I = t) } return { buffers: { color: a, depth: o, stencil: s }, enable: V, disable: G, bindFramebuffer: function (t, n) { return h[t] !== n && (e.bindFramebuffer(t, n), h[t] = n, i && (36009 === t && (h[36160] = n), 36160 === t && (h[36009] = n)), !0) }, drawBuffers: function (t, i) { let a = f, o = !1; if (t) if (a = d.get(i), void 0 === a && (a = [], d.set(i, a)), t.isWebGLMultipleRenderTargets) { const e = t.texture; if (a.length !== e.length || 36064 !== a[0]) { for (let t = 0, n = e.length; t < n; t++)a[t] = 36064 + t; a.length = e.length, o = !0 } } else 36064 !== a[0] && (a[0] = 36064, o = !0); else 1029 !== a[0] && (a[0] = 1029, o = !0); o && (r.isWebGL2 ? e.drawBuffers(a) : n.get("WEBGL_draw_buffers").drawBuffersWEBGL(a)) }, useProgram: function (t) { return p !== t && (e.useProgram(t), p = t, !0) }, setBlending: j, setMaterial: function (t, e) { 2 === t.side ? G(2884) : V(2884); let n = 1 === t.side; e && (n = !n), q(n), 1 === t.blending && !1 === t.transparent ? j(0) : j(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), a.setMask(t.colorWrite); const r = t.stencilWrite; s.setTest(r), r && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Y(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? V(32926) : G(32926) }, setFlipSided: q, setCullFace: X, setLineWidth: function (t) { t !== E && (P && e.lineWidth(t), E = t) }, setPolygonOffset: Y, setScissorTest: function (t) { t ? V(3089) : G(3089) }, activeTexture: Z, bindTexture: function (t, n) { null === I && Z(); let r = O[I]; void 0 === r && (r = { type: void 0, texture: void 0 }, O[I] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || B[t]), r.type = t, r.texture = n) }, unbindTexture: function () { const t = O[I]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, updateUBOMapping: function (t, n) { let r = c.get(n); void 0 === r && (r = new WeakMap, c.set(n, r)); let i = r.get(t); void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i)) }, uniformBlockBinding: function (t, n) { const r = c.get(n).get(t); l.get(t) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), l.set(t, r)) }, texStorage2D: function () { try { e.texStorage2D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texStorage3D: function () { try { e.texStorage3D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texSubImage2D: function () { try { e.texSubImage2D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texSubImage3D: function () { try { e.texSubImage3D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, compressedTexSubImage2D: function () { try { e.compressedTexSubImage2D.apply(e, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (t) { !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), F.copy(t)) }, viewport: function (t) { !1 === U.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), U.copy(t)) }, reset: function () { e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === i && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), u = {}, I = null, O = {}, h = {}, d = new WeakMap, f = [], p = null, m = !1, g = null, v = null, _ = null, y = null, x = null, b = null, M = null, w = !1, S = null, T = null, E = null, A = null, C = null, F.set(0, 0, e.canvas.width, e.canvas.height), U.set(0, 0, e.canvas.width, e.canvas.height), a.reset(), o.reset(), s.reset() } } } function Qi(t, e, n, r, i, a, x) { const b = i.isWebGL2, M = i.maxTextures, w = i.maxCubemapSize, S = i.maxTextureSize, T = i.maxSamples, E = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, L = /OculusBrowser/g.test(navigator.userAgent), P = new WeakMap; let R; const D = new WeakMap; let O = !1; try { O = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) { } function N(t, e) { return O ? new OffscreenCanvas(t, e) : q("canvas") } function z(t, e, n, r) { let i = 1; if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const r = e ? G : Math.floor, a = r(i * t.width), o = r(i * t.height); void 0 === R && (R = N(a, o)); const s = n ? N(a, o) : R; return s.width = a, s.height = o, s.getContext("2d").drawImage(t, 0, 0, a, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + o + ")."), s } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function F(t) { return V(t.width) && V(t.height) } function U(t, e) { return t.generateMipmaps && e && t.minFilter !== c && t.minFilter !== u } function k(e) { t.generateMipmap(e) } function B(n, r, i, a, o = !1) { if (!1 === b) return r; if (null !== n) { if (void 0 !== t[n]) return t[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let s = r; return 6403 === r && (5126 === i && (s = 33326), 5131 === i && (s = 33325), 5121 === i && (s = 33321)), 33319 === r && (5126 === i && (s = 33328), 5131 === i && (s = 33327), 5121 === i && (s = 33323)), 6408 === r && (5126 === i && (s = 34836), 5131 === i && (s = 34842), 5121 === i && (s = a === C && !1 === o ? 35907 : 32856), 32819 === i && (s = 32854), 32820 === i && (s = 32855)), 33325 !== s && 33326 !== s && 33327 !== s && 33328 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s } function H(t, e, n) { return !0 === U(t, n) || t.isFramebufferTexture && t.minFilter !== c && t.minFilter !== u ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1 } function W(t) { return t === c || 1004 === t || 1005 === t ? 9728 : 9729 } function j(t) { const e = t.target; e.removeEventListener("dispose", j), function (t) { const e = r.get(t); if (void 0 === e.__webglInit) return; const n = t.source, i = D.get(n); if (i) { const r = i[e.__cacheKey]; r.usedTimes--, 0 === r.usedTimes && Y(t), 0 === Object.keys(i).length && D.delete(n) } r.remove(t) }(e), e.isVideoTexture && P.delete(e) } function X(e) { const n = e.target; n.removeEventListener("dispose", X), function (e) { const n = e.texture, i = r.get(e), a = r.get(n); if (void 0 !== a.__webglTexture && (t.deleteTexture(a.__webglTexture), x.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)t.deleteFramebuffer(i.__webglFramebuffer[e]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[e]); else { if (t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && t.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer) for (let e = 0; e < i.__webglColorRenderbuffer.length; e++)i.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(i.__webglColorRenderbuffer[e]); i.__webglDepthRenderbuffer && t.deleteRenderbuffer(i.__webglDepthRenderbuffer) } if (e.isWebGLMultipleRenderTargets) for (let e = 0, i = n.length; e < i; e++) { const i = r.get(n[e]); i.__webglTexture && (t.deleteTexture(i.__webglTexture), x.memory.textures--), r.remove(n[e]) } r.remove(n), r.remove(e) }(n) } function Y(e) { const n = r.get(e); t.deleteTexture(n.__webglTexture); const i = e.source; delete D.get(i)[n.__cacheKey], x.memory.textures-- } let Z = 0; function K(t, e) { const i = r.get(t); if (t.isVideoTexture && function (t) { const e = x.render.frame; P.get(t) !== e && (P.set(t, e), t.update()) }(t), !1 === t.isRenderTargetTexture && t.version > 0 && i.__version !== t.version) { const n = t.image; if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else { if (!1 !== n.complete) return void et(i, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture) } const J = { [o]: 10497, [s]: 33071, [l]: 33648 }, Q = { [c]: 9728, 1004: 9984, 1005: 9986, [u]: 9729, 1007: 9985, [h]: 9987 }; function $(n, a, o) { if (o ? (t.texParameteri(n, 10242, J[a.wrapS]), t.texParameteri(n, 10243, J[a.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, J[a.wrapR]), t.texParameteri(n, 10240, Q[a.magFilter]), t.texParameteri(n, 10241, Q[a.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), a.wrapS === s && a.wrapT === s || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, W(a.magFilter)), t.texParameteri(n, 10241, W(a.minFilter)), a.minFilter !== c && a.minFilter !== u && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) { const o = e.get("EXT_texture_filter_anisotropic"); if (a.type === p && !1 === e.has("OES_texture_float_linear")) return; if (!1 === b && a.type === m && !1 === e.has("OES_texture_half_float_linear")) return; (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy) } } function tt(e, n) { let r = !1; void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", j)); const i = n.source; let a = D.get(i); void 0 === a && (a = {}, D.set(i, a)); const o = function (t) { const e = []; return e.push(t.wrapS), e.push(t.wrapT), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.encoding), e.join() }(n); if (o !== e.__cacheKey) { void 0 === a[o] && (a[o] = { texture: t.createTexture(), usedTimes: 0 }, x.memory.textures++, r = !0), a[o].usedTimes++; const i = a[e.__cacheKey]; void 0 !== i && (a[e.__cacheKey].usedTimes--, 0 === i.usedTimes && Y(n)), e.__cacheKey = o, e.__webglTexture = a[o].texture } return r } function et(e, r, i) { let o = 3553; r.isDataArrayTexture && (o = 35866), r.isData3DTexture && (o = 32879); const l = tt(e, r), h = r.source; if (n.activeTexture(33984 + i), n.bindTexture(o, e.__webglTexture), h.version !== h.__currentVersion || !0 === l) { t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0); const e = function (t) { return !b && (t.wrapS !== s || t.wrapT !== s || t.minFilter !== c && t.minFilter !== u) }(r) && !1 === F(r.image); let i = z(r.image, e, !1, S); i = lt(r, i); const d = F(i) || b, m = a.convert(r.format, r.encoding); let x, M = a.convert(r.type), w = B(r.internalFormat, m, M, r.encoding, r.isVideoTexture); $(o, r, d); const T = r.mipmaps, E = b && !0 !== r.isVideoTexture, A = void 0 === h.__currentVersion || !0 === l, C = H(r, i, d); if (r.isDepthTexture) w = 6402, b ? w = r.type === p ? 36012 : r.type === f ? 33190 : r.type === g ? 35056 : 33189 : r.type === p && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === _ && 6402 === w && 1012 !== r.type && r.type !== f && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = f, M = a.convert(r.type)), r.format === y && 6402 === w && (w = 34041, r.type !== g && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = g, M = a.convert(r.type))), A && (E ? n.texStorage2D(3553, 1, w, i.width, i.height) : n.texImage2D(3553, 0, w, i.width, i.height, 0, m, M, null)); else if (r.isDataTexture) if (T.length > 0 && d) { E && A && n.texStorage2D(3553, C, w, T[0].width, T[0].height); for (let t = 0, e = T.length; t < e; t++)x = T[t], E ? n.texSubImage2D(3553, t, 0, 0, x.width, x.height, m, M, x.data) : n.texImage2D(3553, t, w, x.width, x.height, 0, m, M, x.data); r.generateMipmaps = !1 } else E ? (A && n.texStorage2D(3553, C, w, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, i.width, i.height, m, M, i.data)) : n.texImage2D(3553, 0, w, i.width, i.height, 0, m, M, i.data); else if (r.isCompressedTexture) { E && A && n.texStorage2D(3553, C, w, T[0].width, T[0].height); for (let t = 0, e = T.length; t < e; t++)x = T[t], r.format !== v ? null !== m ? E ? n.compressedTexSubImage2D(3553, t, 0, 0, x.width, x.height, m, x.data) : n.compressedTexImage2D(3553, t, w, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : E ? n.texSubImage2D(3553, t, 0, 0, x.width, x.height, m, M, x.data) : n.texImage2D(3553, t, w, x.width, x.height, 0, m, M, x.data) } else if (r.isDataArrayTexture) E ? (A && n.texStorage3D(35866, C, w, i.width, i.height, i.depth), n.texSubImage3D(35866, 0, 0, 0, 0, i.width, i.height, i.depth, m, M, i.data)) : n.texImage3D(35866, 0, w, i.width, i.height, i.depth, 0, m, M, i.data); else if (r.isData3DTexture) E ? (A && n.texStorage3D(32879, C, w, i.width, i.height, i.depth), n.texSubImage3D(32879, 0, 0, 0, 0, i.width, i.height, i.depth, m, M, i.data)) : n.texImage3D(32879, 0, w, i.width, i.height, i.depth, 0, m, M, i.data); else if (r.isFramebufferTexture) { if (A) if (E) n.texStorage2D(3553, C, w, i.width, i.height); else { let t = i.width, e = i.height; for (let r = 0; r < C; r++)n.texImage2D(3553, r, w, t, e, 0, m, M, null), t >>= 1, e >>= 1 } } else if (T.length > 0 && d) { E && A && n.texStorage2D(3553, C, w, T[0].width, T[0].height); for (let t = 0, e = T.length; t < e; t++)x = T[t], E ? n.texSubImage2D(3553, t, 0, 0, m, M, x) : n.texImage2D(3553, t, w, m, M, x); r.generateMipmaps = !1 } else E ? (A && n.texStorage2D(3553, C, w, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, m, M, i)) : n.texImage2D(3553, 0, w, m, M, i); U(r, d) && k(o), h.__currentVersion = h.version, r.onUpdate && r.onUpdate(r) } e.__version = r.version } function nt(e, i, o, s, l) { const c = a.convert(o.format, o.encoding), u = a.convert(o.type), h = B(o.internalFormat, c, u, o.encoding); r.get(i).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, i.width, i.height, i.depth, 0, c, u, null) : n.texImage2D(l, 0, h, i.width, i.height, 0, c, u, null)), n.bindFramebuffer(36160, e), st(i) ? E.framebufferTexture2DMultisampleEXT(36160, s, l, r.get(o).__webglTexture, 0, ot(i)) : t.framebufferTexture2D(36160, s, l, r.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null) } function rt(e, n, r) { if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) { let i = 33189; if (r || st(n)) { const e = n.depthTexture; e && e.isDepthTexture && (e.type === p ? i = 36012 : e.type === f && (i = 33190)); const r = ot(n); st(n) ? E.renderbufferStorageMultisampleEXT(36161, r, i, n.width, n.height) : t.renderbufferStorageMultisample(36161, r, i, n.width, n.height) } else t.renderbufferStorage(36161, i, n.width, n.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (n.depthBuffer && n.stencilBuffer) { const i = ot(n); r && !1 === st(n) ? t.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height) : st(n) ? E.renderbufferStorageMultisampleEXT(36161, i, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture]; for (let i = 0; i < e.length; i++) { const o = e[i], s = a.convert(o.format, o.encoding), l = a.convert(o.type), c = B(o.internalFormat, s, l, o.encoding), u = ot(n); r && !1 === st(n) ? t.renderbufferStorageMultisample(36161, u, c, n.width, n.height) : st(n) ? E.renderbufferStorageMultisampleEXT(36161, u, c, n.width, n.height) : t.renderbufferStorage(36161, c, n.width, n.height) } } t.bindRenderbuffer(36161, null) } function it(e) { const i = r.get(e), a = !0 === e.isWebGLCubeRenderTarget; if (e.depthTexture && !i.__autoAllocateDepthBuffer) { if (a) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, i) { if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), K(i.depthTexture, 0); const a = r.get(i.depthTexture).__webglTexture, o = ot(i); if (i.depthTexture.format === _) st(i) ? E.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, a, 0, o) : t.framebufferTexture2D(36160, 36096, 3553, a, 0); else { if (i.depthTexture.format !== y) throw new Error("Unknown depthTexture format"); st(i) ? E.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, a, 0, o) : t.framebufferTexture2D(36160, 33306, 3553, a, 0) } }(i.__webglFramebuffer, e) } else if (a) { i.__webglDepthbuffer = []; for (let r = 0; r < 6; r++)n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), rt(i.__webglDepthbuffer[r], e, !1) } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), rt(i.__webglDepthbuffer, e, !1); n.bindFramebuffer(36160, null) } function ot(t) { return Math.min(T, t.samples) } function st(t) { const n = r.get(t); return b && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture } function lt(t, n) { const r = t.encoding, i = t.format, a = t.type; return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === I || r !== A && (r === C ? !1 === b ? !0 === e.has("EXT_sRGB") && i === v ? (t.format = I, t.minFilter = u, t.generateMipmaps = !1) : n = at.sRGBToLinear(n) : i === v && a === d || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", r)), n } this.allocateTextureUnit = function () { const t = Z; return t >= M && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + M), Z += 1, t }, this.resetTextureUnits = function () { Z = 0 }, this.setTexture2D = K, this.setTexture2DArray = function (t, e) { const i = r.get(t); t.version > 0 && i.__version !== t.version ? et(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture)) }, this.setTexture3D = function (t, e) { const i = r.get(t); t.version > 0 && i.__version !== t.version ? et(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture)) }, this.setTextureCube = function (e, i) { const o = r.get(e); e.version > 0 && o.__version !== e.version ? function (e, r, i) { if (6 !== r.image.length) return; const o = tt(e, r), s = r.source; if (n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), s.version !== s.__currentVersion || !0 === o) { t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0); const e = r.isCompressedTexture || r.image[0].isCompressedTexture, i = r.image[0] && r.image[0].isDataTexture, l = []; for (let t = 0; t < 6; t++)l[t] = e || i ? i ? r.image[t].image : r.image[t] : z(r.image[t], !1, !0, w), l[t] = lt(r, l[t]); const c = l[0], u = F(c) || b, h = a.convert(r.format, r.encoding), d = a.convert(r.type), f = B(r.internalFormat, h, d, r.encoding), p = b && !0 !== r.isVideoTexture, m = void 0 === s.__currentVersion || !0 === o; let g, _ = H(r, c, u); if ($(34067, r, u), e) { p && m && n.texStorage2D(34067, _, f, c.width, c.height); for (let t = 0; t < 6; t++) { g = l[t].mipmaps; for (let e = 0; e < g.length; e++) { const i = g[e]; r.format !== v ? null !== h ? p ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, i.width, i.height, h, i.data) : n.compressedTexImage2D(34069 + t, e, f, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : p ? n.texSubImage2D(34069 + t, e, 0, 0, i.width, i.height, h, d, i.data) : n.texImage2D(34069 + t, e, f, i.width, i.height, 0, h, d, i.data) } } } else { g = r.mipmaps, p && m && (g.length > 0 && _++, n.texStorage2D(34067, _, f, l[0].width, l[0].height)); for (let t = 0; t < 6; t++)if (i) { p ? n.texSubImage2D(34069 + t, 0, 0, 0, l[t].width, l[t].height, h, d, l[t].data) : n.texImage2D(34069 + t, 0, f, l[t].width, l[t].height, 0, h, d, l[t].data); for (let e = 0; e < g.length; e++) { const r = g[e].image[t].image; p ? n.texSubImage2D(34069 + t, e + 1, 0, 0, r.width, r.height, h, d, r.data) : n.texImage2D(34069 + t, e + 1, f, r.width, r.height, 0, h, d, r.data) } } else { p ? n.texSubImage2D(34069 + t, 0, 0, 0, h, d, l[t]) : n.texImage2D(34069 + t, 0, f, h, d, l[t]); for (let e = 0; e < g.length; e++) { const r = g[e]; p ? n.texSubImage2D(34069 + t, e + 1, 0, 0, h, d, r.image[t]) : n.texImage2D(34069 + t, e + 1, f, h, d, r.image[t]) } } } U(r, u) && k(34067), s.__currentVersion = s.version, r.onUpdate && r.onUpdate(r) } e.__version = r.version }(o, e, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture)) }, this.rebindTextures = function (t, e, n) { const i = r.get(t); void 0 !== e && nt(i.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && it(t) }, this.setupRenderTarget = function (e) { const o = e.texture, s = r.get(e), l = r.get(o); e.addEventListener("dispose", X), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === l.__webglTexture && (l.__webglTexture = t.createTexture()), l.__version = o.version, x.memory.textures++); const c = !0 === e.isWebGLCubeRenderTarget, u = !0 === e.isWebGLMultipleRenderTargets, h = F(e) || b; if (c) { s.__webglFramebuffer = []; for (let e = 0; e < 6; e++)s.__webglFramebuffer[e] = t.createFramebuffer() } else { if (s.__webglFramebuffer = t.createFramebuffer(), u) if (i.drawBuffers) { const n = e.texture; for (let e = 0, i = n.length; e < i; e++) { const i = r.get(n[e]); void 0 === i.__webglTexture && (i.__webglTexture = t.createTexture(), x.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (b && e.samples > 0 && !1 === st(e)) { const r = u ? o : [o]; s.__webglMultisampledFramebuffer = t.createFramebuffer(), s.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, s.__webglMultisampledFramebuffer); for (let n = 0; n < r.length; n++) { const i = r[n]; s.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(36161, s.__webglColorRenderbuffer[n]); const o = a.convert(i.format, i.encoding), l = a.convert(i.type), c = B(i.internalFormat, o, l, i.encoding), u = ot(e); t.renderbufferStorageMultisample(36161, u, c, e.width, e.height), t.framebufferRenderbuffer(36160, 36064 + n, 36161, s.__webglColorRenderbuffer[n]) } t.bindRenderbuffer(36161, null), e.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(), rt(s.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null) } } if (c) { n.bindTexture(34067, l.__webglTexture), $(34067, o, h); for (let t = 0; t < 6; t++)nt(s.__webglFramebuffer[t], e, o, 36064, 34069 + t); U(o, h) && k(34067), n.unbindTexture() } else if (u) { const t = e.texture; for (let i = 0, a = t.length; i < a; i++) { const a = t[i], o = r.get(a); n.bindTexture(3553, o.__webglTexture), $(3553, a, h), nt(s.__webglFramebuffer, e, a, 36064 + i, 3553), U(a, h) && k(3553) } n.unbindTexture() } else { let t = 3553; (e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (b ? t = e.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(t, l.__webglTexture), $(t, o, h), nt(s.__webglFramebuffer, e, o, 36064, t), U(o, h) && k(t), n.unbindTexture() } e.depthBuffer && it(e) }, this.updateRenderTargetMipmap = function (t) { const e = F(t) || b, i = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]; for (let a = 0, o = i.length; a < o; a++) { const o = i[a]; if (U(o, e)) { const e = t.isWebGLCubeRenderTarget ? 34067 : 3553, i = r.get(o).__webglTexture; n.bindTexture(e, i), k(e), n.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (e) { if (b && e.samples > 0 && !1 === st(e)) { const i = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture], a = e.width, o = e.height; let s = 16384; const l = [], c = e.stencilBuffer ? 33306 : 36096, u = r.get(e), h = !0 === e.isWebGLMultipleRenderTargets; if (h) for (let e = 0; e < i.length; e++)n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + e, 36161, null), n.bindFramebuffer(36160, u.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + e, 3553, null, 0); n.bindFramebuffer(36008, u.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, u.__webglFramebuffer); for (let n = 0; n < i.length; n++) { l.push(36064 + n), e.depthBuffer && l.push(c); const d = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues; if (!1 === d && (e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024)), h && t.framebufferRenderbuffer(36008, 36064, 36161, u.__webglColorRenderbuffer[n]), !0 === d && (t.invalidateFramebuffer(36008, [c]), t.invalidateFramebuffer(36009, [c])), h) { const e = r.get(i[n]).__webglTexture; t.framebufferTexture2D(36009, 36064, 3553, e, 0) } t.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, 9728), L && t.invalidateFramebuffer(36008, l) } if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), h) for (let e = 0; e < i.length; e++) { n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + e, 36161, u.__webglColorRenderbuffer[e]); const a = r.get(i[e]).__webglTexture; n.bindFramebuffer(36160, u.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + e, 3553, a, 0) } n.bindFramebuffer(36009, u.__webglMultisampledFramebuffer) } }, this.setupDepthRenderbuffer = it, this.setupFrameBufferTexture = nt, this.useMultisampledRTT = st } function $i(t, e, n) { const r = n.isWebGL2; return { convert: function (n, i = null) { let a; if (n === d) return 5121; if (1017 === n) return 32819; if (1018 === n) return 32820; if (1010 === n) return 5120; if (1011 === n) return 5122; if (1012 === n) return 5123; if (1013 === n) return 5124; if (n === f) return 5125; if (n === p) return 5126; if (n === m) return r ? 5131 : (a = e.get("OES_texture_half_float"), null !== a ? a.HALF_FLOAT_OES : null); if (1021 === n) return 6406; if (n === v) return 6408; if (1024 === n) return 6409; if (1025 === n) return 6410; if (n === _) return 6402; if (n === y) return 34041; if (1028 === n) return 6403; if (1022 === n) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408; if (n === I) return a = e.get("EXT_sRGB"), null !== a ? a.SRGB_ALPHA_EXT : null; if (1029 === n) return 36244; if (1030 === n) return 33319; if (1031 === n) return 33320; if (1033 === n) return 36249; if (n === x || n === b || n === M || n === w) if (i === C) { if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === a) return null; if (n === x) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (n === b) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (n === M) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (n === w) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (a = e.get("WEBGL_compressed_texture_s3tc"), null === a) return null; if (n === x) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (n === b) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (n === M) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (n === w) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === n || 35841 === n || 35842 === n || 35843 === n) { if (a = e.get("WEBGL_compressed_texture_pvrtc"), null === a) return null; if (35840 === n) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === n) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === n) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === n) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === n) return a = e.get("WEBGL_compressed_texture_etc1"), null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null; if (37492 === n || 37496 === n) { if (a = e.get("WEBGL_compressed_texture_etc"), null === a) return null; if (37492 === n) return i === C ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (37496 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) { if (a = e.get("WEBGL_compressed_texture_astc"), null === a) return null; if (37808 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (37809 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (37810 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (37811 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (37812 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (37813 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (37814 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (37815 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (37816 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (37817 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (37818 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (37819 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (37820 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (37821 === n) return i === C ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } if (36492 === n) { if (a = e.get("EXT_texture_compression_bptc"), null === a) return null; if (36492 === n) return i === C ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT } return n === g ? r ? 34042 : (a = e.get("WEBGL_depth_texture"), null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null } } } class ta extends _n { constructor(t = []) { super(), this.isArrayCamera = !0, this.cameras = t } } class ea extends ve { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const na = { type: "move" }; class ra { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new ea, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new ea, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new mt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new mt), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new ea, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new mt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new mt), this._grip } dispatchEvent(t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this } disconnect(t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(t, e, n) { let r = null, i = null, a = null; const o = this._targetRay, s = this._grip, l = this._hand; if (t && "visible-blurred" !== e.session.visibilityState) { if (l && t.hand) { a = !0; for (const r of t.hand.values()) { const t = e.getJointPose(r, n); if (void 0 === l.joints[r.jointName]) { const t = new ea; t.matrixAutoUpdate = !1, t.visible = !1, l.joints[r.jointName] = t, l.add(t) } const i = l.joints[r.jointName]; null !== t && (i.matrix.fromArray(t.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = t.radius), i.visible = null !== t } const r = l.joints["index-finger-tip"], i = l.joints["thumb-tip"], o = r.position.distanceTo(i.position), s = .02, c = .005; l.inputState.pinching && o > s + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && o <= s - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } else null !== s && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1)); null !== o && (r = e.getPose(t.targetRaySpace, n), null === r && null !== i && (r = i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(na))) } return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== a), this } } class ia extends ct { constructor(t, e, n, r, i, a, o, s, l, u) { if ((u = void 0 !== u ? u : _) !== _ && u !== y) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && u === _ && (n = f), void 0 === n && u === y && (n = g), super(null, r, i, a, o, s, u, n, l), this.isDepthTexture = !0, this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : c, this.minFilter = void 0 !== s ? s : c, this.flipY = !1, this.generateMipmaps = !1 } } class aa extends O { constructor(t, e) { super(); const n = this; let r = null, i = 1, a = null, o = "local-floor", s = null, l = null, c = null, u = null, h = null, p = null; const m = e.getContextAttributes(); let x = null, b = null; const M = [], w = [], S = new _n; S.layers.enable(1), S.viewport = new ut; const T = new _n; T.layers.enable(2), T.viewport = new ut; const E = [S, T], A = new ta; A.layers.enable(1), A.layers.enable(2); let C = null, L = null; function P(t) { const e = w.indexOf(t.inputSource); if (-1 === e) return; const n = M[e]; void 0 !== n && n.dispatchEvent({ type: t.type, data: t.inputSource }) } function R() { r.removeEventListener("select", P), r.removeEventListener("selectstart", P), r.removeEventListener("selectend", P), r.removeEventListener("squeeze", P), r.removeEventListener("squeezestart", P), r.removeEventListener("squeezeend", P), r.removeEventListener("end", R), r.removeEventListener("inputsourceschange", D); for (let t = 0; t < M.length; t++) { const e = w[t]; null !== e && (w[t] = null, M[t].disconnect(e)) } C = null, L = null, t.setRenderTarget(x), h = null, u = null, c = null, r = null, b = null, F.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function D(t) { for (let e = 0; e < t.removed.length; e++) { const n = t.removed[e], r = w.indexOf(n); r >= 0 && (w[r] = null, M[r].dispatchEvent({ type: "disconnected", data: n })) } for (let e = 0; e < t.added.length; e++) { const n = t.added[e]; let r = w.indexOf(n); if (-1 === r) { for (let t = 0; t < M.length; t++) { if (t >= w.length) { w.push(n), r = t; break } if (null === w[t]) { w[t] = n, r = t; break } } if (-1 === r) break } const i = M[r]; i && i.dispatchEvent({ type: "connected", data: n }) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) { let e = M[t]; return void 0 === e && (e = new ra, M[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function (t) { let e = M[t]; return void 0 === e && (e = new ra, M[t] = e), e.getGripSpace() }, this.getHand = function (t) { let e = M[t]; return void 0 === e && (e = new ra, M[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function (t) { i = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (t) { o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return s || a }, this.setReferenceSpace = function (t) { s = t }, this.getBaseLayer = function () { return null !== u ? u : h }, this.getBinding = function () { return c }, this.getFrame = function () { return p }, this.getSession = function () { return r }, this.setSession = async function (l) { if (r = l, null !== r) { if (x = t.getRenderTarget(), r.addEventListener("select", P), r.addEventListener("selectstart", P), r.addEventListener("selectend", P), r.addEventListener("squeeze", P), r.addEventListener("squeezestart", P), r.addEventListener("squeezeend", P), r.addEventListener("end", R), r.addEventListener("inputsourceschange", D), !0 !== m.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers || !1 === t.capabilities.isWebGL2) { const n = { antialias: void 0 !== r.renderState.layers || m.antialias, alpha: m.alpha, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: i }; h = new XRWebGLLayer(r, e, n), r.updateRenderState({ baseLayer: h }), b = new ht(h.framebufferWidth, h.framebufferHeight, { format: v, type: d, encoding: t.outputEncoding }) } else { let n = null, a = null, o = null; m.depth && (o = m.stencil ? 35056 : 33190, n = m.stencil ? y : _, a = m.stencil ? g : f); const s = { colorFormat: 32856, depthFormat: o, scaleFactor: i }; c = new XRWebGLBinding(r, e), u = c.createProjectionLayer(s), r.updateRenderState({ layers: [u] }), b = new ht(u.textureWidth, u.textureHeight, { format: v, type: d, depthTexture: new ia(u.textureWidth, u.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, n), stencilBuffer: m.stencil, encoding: t.outputEncoding, samples: m.antialias ? 4 : 0 }), t.properties.get(b).__ignoreDepthValues = u.ignoreDepthValues } b.isXRRenderTarget = !0, this.setFoveation(1), s = null, a = await r.requestReferenceSpace(o), F.setContext(r), F.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; const I = new mt, O = new mt; function N(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert() } this.updateCamera = function (t) { if (null === r) return; A.near = T.near = S.near = t.near, A.far = T.far = S.far = t.far, C === A.near && L === A.far || (r.updateRenderState({ depthNear: A.near, depthFar: A.far }), C = A.near, L = A.far); const e = t.parent, n = A.cameras; N(A, e); for (let t = 0; t < n.length; t++)N(n[t], e); A.matrixWorld.decompose(A.position, A.quaternion, A.scale), t.position.copy(A.position), t.quaternion.copy(A.quaternion), t.scale.copy(A.scale), t.matrix.copy(A.matrix), t.matrixWorld.copy(A.matrixWorld); const i = t.children; for (let t = 0, e = i.length; t < e; t++)i[t].updateMatrixWorld(!0); 2 === n.length ? function (t, e, n) { I.setFromMatrixPosition(e.matrixWorld), O.setFromMatrixPosition(n.matrixWorld); const r = I.distanceTo(O), i = e.projectionMatrix.elements, a = n.projectionMatrix.elements, o = i[14] / (i[10] - 1), s = i[14] / (i[10] + 1), l = (i[9] + 1) / i[5], c = (i[9] - 1) / i[5], u = (i[8] - 1) / i[0], h = (a[8] + 1) / a[0], d = o * u, f = o * h, p = r / (-u + h), m = p * -u; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(p), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert(); const g = o + p, v = s + p, _ = d - m, y = f + (r - m), x = l * s / v * g, b = c * s / v * g; t.projectionMatrix.makePerspective(_, y, x, b, g, v) }(A, S, T) : A.projectionMatrix.copy(S.projectionMatrix) }, this.getCamera = function () { return A }, this.getFoveation = function () { return null !== u ? u.fixedFoveation : null !== h ? h.fixedFoveation : void 0 }, this.setFoveation = function (t) { null !== u && (u.fixedFoveation = t), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = t) }; let z = null; const F = new Pn; F.setAnimationLoop((function (e, n) { if (l = n.getViewerPose(s || a), p = n, null !== l) { const e = l.views; null !== h && (t.setRenderTargetFramebuffer(b, h.framebuffer), t.setRenderTarget(b)); let n = !1; e.length !== A.cameras.length && (A.cameras.length = 0, n = !0); for (let r = 0; r < e.length; r++) { const i = e[r]; let a = null; if (null !== h) a = h.getViewport(i); else { const e = c.getViewSubImage(u, i); a = e.viewport, 0 === r && (t.setRenderTargetTextures(b, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(b)) } let o = E[r]; void 0 === o && (o = new _n, o.layers.enable(r), o.viewport = new ut, E[r] = o), o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === r && A.matrix.copy(o.matrix), !0 === n && A.cameras.push(o) } } for (let t = 0; t < M.length; t++) { const e = w[t], r = M[t]; null !== e && void 0 !== r && r.update(e, n, s || a) } z && z(e, n), p = null })), this.setAnimationLoop = function (t) { z = t }, this.dispose = function () { } } } function oa(t, e) { function n(n, r) { n.opacity.value = r.opacity, r.color && n.diffuse.value.copy(r.color), r.emissive && n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (n.map.value = r.map), r.alphaMap && (n.alphaMap.value = r.alphaMap), r.bumpMap && (n.bumpMap.value = r.bumpMap, n.bumpScale.value = r.bumpScale, 1 === r.side && (n.bumpScale.value *= -1)), r.displacementMap && (n.displacementMap.value = r.displacementMap, n.displacementScale.value = r.displacementScale, n.displacementBias.value = r.displacementBias), r.emissiveMap && (n.emissiveMap.value = r.emissiveMap), r.normalMap && (n.normalMap.value = r.normalMap, n.normalScale.value.copy(r.normalScale), 1 === r.side && n.normalScale.value.negate()), r.specularMap && (n.specularMap.value = r.specularMap), r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest); const i = e.get(r).envMap; if (i && (n.envMap.value = i, n.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = r.reflectivity, n.ior.value = r.ior, n.refractionRatio.value = r.refractionRatio), r.lightMap) { n.lightMap.value = r.lightMap; const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1; n.lightMapIntensity.value = r.lightMapIntensity * e } let a, o; r.aoMap && (n.aoMap.value = r.aoMap, n.aoMapIntensity.value = r.aoMapIntensity), r.map ? a = r.map : r.specularMap ? a = r.specularMap : r.displacementMap ? a = r.displacementMap : r.normalMap ? a = r.normalMap : r.bumpMap ? a = r.bumpMap : r.roughnessMap ? a = r.roughnessMap : r.metalnessMap ? a = r.metalnessMap : r.alphaMap ? a = r.alphaMap : r.emissiveMap ? a = r.emissiveMap : r.clearcoatMap ? a = r.clearcoatMap : r.clearcoatNormalMap ? a = r.clearcoatNormalMap : r.clearcoatRoughnessMap ? a = r.clearcoatRoughnessMap : r.iridescenceMap ? a = r.iridescenceMap : r.iridescenceThicknessMap ? a = r.iridescenceThicknessMap : r.specularIntensityMap ? a = r.specularIntensityMap : r.specularColorMap ? a = r.specularColorMap : r.transmissionMap ? a = r.transmissionMap : r.thicknessMap ? a = r.thicknessMap : r.sheenColorMap ? a = r.sheenColorMap : r.sheenRoughnessMap && (a = r.sheenRoughnessMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), n.uvTransform.value.copy(a.matrix)), r.aoMap ? o = r.aoMap : r.lightMap && (o = r.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), n.uv2Transform.value.copy(o.matrix)) } return { refreshFogUniforms: function (t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }, refreshMaterialUniforms: function (t, r, i, a, o) { r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(t, r) : r.isMeshToonMaterial ? (n(t, r), function (t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap) }(t, r)) : r.isMeshPhongMaterial ? (n(t, r), function (t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4) }(t, r)) : r.isMeshStandardMaterial ? (n(t, r), function (t, n) { t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity) }(t, r), r.isMeshPhysicalMaterial && function (t, e, n) { t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate())), e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap)), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap) }(t, r, o)) : r.isMeshMatcapMaterial ? (n(t, r), function (t, e) { e.matcap && (t.matcap.value = e.matcap) }(t, r)) : r.isMeshDepthMaterial ? n(t, r) : r.isMeshDistanceMaterial ? (n(t, r), function (t, e) { t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, r)) : r.isMeshNormalMaterial ? n(t, r) : r.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, r), r.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, r)) : r.isPointsMaterial ? function (t, e, n, r) { let i; t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? i = e.map : e.alphaMap && (i = e.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)) }(t, r, i, a) : r.isSpriteMaterial ? function (t, e) { let n; t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)) }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1) } } } function sa(t, e, n, r) { let i = {}, a = {}, o = []; const s = n.isWebGL2 ? t.getParameter(35375) : 0; function l(t, e, n) { const r = t.value; if (void 0 === n[e]) return n[e] = "number" == typeof r ? r : r.clone(), !0; if ("number" == typeof r) { if (n[e] !== r) return n[e] = r, !0 } else { const t = n[e]; if (!1 === t.equals(r)) return t.copy(r), !0 } return !1 } function c(t) { const e = t.value, n = { boundary: 0, storage: 0 }; return "number" == typeof e ? (n.boundary = 4, n.storage = 4) : e.isVector2 ? (n.boundary = 8, n.storage = 8) : e.isVector3 || e.isColor ? (n.boundary = 16, n.storage = 12) : e.isVector4 ? (n.boundary = 16, n.storage = 16) : e.isMatrix3 ? (n.boundary = 48, n.storage = 48) : e.isMatrix4 ? (n.boundary = 64, n.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), n } function u(e) { const n = e.target; n.removeEventListener("dispose", u); const r = o.indexOf(n.__bindingPointIndex); o.splice(r, 1), t.deleteBuffer(i[n.id]), delete i[n.id], delete a[n.id] } return { bind: function (t, e) { const n = e.program; r.uniformBlockBinding(t, n) }, update: function (n, h) { let d = i[n.id]; void 0 === d && (function (t) { const e = t.uniforms; let n = 0; let r = 0; for (let t = 0, i = e.length; t < i; t++) { const i = e[t], a = c(i); if (i.__data = new Float32Array(a.storage / Float32Array.BYTES_PER_ELEMENT), i.__offset = n, t > 0) { r = n % 16; const t = 16 - r; 0 !== r && t - a.boundary < 0 && (n += 16 - r, i.__offset = n) } n += a.storage } r = n % 16, r > 0 && (n += 16 - r), t.__size = n, t.__cache = {} }(n), d = function (e) { const n = function () { for (let t = 0; t < s; t++)if (-1 === o.indexOf(t)) return o.push(t), t; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 }(); e.__bindingPointIndex = n; const r = t.createBuffer(), i = e.__size, a = e.usage; return t.bindBuffer(35345, r), t.bufferData(35345, i, a), t.bindBuffer(35345, null), t.bindBufferBase(35345, n, r), r }(n), i[n.id] = d, n.addEventListener("dispose", u)); const f = h.program; r.updateUBOMapping(n, f); const p = e.render.frame; a[n.id] !== p && (function (e) { const n = i[e.id], r = e.uniforms, a = e.__cache; t.bindBuffer(35345, n); for (let e = 0, n = r.length; e < n; e++) { const n = r[e]; if (!0 === l(n, e, a)) { const e = n.value, r = n.__offset; "number" == typeof e ? (n.__data[0] = e, t.bufferSubData(35345, r, n.__data)) : (n.value.isMatrix3 ? (n.__data[0] = n.value.elements[0], n.__data[1] = n.value.elements[1], n.__data[2] = n.value.elements[2], n.__data[3] = n.value.elements[0], n.__data[4] = n.value.elements[3], n.__data[5] = n.value.elements[4], n.__data[6] = n.value.elements[5], n.__data[7] = n.value.elements[0], n.__data[8] = n.value.elements[6], n.__data[9] = n.value.elements[7], n.__data[10] = n.value.elements[8], n.__data[11] = n.value.elements[0]) : e.toArray(n.__data), t.bufferSubData(35345, r, n.__data)) } } t.bindBuffer(35345, null) }(n), a[n.id] = p) }, dispose: function () { for (const e in i) t.deleteBuffer(i[e]); o = [], i = {}, a = {} } } } function la(t = {}) { this.isWebGLRenderer = !0; const e = void 0 !== t.canvas ? t.canvas : function () { const t = q("canvas"); return t.style.display = "block", t }(), n = void 0 !== t.context ? t.context : null, r = void 0 === t.depth || t.depth, i = void 0 === t.stencil || t.stencil, a = void 0 !== t.antialias && t.antialias, o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, s = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, l = void 0 !== t.powerPreference ? t.powerPreference : "default", c = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat; let u; u = null !== n ? n.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha; let f = null, g = null; const _ = [], y = []; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = A, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, Object.defineProperties(this, { gammaFactor: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.") } } }); const x = this; let b = !1, M = 0, w = 0, S = null, T = -1, E = null; const C = new ut, L = new ut; let P = null, R = e.width, D = e.height, I = 1, O = null, N = null; const z = new ut(0, 0, R, D), F = new ut(0, 0, R, D); let U = !1; const k = new Ln; let B = !1, V = !1, W = null; const j = new qt, X = new H, Y = new mt, Z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function K() { return null === S ? I : 1 } let J, Q, $, tt, et, nt, rt, it, at, ot, st, lt, ct, dt, ft, pt, gt, vt, _t, yt, xt, bt, Mt, wt, St = n; function Tt(t, n) { for (let r = 0; r < t.length; r++) { const i = t[r], a = e.getContext(i, n); if (null !== a) return a } return null } try { const t = { alpha: !0, depth: r, stencil: i, antialias: a, premultipliedAlpha: o, preserveDrawingBuffer: s, powerPreference: l, failIfMajorPerformanceCaveat: c }; if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r143"), e.addEventListener("webglcontextlost", Ct, !1), e.addEventListener("webglcontextrestored", Lt, !1), e.addEventListener("webglcontextcreationerror", Pt, !1), null === St) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === x.isWebGL1Renderer && e.shift(), St = Tt(e, t), null === St) throw Tt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === St.getShaderPrecisionFormat && (St.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } function Et() { J = new nr(St), Q = new kn(St, J, t), J.init(Q), bt = new $i(St, J, Q), $ = new Ji(St, J, Q), tt = new ar, et = new Fi, nt = new Qi(St, J, $, et, Q, bt, tt), rt = new Vn(x), it = new er(x), at = new Rn(St, Q), Mt = new Fn(St, J, at, Q), ot = new rr(St, at, tt, Mt), st = new ur(St, ot, at, tt), _t = new cr(St, Q, nt), pt = new Bn(et), lt = new zi(x, rt, it, J, Q, Mt, pt), ct = new oa(x, et), dt = new Vi, ft = new Xi(J, Q), vt = new zn(x, rt, $, st, u, o), gt = new Ki(x, st, Q), wt = new sa(St, tt, Q, $), yt = new Un(St, J, tt, Q), xt = new ir(St, J, tt, Q), tt.programs = lt.programs, x.capabilities = Q, x.extensions = J, x.properties = et, x.renderLists = dt, x.shadowMap = gt, x.state = $, x.info = tt } Et(); const At = new aa(x, St); function Ct(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0 } function Lt() { console.log("THREE.WebGLRenderer: Context Restored."), b = !1; const t = tt.autoReset, e = gt.enabled, n = gt.autoUpdate, r = gt.needsUpdate, i = gt.type; Et(), tt.autoReset = t, gt.enabled = e, gt.autoUpdate = n, gt.needsUpdate = r, gt.type = i } function Pt(t) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage) } function Rt(t) { const e = t.target; e.removeEventListener("dispose", Rt), function (t) { (function (t) { const e = et.get(t).programs; void 0 !== e && (e.forEach((function (t) { lt.releaseProgram(t) })), t.isShaderMaterial && lt.releaseShaderCache(t)) })(t), et.remove(t) }(e) } this.xr = At, this.getContext = function () { return St }, this.getContextAttributes = function () { return St.getContextAttributes() }, this.forceContextLoss = function () { const t = J.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { const t = J.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return I }, this.setPixelRatio = function (t) { void 0 !== t && (I = t, this.setSize(R, D, !1)) }, this.getSize = function (t) { return t.set(R, D) }, this.setSize = function (t, n, r) { At.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = t, D = n, e.width = Math.floor(t * I), e.height = Math.floor(n * I), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function (t) { return t.set(R * I, D * I).floor() }, this.setDrawingBufferSize = function (t, n, r) { R = t, D = n, I = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function (t) { return t.copy(C) }, this.getViewport = function (t) { return t.copy(z) }, this.setViewport = function (t, e, n, r) { t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, n, r), $.viewport(C.copy(z).multiplyScalar(I).floor()) }, this.getScissor = function (t) { return t.copy(F) }, this.setScissor = function (t, e, n, r) { t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, r), $.scissor(L.copy(F).multiplyScalar(I).floor()) }, this.getScissorTest = function () { return U }, this.setScissorTest = function (t) { $.setScissorTest(U = t) }, this.setOpaqueSort = function (t) { O = t }, this.setTransparentSort = function (t) { N = t }, this.getClearColor = function (t) { return t.copy(vt.getClearColor()) }, this.setClearColor = function () { vt.setClearColor.apply(vt, arguments) }, this.getClearAlpha = function () { return vt.getClearAlpha() }, this.setClearAlpha = function () { vt.setClearAlpha.apply(vt, arguments) }, this.clear = function (t = !0, e = !0, n = !0) { let r = 0; t && (r |= 16384), e && (r |= 256), n && (r |= 1024), St.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", Ct, !1), e.removeEventListener("webglcontextrestored", Lt, !1), e.removeEventListener("webglcontextcreationerror", Pt, !1), dt.dispose(), ft.dispose(), et.dispose(), rt.dispose(), it.dispose(), st.dispose(), Mt.dispose(), wt.dispose(), lt.dispose(), At.dispose(), At.removeEventListener("sessionstart", It), At.removeEventListener("sessionend", Ot), W && (W.dispose(), W = null), Nt.stop() }, this.renderBufferDirect = function (t, e, n, r, i, a) { null === e && (e = Z); const o = i.isMesh && i.matrixWorld.determinant() < 0, s = function (t, e, n, r, i) { !0 !== e.isScene && (e = Z), nt.resetTextureUnits(); const a = e.fog, o = r.isMeshStandardMaterial ? e.environment : null, s = null === S ? x.outputEncoding : !0 === S.isXRRenderTarget ? S.texture.encoding : A, l = (r.isMeshStandardMaterial ? it : rt).get(r.envMap || o), c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize, u = !!r.normalMap && !!n.attributes.tangent, h = !!n.morphAttributes.position, d = !!n.morphAttributes.normal, f = !!n.morphAttributes.color, p = r.toneMapped ? x.toneMapping : 0, m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color, v = void 0 !== m ? m.length : 0, _ = et.get(r), y = g.state.lights; if (!0 === B && (!0 === V || t !== E)) { const e = t === E && r.id === T; pt.setState(r, t, e) } let b = !1; r.version === _.__version ? _.needsLights && _.lightsStateVersion !== y.state.version || _.outputEncoding !== s || i.isInstancedMesh && !1 === _.instancing ? b = !0 : i.isInstancedMesh || !0 !== _.instancing ? i.isSkinnedMesh && !1 === _.skinning ? b = !0 : i.isSkinnedMesh || !0 !== _.skinning ? _.envMap !== l || !0 === r.fog && _.fog !== a ? b = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === pt.numPlanes && _.numIntersection === pt.numIntersection ? (_.vertexAlphas !== c || _.vertexTangents !== u || _.morphTargets !== h || _.morphNormals !== d || _.morphColors !== f || _.toneMapping !== p || !0 === Q.isWebGL2 && _.morphTargetsCount !== v) && (b = !0) : b = !0 : b = !0 : b = !0 : (b = !0, _.__version = r.version); let M = _.currentProgram; !0 === b && (M = Bt(r, e, i)); let w = !1, C = !1, L = !1; const P = M.getUniforms(), R = _.uniforms; if ($.useProgram(M.program) && (w = !0, C = !0, L = !0), r.id !== T && (T = r.id, C = !0), w || E !== t) { if (P.setValue(St, "projectionMatrix", t.projectionMatrix), Q.logarithmicDepthBuffer && P.setValue(St, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), E !== t && (E = t, C = !0, L = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) { const e = P.map.cameraPosition; void 0 !== e && e.setValue(St, Y.setFromMatrixPosition(t.matrixWorld)) } (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && P.setValue(St, "isOrthographic", !0 === t.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && P.setValue(St, "viewMatrix", t.matrixWorldInverse) } if (i.isSkinnedMesh) { P.setOptional(St, i, "bindMatrix"), P.setOptional(St, i, "bindMatrixInverse"); const t = i.skeleton; t && (Q.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), P.setValue(St, "boneTexture", t.boneTexture, nt), P.setValue(St, "boneTextureSize", t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const O = n.morphAttributes; var N, z; if ((void 0 !== O.position || void 0 !== O.normal || void 0 !== O.color && !0 === Q.isWebGL2) && _t.update(i, n, r, M), (C || _.receiveShadow !== i.receiveShadow) && (_.receiveShadow = i.receiveShadow, P.setValue(St, "receiveShadow", i.receiveShadow)), C && (P.setValue(St, "toneMappingExposure", x.toneMappingExposure), _.needsLights && (z = L, (N = R).ambientLightColor.needsUpdate = z, N.lightProbe.needsUpdate = z, N.directionalLights.needsUpdate = z, N.directionalLightShadows.needsUpdate = z, N.pointLights.needsUpdate = z, N.pointLightShadows.needsUpdate = z, N.spotLights.needsUpdate = z, N.spotLightShadows.needsUpdate = z, N.rectAreaLights.needsUpdate = z, N.hemisphereLights.needsUpdate = z), a && !0 === r.fog && ct.refreshFogUniforms(R, a), ct.refreshMaterialUniforms(R, r, I, D, W), pi.upload(St, _.uniformsList, R, nt)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (pi.upload(St, _.uniformsList, R, nt), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && P.setValue(St, "center", i.center), P.setValue(St, "modelViewMatrix", i.modelViewMatrix), P.setValue(St, "normalMatrix", i.normalMatrix), P.setValue(St, "modelMatrix", i.matrixWorld), r.isShaderMaterial || r.isRawShaderMaterial) { const t = r.uniformsGroups; for (let e = 0, n = t.length; e < n; e++)if (Q.isWebGL2) { const n = t[e]; wt.update(n, M), wt.bind(n, M) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return M }(t, e, n, r, i); $.setMaterial(r, o); let l = n.index; const c = n.attributes.position; if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return; let u, h = 1; !0 === r.wireframe && (l = ot.getWireframeAttribute(n), h = 2), Mt.setup(i, r, s, n, l); let d = yt; null !== l && (u = at.get(l), d = xt, d.setIndex(u)); const f = null !== l ? l.count : c.count, p = n.drawRange.start * h, m = n.drawRange.count * h, v = null !== a ? a.start * h : 0, _ = null !== a ? a.count * h : 1 / 0, y = Math.max(p, v), b = Math.min(f, p + m, v + _) - 1, M = Math.max(0, b - y + 1); if (0 !== M) { if (i.isMesh) !0 === r.wireframe ? ($.setLineWidth(r.wireframeLinewidth * K()), d.setMode(1)) : d.setMode(4); else if (i.isLine) { let t = r.linewidth; void 0 === t && (t = 1), $.setLineWidth(t * K()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3) } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4); if (i.isInstancedMesh) d.renderInstances(y, M, i.count); else if (n.isInstancedBufferGeometry) { const t = Math.min(n.instanceCount, n._maxInstanceCount); d.renderInstances(y, M, t) } else d.render(y, M) } }, this.compile = function (t, e) { g = ft.get(t), g.init(), y.push(g), t.traverseVisible((function (t) { t.isLight && t.layers.test(e.layers) && (g.pushLight(t), t.castShadow && g.pushShadow(t)) })), g.setupLights(x.physicallyCorrectLights), t.traverse((function (e) { const n = e.material; if (n) if (Array.isArray(n)) for (let r = 0; r < n.length; r++)Bt(n[r], t, e); else Bt(n, t, e) })), y.pop(), g = null }; let Dt = null; function It() { Nt.stop() } function Ot() { Nt.start() } const Nt = new Pn; function zt(t, e, n, r) { if (!1 === t.visible) return; if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) g.pushLight(t), t.castShadow && g.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || k.intersectsSprite(t)) { r && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j); const e = st.update(t), i = t.material; i.visible && f.push(t, e, i, n, Y.z, null) } } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== tt.render.frame && (t.skeleton.update(), t.skeleton.frame = tt.render.frame), !t.frustumCulled || k.intersectsObject(t))) { r && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j); const e = st.update(t), i = t.material; if (Array.isArray(i)) { const r = e.groups; for (let a = 0, o = r.length; a < o; a++) { const o = r[a], s = i[o.materialIndex]; s && s.visible && f.push(t, e, s, n, Y.z, o) } } else i.visible && f.push(t, e, i, n, Y.z, null) } const i = t.children; for (let t = 0, a = i.length; t < a; t++)zt(i[t], e, n, r) } function Ft(t, e, n, r) { const i = t.opaque, o = t.transmissive, s = t.transparent; g.setupLightsView(n), o.length > 0 && function (t, e, n) { const r = Q.isWebGL2; null === W && (W = new ht(1, 1, { generateMipmaps: !0, type: J.has("EXT_color_buffer_half_float") ? m : d, minFilter: h, samples: r && !0 === a ? 4 : 0 })), x.getDrawingBufferSize(X), r ? W.setSize(X.x, X.y) : W.setSize(G(X.x), G(X.y)); const i = x.getRenderTarget(); x.setRenderTarget(W), x.clear(); const o = x.toneMapping; x.toneMapping = 0, Ut(t, e, n), x.toneMapping = o, nt.updateMultisampleRenderTarget(W), nt.updateRenderTargetMipmap(W), x.setRenderTarget(i) }(i, e, n), r && $.viewport(C.copy(r)), i.length > 0 && Ut(i, e, n), o.length > 0 && Ut(o, e, n), s.length > 0 && Ut(s, e, n), $.buffers.depth.setTest(!0), $.buffers.depth.setMask(!0), $.buffers.color.setMask(!0), $.setPolygonOffset(!1) } function Ut(t, e, n) { const r = !0 === e.isScene ? e.overrideMaterial : null; for (let i = 0, a = t.length; i < a; i++) { const a = t[i], o = a.object, s = a.geometry, l = null === r ? a.material : r, c = a.group; o.layers.test(n.layers) && kt(o, e, n, s, l, c) } } function kt(t, e, n, r, i, a) { t.onBeforeRender(x, e, n, r, i, a), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), i.onBeforeRender(x, e, n, r, t, a), !0 === i.transparent && 2 === i.side ? (i.side = 1, i.needsUpdate = !0, x.renderBufferDirect(n, e, r, i, t, a), i.side = 0, i.needsUpdate = !0, x.renderBufferDirect(n, e, r, i, t, a), i.side = 2) : x.renderBufferDirect(n, e, r, i, t, a), t.onAfterRender(x, e, n, r, i, a) } function Bt(t, e, n) { !0 !== e.isScene && (e = Z); const r = et.get(t), i = g.state.lights, a = g.state.shadowsArray, o = i.state.version, s = lt.getParameters(t, i.state, a, e, n), l = lt.getProgramCacheKey(s); let c = r.programs; r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = (t.isMeshStandardMaterial ? it : rt).get(t.envMap || r.environment), void 0 === c && (t.addEventListener("dispose", Rt), c = new Map, r.programs = c); let u = c.get(l); if (void 0 !== u) { if (r.currentProgram === u && r.lightsStateVersion === o) return Vt(t, s), u } else s.uniforms = lt.getUniforms(t), t.onBuild(n, s, x), t.onBeforeCompile(s, x), u = lt.acquireProgram(s, l), c.set(l, u), r.uniforms = s.uniforms; const h = r.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = pt.uniform), Vt(t, s), r.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), r.lightsStateVersion = o, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i.state.spotShadowMatrix, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix); const d = u.getUniforms(), f = pi.seqWithValue(d.seq, h); return r.currentProgram = u, r.uniformsList = f, u } function Vt(t, e) { const n = et.get(t); n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping } Nt.setAnimationLoop((function (t) { Dt && Dt(t) })), "undefined" != typeof self && Nt.setContext(self), this.setAnimationLoop = function (t) { Dt = t, At.setAnimationLoop(t), null === t ? Nt.stop() : Nt.start() }, At.addEventListener("sessionstart", It), At.addEventListener("sessionend", Ot), this.render = function (t, e) { if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === b) return; !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === At.enabled && !0 === At.isPresenting && (!0 === At.cameraAutoUpdate && At.updateCamera(e), e = At.getCamera()), !0 === t.isScene && t.onBeforeRender(x, t, e, S), g = ft.get(t, y.length), g.init(), y.push(g), j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), k.setFromProjectionMatrix(j), V = this.localClippingEnabled, B = pt.init(this.clippingPlanes, V, e), f = dt.get(t, _.length), f.init(), _.push(f), zt(t, e, 0, x.sortObjects), f.finish(), !0 === x.sortObjects && f.sort(O, N), !0 === B && pt.beginShadows(); const n = g.state.shadowsArray; if (gt.render(n, t, e), !0 === B && pt.endShadows(), !0 === this.info.autoReset && this.info.reset(), vt.render(f, t), g.setupLights(x.physicallyCorrectLights), e.isArrayCamera) { const n = e.cameras; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; Ft(f, t, r, r.viewport) } } else Ft(f, t, e); null !== S && (nt.updateMultisampleRenderTarget(S), nt.updateRenderTargetMipmap(S)), !0 === t.isScene && t.onAfterRender(x, t, e), Mt.resetDefaultState(), T = -1, E = null, y.pop(), g = y.length > 0 ? y[y.length - 1] : null, _.pop(), f = _.length > 0 ? _[_.length - 1] : null }, this.getActiveCubeFace = function () { return M }, this.getActiveMipmapLevel = function () { return w }, this.getRenderTarget = function () { return S }, this.setRenderTargetTextures = function (t, e, n) { et.get(t.texture).__webglTexture = e, et.get(t.depthTexture).__webglTexture = n; const r = et.get(t); r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === J.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (t, e) { const n = et.get(t); n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e }, this.setRenderTarget = function (t, e = 0, n = 0) { S = t, M = e, w = n; let r = !0; if (t) { const e = et.get(t); void 0 !== e.__useDefaultFramebuffer ? ($.bindFramebuffer(36160, null), r = !1) : void 0 === e.__webglFramebuffer ? nt.setupRenderTarget(t) : e.__hasExternalTextures && nt.rebindTextures(t, et.get(t.texture).__webglTexture, et.get(t.depthTexture).__webglTexture) } let i = null, a = !1, o = !1; if (t) { const n = t.texture; (n.isData3DTexture || n.isDataArrayTexture) && (o = !0); const r = et.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (i = r[e], a = !0) : i = Q.isWebGL2 && t.samples > 0 && !1 === nt.useMultisampledRTT(t) ? et.get(t).__webglMultisampledFramebuffer : r, C.copy(t.viewport), L.copy(t.scissor), P = t.scissorTest } else C.copy(z).multiplyScalar(I).floor(), L.copy(F).multiplyScalar(I).floor(), P = U; if ($.bindFramebuffer(36160, i) && Q.drawBuffers && r && $.drawBuffers(t, i), $.viewport(C), $.scissor(L), $.setScissorTest(P), a) { const r = et.get(t.texture); St.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n) } else if (o) { const r = et.get(t.texture), i = e || 0; St.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i) } T = -1 }, this.readRenderTargetPixels = function (t, e, n, r, i, a, o) { if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let s = et.get(t).__webglFramebuffer; if (t.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) { $.bindFramebuffer(36160, s); try { const o = t.texture, s = o.format, l = o.type; if (s !== v && bt.convert(s) !== St.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const c = l === m && (J.has("EXT_color_buffer_half_float") || Q.isWebGL2 && J.has("EXT_color_buffer_float")); if (!(l === d || bt.convert(l) === St.getParameter(35738) || l === p && (Q.isWebGL2 || J.has("OES_texture_float") || J.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && St.readPixels(e, n, r, i, bt.convert(s), bt.convert(l), a) } finally { const t = null !== S ? et.get(S).__webglFramebuffer : null; $.bindFramebuffer(36160, t) } } }, this.copyFramebufferToTexture = function (t, e, n = 0) { const r = Math.pow(2, -n), i = Math.floor(e.image.width * r), a = Math.floor(e.image.height * r); nt.setTexture2D(e, 0), St.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, i, a), $.unbindTexture() }, this.copyTextureToTexture = function (t, e, n, r = 0) { const i = e.image.width, a = e.image.height, o = bt.convert(n.format), s = bt.convert(n.type); nt.setTexture2D(n, 0), St.pixelStorei(37440, n.flipY), St.pixelStorei(37441, n.premultiplyAlpha), St.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? St.texSubImage2D(3553, r, t.x, t.y, i, a, o, s, e.image.data) : e.isCompressedTexture ? St.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : St.texSubImage2D(3553, r, t.x, t.y, o, s, e.image), 0 === r && n.generateMipmaps && St.generateMipmap(3553), $.unbindTexture() }, this.copyTextureToTexture3D = function (t, e, n, r, i = 0) { if (x.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const a = t.max.x - t.min.x + 1, o = t.max.y - t.min.y + 1, s = t.max.z - t.min.z + 1, l = bt.convert(r.format), c = bt.convert(r.type); let u; if (r.isData3DTexture) nt.setTexture3D(r, 0), u = 32879; else { if (!r.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); nt.setTexture2DArray(r, 0), u = 35866 } St.pixelStorei(37440, r.flipY), St.pixelStorei(37441, r.premultiplyAlpha), St.pixelStorei(3317, r.unpackAlignment); const h = St.getParameter(3314), d = St.getParameter(32878), f = St.getParameter(3316), p = St.getParameter(3315), m = St.getParameter(32877), g = n.isCompressedTexture ? n.mipmaps[0] : n.image; St.pixelStorei(3314, g.width), St.pixelStorei(32878, g.height), St.pixelStorei(3316, t.min.x), St.pixelStorei(3315, t.min.y), St.pixelStorei(32877, t.min.z), n.isDataTexture || n.isData3DTexture ? St.texSubImage3D(u, i, e.x, e.y, e.z, a, o, s, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), St.compressedTexSubImage3D(u, i, e.x, e.y, e.z, a, o, s, l, g.data)) : St.texSubImage3D(u, i, e.x, e.y, e.z, a, o, s, l, c, g), St.pixelStorei(3314, h), St.pixelStorei(32878, d), St.pixelStorei(3316, f), St.pixelStorei(3315, p), St.pixelStorei(32877, m), 0 === i && r.generateMipmaps && St.generateMipmap(u), $.unbindTexture() }, this.initTexture = function (t) { t.isCubeTexture ? nt.setTextureCube(t, 0) : t.isData3DTexture ? nt.setTexture3D(t, 0) : t.isDataArrayTexture ? nt.setTexture2DArray(t, 0) : nt.setTexture2D(t, 0), $.unbindTexture() }, this.resetState = function () { M = 0, w = 0, S = null, $.reset(), Mt.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } (class extends la { }).prototype.isWebGL1Renderer = !0; class ca extends ve { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this } toJSON(t) { const e = super.toJSON(t); return null !== this.fog && (e.object.fog = this.fog.toJSON()), e } } class ua extends Pe { constructor(t) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this } } const ha = new qt, da = new jt, fa = new Ft, pa = new mt; class ma extends ve { constructor(t = new je, e = new ua) { super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t, e) { return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this } raycast(t, e) { const n = this.geometry, r = this.matrixWorld, i = t.params.Points.threshold, a = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), fa.copy(n.boundingSphere), fa.applyMatrix4(r), fa.radius += i, !1 === t.ray.intersectsSphere(fa)) return; ha.copy(r).invert(), da.copy(t.ray).applyMatrix4(ha); const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, l = n.index, c = n.attributes.position; if (null !== l) for (let n = Math.max(0, a.start), i = Math.min(l.count, a.start + a.count); n < i; n++) { const i = l.getX(n); pa.fromBufferAttribute(c, i), ga(pa, i, s, r, t, e, this) } else for (let n = Math.max(0, a.start), i = Math.min(c.count, a.start + a.count); n < i; n++)pa.fromBufferAttribute(c, n), ga(pa, n, s, r, t, e, this) } updateMorphTargets() { const t = this.geometry.morphAttributes, e = Object.keys(t); if (e.length > 0) { const n = t[e[0]]; if (void 0 !== n) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, e = n.length; t < e; t++) { const e = n[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t } } } } } function ga(t, e, n, r, i, a, o) { const s = da.distanceSqToPoint(t); if (s < n) { const n = new mt; da.closestPointToPoint(t, n), n.applyMatrix4(r); const l = i.ray.origin.distanceTo(n); if (l < i.near || l > i.far) return; a.push({ distance: l, distanceToRay: Math.sqrt(s), point: n, index: e, face: null, object: o }) } } class va extends je { constructor(t = 1, e = 32, n = 16, r = 0, i = 2 * Math.PI, a = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: r, phiLength: i, thetaStart: a, thetaLength: o }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n)); const s = Math.min(a + o, Math.PI); let l = 0; const c = [], u = new mt, h = new mt, d = [], f = [], p = [], m = []; for (let d = 0; d <= n; d++) { const g = [], v = d / n; let _ = 0; 0 == d && 0 == a ? _ = .5 / e : d == n && s == Math.PI && (_ = -.5 / e); for (let n = 0; n <= e; n++) { const s = n / e; u.x = -t * Math.cos(r + s * i) * Math.sin(a + v * o), u.y = t * Math.cos(a + v * o), u.z = t * Math.sin(r + s * i) * Math.sin(a + v * o), f.push(u.x, u.y, u.z), h.copy(u).normalize(), p.push(h.x, h.y, h.z), m.push(s + _, 1 - v), g.push(l++) } c.push(g) } for (let t = 0; t < n; t++)for (let r = 0; r < e; r++) { const e = c[t][r + 1], i = c[t][r], o = c[t + 1][r], l = c[t + 1][r + 1]; (0 !== t || a > 0) && d.push(e, i, l), (t !== n - 1 || s < Math.PI) && d.push(i, o, l) } this.setIndex(d), this.setAttribute("position", new Fe(f, 3)), this.setAttribute("normal", new Fe(p, 3)), this.setAttribute("uv", new Fe(m, 2)) } static fromJSON(t) { return new va(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength) } } function _a(t, e, n) { return xa(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) } function ya(t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) } function xa(t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) } class ba { constructor(t, e, n, r) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(t) { const e = this.parameterPositions; let n = this._cachedIndex, r = e[n], i = e[n - 1]; t: { e: { let a; n: { r: if (!(t < r)) { for (let a = n + 2; ;) { if (void 0 === r) { if (t < i) break r; return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } if (n === a) break; if (i = r, r = e[++n], t < r) break e } a = e.length; break n } if (t >= i) break t; { const o = e[1]; t < o && (n = 2, i = o); for (let a = n - 2; ;) { if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0); if (n === a) break; if (r = i, i = e[--n - 1], t >= i) break e } a = n, n = 0 } } for (; n < a;) { const r = n + a >>> 1; t < e[r] ? a = r : n = r + 1 } if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0); if (void 0 === r) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } this._cachedIndex = n, this.intervalChanged_(n, i, r) } return this.interpolate_(n, i, t, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(t) { const e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r; for (let t = 0; t !== r; ++t)e[t] = n[i + t]; return e } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class Ma extends ba { constructor(t, e, n, r) { super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 } } intervalChanged_(t, e, n) { const r = this.parameterPositions; let i = t - 2, a = t + 1, o = r[i], s = r[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case 2401: i = t, o = 2 * e - n; break; case 2402: i = r.length - 2, o = e + r[i] - r[i + 1]; break; default: i = t, o = n }if (void 0 === s) switch (this.getSettings_().endingEnd) { case 2401: a = t, s = 2 * n - e; break; case 2402: a = 1, s = n + r[1] - r[0]; break; default: a = t - 1, s = e }const l = .5 * (n - e), c = this.valueSize; this._weightPrev = l / (e - o), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = a * c } interpolate_(t, e, n, r) { const i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, l = s - o, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (n - e) / (r - e), p = f * f, m = p * f, g = -h * m + 2 * h * p - h * f, v = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1, _ = (-1 - d) * m + (1.5 + d) * p + .5 * f, y = d * m - d * p; for (let t = 0; t !== o; ++t)i[t] = g * a[c + t] + v * a[l + t] + _ * a[s + t] + y * a[u + t]; return i } } class wa extends ba { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_(t, e, n, r) { const i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, l = s - o, c = (n - e) / (r - e), u = 1 - c; for (let t = 0; t !== o; ++t)i[t] = a[l + t] * u + a[s + t] * c; return i } } class Sa extends ba { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_(t) { return this.copySampleValue_(t - 1) } } class Ta { constructor(t, e, n, r) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = ya(e, this.TimeBufferType), this.values = ya(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(t) { const e = t.constructor; let n; if (e.toJSON !== this.toJSON) n = e.toJSON(t); else { n = { name: t.name, times: ya(t.times, Array), values: ya(t.values, Array) }; const e = t.getInterpolation(); e !== t.DefaultInterpolation && (n.interpolation = e) } return n.type = t.ValueTypeName, n } InterpolantFactoryMethodDiscrete(t) { return new Sa(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodLinear(t) { return new wa(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodSmooth(t) { return new Ma(this.times, this.values, this.getValueSize(), t) } setInterpolation(t) { let e; switch (t) { case S: e = this.InterpolantFactoryMethodDiscrete; break; case T: e = this.InterpolantFactoryMethodLinear; break; case E: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return S; case this.InterpolantFactoryMethodLinear: return T; case this.InterpolantFactoryMethodSmooth: return E } } getValueSize() { return this.values.length / this.times.length } shift(t) { if (0 !== t) { const e = this.times; for (let n = 0, r = e.length; n !== r; ++n)e[n] += t } return this } scale(t) { if (1 !== t) { const e = this.times; for (let n = 0, r = e.length; n !== r; ++n)e[n] *= t } return this } trim(t, e) { const n = this.times, r = n.length; let i = 0, a = r - 1; for (; i !== r && n[i] < t;)++i; for (; -1 !== a && n[a] > e;)--a; if (++a, 0 !== i || a !== r) { i >= a && (a = Math.max(a, 1), i = a - 1); const t = this.getValueSize(); this.times = _a(n, i, a), this.values = _a(this.values, i * t, a * t) } return this } validate() { let t = !0; const e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); const n = this.times, r = this.values, i = n.length; 0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let a = null; for (let e = 0; e !== i; e++) { const r = n[e]; if ("number" == typeof r && isNaN(r)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, r), t = !1; break } if (null !== a && a > r) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, r, a), t = !1; break } a = r } if (void 0 !== r && xa(r)) for (let e = 0, n = r.length; e !== n; ++e) { const n = r[e]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1; break } } return t } optimize() { const t = _a(this.times), e = _a(this.values), n = this.getValueSize(), r = this.getInterpolation() === E, i = t.length - 1; let a = 1; for (let o = 1; o < i; ++o) { let i = !1; const s = t[o]; if (s !== t[o + 1] && (1 !== o || s !== t[0])) if (r) i = !0; else { const t = o * n, r = t - n, a = t + n; for (let o = 0; o !== n; ++o) { const n = e[t + o]; if (n !== e[r + o] || n !== e[a + o]) { i = !0; break } } } if (i) { if (o !== a) { t[a] = t[o]; const r = o * n, i = a * n; for (let t = 0; t !== n; ++t)e[i + t] = e[r + t] } ++a } } if (i > 0) { t[a] = t[i]; for (let t = i * n, r = a * n, o = 0; o !== n; ++o)e[r + o] = e[t + o]; ++a } return a !== t.length ? (this.times = _a(t, 0, a), this.values = _a(e, 0, a * n)) : (this.times = t, this.values = e), this } clone() { const t = _a(this.times, 0), e = _a(this.values, 0), n = new (0, this.constructor)(this.name, t, e); return n.createInterpolant = this.createInterpolant, n } } Ta.prototype.TimeBufferType = Float32Array, Ta.prototype.ValueBufferType = Float32Array, Ta.prototype.DefaultInterpolation = T; class Ea extends Ta { } Ea.prototype.ValueTypeName = "bool", Ea.prototype.ValueBufferType = Array, Ea.prototype.DefaultInterpolation = S, Ea.prototype.InterpolantFactoryMethodLinear = void 0, Ea.prototype.InterpolantFactoryMethodSmooth = void 0; (class extends Ta { }).prototype.ValueTypeName = "color"; (class extends Ta { }).prototype.ValueTypeName = "number"; class Aa extends ba { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_(t, e, n, r) { const i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (n - e) / (r - e); let l = t * o; for (let t = l + o; l !== t; l += 4)pt.slerpFlat(i, 0, a, l - o, a, l, s); return i } } class Ca extends Ta { InterpolantFactoryMethodLinear(t) { return new Aa(this.times, this.values, this.getValueSize(), t) } } Ca.prototype.ValueTypeName = "quaternion", Ca.prototype.DefaultInterpolation = T, Ca.prototype.InterpolantFactoryMethodSmooth = void 0; class La extends Ta { } La.prototype.ValueTypeName = "string", La.prototype.ValueBufferType = Array, La.prototype.DefaultInterpolation = S, La.prototype.InterpolantFactoryMethodLinear = void 0, La.prototype.InterpolantFactoryMethodSmooth = void 0; (class extends Ta { }).prototype.ValueTypeName = "vector"; const Pa = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; class Ra { constructor(t, e, n) { const r = this; let i, a = !1, o = 0, s = 0; const l = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { s++, !1 === a && void 0 !== r.onStart && r.onStart(t, o, s), a = !0 }, this.itemEnd = function (t) { o++, void 0 !== r.onProgress && r.onProgress(t, o, s), o === s && (a = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (t) { void 0 !== r.onError && r.onError(t) }, this.resolveURL = function (t) { return i ? i(t) : t }, this.setURLModifier = function (t) { return i = t, this }, this.addHandler = function (t, e) { return l.push(t, e), this }, this.removeHandler = function (t) { const e = l.indexOf(t); return -1 !== e && l.splice(e, 2), this }, this.getHandler = function (t) { for (let e = 0, n = l.length; e < n; e += 2) { const n = l[e], r = l[e + 1]; if (n.global && (n.lastIndex = 0), n.test(t)) return r } return null } } } const Da = new Ra; class Ia { constructor(t) { this.manager = void 0 !== t ? t : Da, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(t, e) { const n = this; return new Promise((function (r, i) { n.load(t, r, e, i) })) } parse() { } setCrossOrigin(t) { return this.crossOrigin = t, this } setWithCredentials(t) { return this.withCredentials = t, this } setPath(t) { return this.path = t, this } setResourcePath(t) { return this.resourcePath = t, this } setRequestHeader(t) { return this.requestHeader = t, this } } class Oa extends Error { constructor(t, e) { super(t), this.response = e } } class Na extends Ia { constructor(t) { super(t) } load(t, e, n, r) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, a = Pa.get(t); if (void 0 !== a) return i.manager.itemStart(t), setTimeout((function () { e && e(a), i.manager.itemEnd(t) }), 0), a; const o = q("img"); function s() { c(), Pa.add(t, this), e && e(this), i.manager.itemEnd(t) } function l(e) { c(), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t) } function c() { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1) } return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o } } class za extends Ia { constructor(t) { super(t) } load(t, e, n, r) { const i = new ct, a = new Na(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, (function (t) { i.image = t, i.needsUpdate = !0, void 0 !== e && e(i) }), n, r), i } } const Fa = new RegExp("[\\[\\]\\.:\\/]", "g"), Ua = "[^\\[\\]\\.:\\/]", ka = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Ba = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Ua) + /(WCOD+)?/.source.replace("WCOD", ka) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ua) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ua) + "$"), Va = ["material", "materials", "bones"]; class Ga { constructor(t, e, n) { this.path = e, this.parsedPath = n || Ga.parseTrackName(e), this.node = Ga.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(t, e, n) { return t && t.isAnimationObjectGroup ? new Ga.Composite(t, e, n) : new Ga(t, e, n) } static sanitizeNodeName(t) { return t.replace(/\s/g, "_").replace(Fa, "") } static parseTrackName(t) { const e = Ba.exec(t); if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { const t = n.nodeName.substring(r + 1); -1 !== Va.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n } static findNode(t, e) { if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n } if (t.children) { const n = function (t) { for (let r = 0; r < t.length; r++) { const i = t[r]; if (i.name === e || i.uuid === e) return i; const a = n(i.children); if (a) return a } return null }, r = n(t.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(t, e) { t[e] = this.targetObject[this.propertyName] } _getValue_array(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)t[e++] = n[r] } _getValue_arrayElement(t, e) { t[e] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(t, e) { this.resolvedProperty.toArray(t, e) } _setValue_direct(t, e) { this.targetObject[this.propertyName] = t[e] } _setValue_direct_setNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = t[e++] } _setValue_array_setNeedsUpdate(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = t[e++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(t, e) { this.resolvedProperty[this.propertyIndex] = t[e] } _setValue_arrayElement_setNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(t, e) { this.resolvedProperty.fromArray(t, e) } _setValue_fromArray_setNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(t, e) { this.bind(), this.getValue(t, e) } _setValue_unbound(t, e) { this.bind(), this.setValue(t, e) } bind() { let t = this.node; const e = this.parsedPath, n = e.objectName, r = e.propertyName; let i = e.propertyIndex; if (t || (t = Ga.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let r = e.objectIndex; switch (n) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (let e = 0; e < t.length; e++)if (t[e].name === r) { r = e; break } break; default: if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[n] }if (void 0 !== r) { if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[r] } } const a = t[r]; if (void 0 === a) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t) } let o = this.Versioning.None; this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate); let s = this.BindingType.Direct; if (void 0 !== i) { if ("morphTargetInfluences" === r) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i]) } s = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = i } else void 0 !== a.fromArray && void 0 !== a.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (s = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r; this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][o] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Ga.Composite = class { constructor(t, e, n) { const r = n || Ga.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, r) } getValue(t, e) { this.bind(); const n = this._targetGroup.nCachedObjects_, r = this._bindings[n]; void 0 !== r && r.getValue(t, e) } setValue(t, e) { const n = this._bindings; for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)n[r].setValue(t, e) } bind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() } unbind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }, Ga.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ga.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ga.prototype.GetterByBindingType = [Ga.prototype._getValue_direct, Ga.prototype._getValue_array, Ga.prototype._getValue_arrayElement, Ga.prototype._getValue_toArray], Ga.prototype.SetterByBindingTypeAndVersioning = [[Ga.prototype._setValue_direct, Ga.prototype._setValue_direct_setNeedsUpdate, Ga.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ga.prototype._setValue_array, Ga.prototype._setValue_array_setNeedsUpdate, Ga.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ga.prototype._setValue_arrayElement, Ga.prototype._setValue_arrayElement_setNeedsUpdate, Ga.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ga.prototype._setValue_fromArray, Ga.prototype._setValue_fromArray_setNeedsUpdate, Ga.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]], new Float32Array(1); class Ha { constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this } set(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this } copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this } makeSafe() { const t = 1e-6; return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this } setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) } setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(k(e / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "143" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "143"); const Wa = { type: "change" }, ja = { type: "start" }, qa = { type: "end" }; class Xa extends O { constructor(t, e) { super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new mt, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, this.touches = { ONE: 0, TWO: 2 }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return o.phi }, this.getAzimuthalAngle = function () { return o.theta }, this.getDistance = function () { return this.object.position.distanceTo(this.target) }, this.listenToKeyEvents = function (t) { t.addEventListener("keydown", W), this._domElementKeyEvents = t }, this.saveState = function () { n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom }, this.reset = function () { n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(Wa), n.update(), i = r.NONE }, this.update = function () { const e = new mt, h = (new pt).setFromUnitVectors(t.up, new mt(0, 1, 0)), d = h.clone().invert(), f = new mt, p = new pt, m = 2 * Math.PI; return function () { const t = n.object.position; e.copy(t).sub(n.target), e.applyQuaternion(h), o.setFromVector3(e), n.autoRotate && i === r.NONE && w(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (o.theta += s.theta * n.dampingFactor, o.phi += s.phi * n.dampingFactor) : (o.theta += s.theta, o.phi += s.phi); let g = n.minAzimuthAngle, v = n.maxAzimuthAngle; return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += m : g > Math.PI && (g -= m), v < -Math.PI ? v += m : v > Math.PI && (v -= m), o.theta = g <= v ? Math.max(g, Math.min(v, o.theta)) : o.theta > (g + v) / 2 ? Math.max(g, o.theta) : Math.min(v, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), o.radius *= l, o.radius = Math.max(n.minDistance, Math.min(n.maxDistance, o.radius)), !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c), e.setFromSpherical(o), e.applyQuaternion(d), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (s.theta *= 1 - n.dampingFactor, s.phi *= 1 - n.dampingFactor, c.multiplyScalar(1 - n.dampingFactor)) : (s.set(0, 0, 0), c.set(0, 0, 0)), l = 1, !!(u || f.distanceToSquared(n.object.position) > a || 8 * (1 - p.dot(n.object.quaternion)) > a) && (n.dispatchEvent(Wa), f.copy(n.object.position), p.copy(n.object.quaternion), u = !1, !0) } }(), this.dispose = function () { n.domElement.removeEventListener("contextmenu", j), n.domElement.removeEventListener("pointerdown", U), n.domElement.removeEventListener("pointercancel", V), n.domElement.removeEventListener("wheel", G), n.domElement.removeEventListener("pointermove", k), n.domElement.removeEventListener("pointerup", B), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", W) }; const n = this, r = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let i = r.NONE; const a = 1e-6, o = new Ha, s = new Ha; let l = 1; const c = new mt; let u = !1; const h = new H, d = new H, f = new H, p = new H, m = new H, g = new H, v = new H, _ = new H, y = new H, x = [], b = {}; function M() { return Math.pow(.95, n.zoomSpeed) } function w(t) { s.theta -= t } function S(t) { s.phi -= t } const T = function () { const t = new mt; return function (e, n) { t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), c.add(t) } }(), E = function () { const t = new mt; return function (e, r) { !0 === n.screenSpacePanning ? t.setFromMatrixColumn(r, 1) : (t.setFromMatrixColumn(r, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), c.add(t) } }(), A = function () { const t = new mt; return function (e, r) { const i = n.domElement; if (n.object.isPerspectiveCamera) { const a = n.object.position; t.copy(a).sub(n.target); let o = t.length(); o *= Math.tan(n.object.fov / 2 * Math.PI / 180), T(2 * e * o / i.clientHeight, n.object.matrix), E(2 * r * o / i.clientHeight, n.object.matrix) } else n.object.isOrthographicCamera ? (T(e * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), E(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1) } }(); function C(t) { n.object.isPerspectiveCamera ? l /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function L(t) { n.object.isPerspectiveCamera ? l *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function P(t) { h.set(t.clientX, t.clientY) } function R(t) { p.set(t.clientX, t.clientY) } function D() { if (1 === x.length) h.set(x[0].pageX, x[0].pageY); else { const t = .5 * (x[0].pageX + x[1].pageX), e = .5 * (x[0].pageY + x[1].pageY); h.set(t, e) } } function I() { if (1 === x.length) p.set(x[0].pageX, x[0].pageY); else { const t = .5 * (x[0].pageX + x[1].pageX), e = .5 * (x[0].pageY + x[1].pageY); p.set(t, e) } } function O() { const t = x[0].pageX - x[1].pageX, e = x[0].pageY - x[1].pageY, n = Math.sqrt(t * t + e * e); v.set(0, n) } function N(t) { if (1 == x.length) d.set(t.pageX, t.pageY); else { const e = Y(t), n = .5 * (t.pageX + e.x), r = .5 * (t.pageY + e.y); d.set(n, r) } f.subVectors(d, h).multiplyScalar(n.rotateSpeed); const e = n.domElement; w(2 * Math.PI * f.x / e.clientHeight), S(2 * Math.PI * f.y / e.clientHeight), h.copy(d) } function z(t) { if (1 === x.length) m.set(t.pageX, t.pageY); else { const e = Y(t), n = .5 * (t.pageX + e.x), r = .5 * (t.pageY + e.y); m.set(n, r) } g.subVectors(m, p).multiplyScalar(n.panSpeed), A(g.x, g.y), p.copy(m) } function F(t) { const e = Y(t), r = t.pageX - e.x, i = t.pageY - e.y, a = Math.sqrt(r * r + i * i); _.set(0, a), y.set(0, Math.pow(_.y / v.y, n.zoomSpeed)), C(y.y), v.copy(_) } function U(t) { !1 !== n.enabled && (0 === x.length && (n.domElement.setPointerCapture(t.pointerId), n.domElement.addEventListener("pointermove", k), n.domElement.addEventListener("pointerup", B)), function (t) { x.push(t) }(t), "touch" === t.pointerType ? function (t) { switch (X(t), x.length) { case 1: switch (n.touches.ONE) { case 0: if (!1 === n.enableRotate) return; D(), i = r.TOUCH_ROTATE; break; case 1: if (!1 === n.enablePan) return; I(), i = r.TOUCH_PAN; break; default: i = r.NONE }break; case 2: switch (n.touches.TWO) { case 2: if (!1 === n.enableZoom && !1 === n.enablePan) return; n.enableZoom && O(), n.enablePan && I(), i = r.TOUCH_DOLLY_PAN; break; case 3: if (!1 === n.enableZoom && !1 === n.enableRotate) return; n.enableZoom && O(), n.enableRotate && D(), i = r.TOUCH_DOLLY_ROTATE; break; default: i = r.NONE }break; default: i = r.NONE }i !== r.NONE && n.dispatchEvent(ja) }(t) : function (t) { let e; switch (t.button) { case 0: e = n.mouseButtons.LEFT; break; case 1: e = n.mouseButtons.MIDDLE; break; case 2: e = n.mouseButtons.RIGHT; break; default: e = -1 }switch (e) { case 1: if (!1 === n.enableZoom) return; !function (t) { v.set(t.clientX, t.clientY) }(t), i = r.DOLLY; break; case 0: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === n.enablePan) return; R(t), i = r.PAN } else { if (!1 === n.enableRotate) return; P(t), i = r.ROTATE } break; case 2: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === n.enableRotate) return; P(t), i = r.ROTATE } else { if (!1 === n.enablePan) return; R(t), i = r.PAN } break; default: i = r.NONE }i !== r.NONE && n.dispatchEvent(ja) }(t)) } function k(t) { !1 !== n.enabled && ("touch" === t.pointerType ? function (t) { switch (X(t), i) { case r.TOUCH_ROTATE: if (!1 === n.enableRotate) return; N(t), n.update(); break; case r.TOUCH_PAN: if (!1 === n.enablePan) return; z(t), n.update(); break; case r.TOUCH_DOLLY_PAN: if (!1 === n.enableZoom && !1 === n.enablePan) return; !function (t) { n.enableZoom && F(t), n.enablePan && z(t) }(t), n.update(); break; case r.TOUCH_DOLLY_ROTATE: if (!1 === n.enableZoom && !1 === n.enableRotate) return; !function (t) { n.enableZoom && F(t), n.enableRotate && N(t) }(t), n.update(); break; default: i = r.NONE } }(t) : function (t) { switch (i) { case r.ROTATE: if (!1 === n.enableRotate) return; !function (t) { d.set(t.clientX, t.clientY), f.subVectors(d, h).multiplyScalar(n.rotateSpeed); const e = n.domElement; w(2 * Math.PI * f.x / e.clientHeight), S(2 * Math.PI * f.y / e.clientHeight), h.copy(d), n.update() }(t); break; case r.DOLLY: if (!1 === n.enableZoom) return; !function (t) { _.set(t.clientX, t.clientY), y.subVectors(_, v), y.y > 0 ? C(M()) : y.y < 0 && L(M()), v.copy(_), n.update() }(t); break; case r.PAN: if (!1 === n.enablePan) return; !function (t) { m.set(t.clientX, t.clientY), g.subVectors(m, p).multiplyScalar(n.panSpeed), A(g.x, g.y), p.copy(m), n.update() }(t) } }(t)) } function B(t) { q(t), 0 === x.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", k), n.domElement.removeEventListener("pointerup", B)), n.dispatchEvent(qa), i = r.NONE } function V(t) { q(t) } function G(t) { !1 !== n.enabled && !1 !== n.enableZoom && i === r.NONE && (t.preventDefault(), n.dispatchEvent(ja), function (t) { t.deltaY < 0 ? L(M()) : t.deltaY > 0 && C(M()), n.update() }(t), n.dispatchEvent(qa)) } function W(t) { !1 !== n.enabled && !1 !== n.enablePan && function (t) { let e = !1; switch (t.code) { case n.keys.UP: A(0, n.keyPanSpeed), e = !0; break; case n.keys.BOTTOM: A(0, -n.keyPanSpeed), e = !0; break; case n.keys.LEFT: A(n.keyPanSpeed, 0), e = !0; break; case n.keys.RIGHT: A(-n.keyPanSpeed, 0), e = !0 }e && (t.preventDefault(), n.update()) }(t) } function j(t) { !1 !== n.enabled && t.preventDefault() } function q(t) { delete b[t.pointerId]; for (let e = 0; e < x.length; e++)if (x[e].pointerId == t.pointerId) return void x.splice(e, 1) } function X(t) { let e = b[t.pointerId]; void 0 === e && (e = new H, b[t.pointerId] = e), e.set(t.pageX, t.pageY) } function Y(t) { const e = t.pointerId === x[0].pointerId ? x[1] : x[0]; return b[e.pointerId] } n.domElement.addEventListener("contextmenu", j), n.domElement.addEventListener("pointerdown", U), n.domElement.addEventListener("pointercancel", V), n.domElement.addEventListener("wheel", G, { passive: !1 }), this.update() } } function Ya(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function Za(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var Ka = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), Za(this, "scene", void 0), Za(this, "camera", void 0), Za(this, "renderer", void 0), Za(this, "controls", void 0), Za(this, "dom", void 0), this.dom = e, this.initScenes(), this.setControls() } var e, n; return e = t, (n = [{ key: "initScenes", value: function () { this.scene = new ca, this.camera = new _n(6, window.innerWidth / window.innerHeight, 1, 1e5), this.camera.position.set(200, -100, 0), this.renderer = new la({ alpha: !0, antialias: !0 }), this.renderer.setPixelRatio(2 * window.devicePixelRatio), this.renderer.setSize(window.innerWidth, window.innerHeight), this.dom.appendChild(this.renderer.domElement) } }, { key: "setControls", value: function () { this.controls = new Xa(this.camera, this.renderer.domElement), this.controls.autoRotateSpeed = 3, this.controls.enableDamping = !0, this.controls.dampingFactor = .05, this.controls.enableZoom = !0, this.controls.minDistance = 100, this.controls.maxDistance = 300, this.controls.enablePan = !1 } }]) && Ya(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(), Ja = n(7265); function Qa(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function $a(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var to = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), $a(this, "width", void 0), $a(this, "height", void 0), $a(this, "viewport", void 0), $a(this, "$sizeViewport", void 0), $a(this, "emitter", void 0), this.emitter = new Ja.EventEmitter, this.$sizeViewport = e.dom, this.viewport = { width: 0, height: 0 }, this.resize = this.resize.bind(this), window.addEventListener("resize", this.resize), this.resize() } var e, n; return e = t, (n = [{ key: "$on", value: function (t, e) { this.emitter.on(t, (function () { e() })) } }, { key: "resize", value: function () { this.viewport.width = this.$sizeViewport.offsetWidth, this.viewport.height = this.$sizeViewport.offsetHeight, this.emitter.emit("resize") } }]) && Qa(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(), eo = (n(1249), "./images/earth/"), no = [].map((function (t) { return { name: t, url: eo + t + ".png" } })); no.push({ name: "earth", url: eo + "6.png" }); var ro = { textures: no }; function io(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function ao(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var oo = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), ao(this, "manager", void 0), ao(this, "callback", void 0), ao(this, "textureLoader", void 0), ao(this, "textures", void 0), this.callback = e, this.textures = {}, this.setLoadingManager(), this.loadResources() } var e, n; return e = t, (n = [{ key: "setLoadingManager", value: function () { var t = this; this.manager = new Ra, this.manager.onStart = function () { console.log("开始加载资源文件") }, this.manager.onLoad = function () { t.callback() }, this.manager.onProgress = function (t) { console.log("正在加载：".concat(t)) }, this.manager.onError = function (t) { console.log("加载失败：" + t) } } }, { key: "loadResources", value: function () { var t, e = this; this.textureLoader = new za(this.manager), null === (t = ro.textures) || void 0 === t || t.forEach((function (t) { e.textureLoader.load(t.url, (function (n) { e.textures[t.name] = n })) })) } }]) && io(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(); function so(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function lo(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } n(4197), n(2990), n(8927), n(3105), n(5035), n(4345), n(7174), n(2846), n(4731), n(7209), n(6319), n(8867), n(7789), n(3739), n(9368), n(4483), n(2056), n(3462), n(678), n(7462), n(3824), n(5021), n(2974), n(5016); var co, uo, ho, fo, po, mo, go, vo, _o, yo, xo, bo, Mo, wo, So, To = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, Eo = { duration: .5, overwrite: !1, delay: 0 }, Ao = 1e8, Co = 1e-8, Lo = 2 * Math.PI, Po = Lo / 4, Ro = 0, Do = Math.sqrt, Io = Math.cos, Oo = Math.sin, No = function (t) { return "string" == typeof t }, zo = function (t) { return "function" == typeof t }, Fo = function (t) { return "number" == typeof t }, Uo = function (t) { return void 0 === t }, ko = function (t) { return "object" == typeof t }, Bo = function (t) { return !1 !== t }, Vo = function () { return "undefined" != typeof window }, Go = function (t) { return zo(t) || No(t) }, Ho = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, Wo = Array.isArray, jo = /(?:-?\.?\d|\.)+/gi, qo = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Xo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Yo = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Zo = /[+-]=-?[.\d]+/, Ko = /[^,'"\[\]\s]+/gi, Jo = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Qo = {}, $o = {}, ts = function (t) { return ($o = Cs(t, Qo)) && Ac }, es = function (t, e) { return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()") }, ns = function (t, e) { return !e && console.warn(t) }, rs = function (t, e) { return t && (Qo[t] = e) && $o && ($o[t] = e) || Qo }, is = function () { return 0 }, as = { suppressEvents: !0, isStart: !0 }, os = { suppressEvents: !0 }, ss = {}, ls = [], cs = {}, us = {}, hs = {}, ds = 30, fs = [], ps = "", ms = function (t) { var e, n, r = t[0]; if (ko(r) || zo(r) || (t = [t]), !(e = (r._gsap || {}).harness)) { for (n = fs.length; n-- && !fs[n].targetTest(r);); e = fs[n] } for (n = t.length; n--;)t[n] && (t[n]._gsap || (t[n]._gsap = new Gl(t[n], e))) || t.splice(n, 1); return t }, gs = function (t) { return t._gsap || ms(ol(t))[0]._gsap }, vs = function (t, e, n) { return (n = t[e]) && zo(n) ? t[e]() : Uo(n) && t.getAttribute && t.getAttribute(e) || n }, _s = function (t, e) { return (t = t.split(",")).forEach(e) || t }, ys = function (t) { return Math.round(1e5 * t) / 1e5 || 0 }, xs = function (t) { return Math.round(1e7 * t) / 1e7 || 0 }, bs = function (t, e) { var n = e.charAt(0), r = parseFloat(e.substr(2)); return t = parseFloat(t), "+" === n ? t + r : "-" === n ? t - r : "*" === n ? t * r : t / r }, Ms = function (t, e) { for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n;); return r < n }, ws = function () { var t, e, n = ls.length, r = ls.slice(0); for (cs = {}, ls.length = 0, t = 0; t < n; t++)(e = r[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0) }, Ss = function (t, e, n, r) { ls.length && ws(), t.render(e, n, r || uo), ls.length && ws() }, Ts = function (t) { var e = parseFloat(t); return (e || 0 === e) && (t + "").match(Ko).length < 2 ? e : No(t) ? t.trim() : t }, Es = function (t) { return t }, As = function (t, e) { for (var n in e) n in t || (t[n] = e[n]); return t }, Cs = function (t, e) { for (var n in e) t[n] = e[n]; return t }, Ls = function t(e, n) { for (var r in n) "__proto__" !== r && "constructor" !== r && "prototype" !== r && (e[r] = ko(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r]); return e }, Ps = function (t, e) { var n, r = {}; for (n in t) n in e || (r[n] = t[n]); return r }, Rs = function (t) { var e, n = t.parent || fo, r = t.keyframes ? (e = Wo(t.keyframes), function (t, n) { for (var r in n) r in t || "duration" === r && e || "ease" === r || (t[r] = n[r]) }) : As; if (Bo(t.inherit)) for (; n;)r(t, n.vars.defaults), n = n.parent || n._dp; return t }, Ds = function (t, e, n, r, i) { void 0 === n && (n = "_first"), void 0 === r && (r = "_last"); var a, o = t[r]; if (i) for (a = e[i]; o && o[i] > a;)o = o._prev; return o ? (e._next = o._next, o._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = o, e.parent = e._dp = t, e }, Is = function (t, e, n, r) { void 0 === n && (n = "_first"), void 0 === r && (r = "_last"); var i = e._prev, a = e._next; i ? i._next = a : t[n] === e && (t[n] = a), a ? a._prev = i : t[r] === e && (t[r] = i), e._next = e._prev = e.parent = null }, Os = function (t, e) { t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0 }, Ns = function (t, e) { if (t && (!e || e._end > t._dur || e._start < 0)) for (var n = t; n;)n._dirty = 1, n = n.parent; return t }, zs = function (t) { for (var e = t.parent; e && e.parent;)e._dirty = 1, e.totalDuration(), e = e.parent; return t }, Fs = function (t, e, n, r) { return t._startAt && (uo ? t._startAt.revert(os) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, r)) }, Us = function t(e) { return !e || e._ts && t(e.parent) }, ks = function (t) { return t._repeat ? Bs(t._tTime, t = t.duration() + t._rDelay) * t : 0 }, Bs = function (t, e) { var n = Math.floor(t /= e); return t && n === t ? n - 1 : n }, Vs = function (t, e) { return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur) }, Gs = function (t) { return t._end = xs(t._start + (t._tDur / Math.abs(t._ts || t._rts || Co) || 0)) }, Hs = function (t, e) { var n = t._dp; return n && n.smoothChildTiming && t._ts && (t._start = xs(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Gs(t), n._dirty || Ns(n, t)), t }, Ws = function (t, e) { var n; if ((e._time || e._initted && !e._dur) && (n = Vs(t.rawTime(), e), (!e._dur || nl(0, e.totalDuration(), n) - e._tTime > Co) && e.render(n, !0)), Ns(t, e)._dp && t._initted && t._time >= t._dur && t._ts) { if (t._dur < t.duration()) for (n = t; n._dp;)n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp; t._zTime = -1e-8 } }, js = function (t, e, n, r) { return e.parent && Os(e), e._start = xs((Fo(n) ? n : n || t !== fo ? $s(t, n, e) : t._time) + e._delay), e._end = xs(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Ds(t, e, "_first", "_last", t._sort ? "_start" : 0), Zs(e) || (t._recent = e), r || Ws(t, e), t._ts < 0 && Hs(t, t._tTime), t }, qs = function (t, e) { return (Qo.ScrollTrigger || es("scrollTrigger", e)) && Qo.ScrollTrigger.create(e, t) }, Xs = function (t, e, n, r) { return Kl(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && _o !== Ll.frame ? (ls.push(t), t._lazy = [e, r], 1) : void 0 : 1 }, Ys = function t(e) { var n = e.parent; return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n)) }, Zs = function (t) { var e = t.data; return "isFromStart" === e || "isStart" === e }, Ks = function (t, e, n, r) { var i = t._repeat, a = xs(e) || 0, o = t._tTime / t._tDur; return o && !r && (t._time *= a / t._dur), t._dur = a, t._tDur = i ? i < 0 ? 1e10 : xs(a * (i + 1) + t._rDelay * i) : a, o > 0 && !r ? Hs(t, t._tTime = t._tDur * o) : t.parent && Gs(t), n || Ns(t.parent, t), t }, Js = function (t) { return t instanceof Wl ? Ns(t) : Ks(t, t._dur) }, Qs = { _start: 0, endTime: is, totalDuration: is }, $s = function t(e, n, r) { var i, a, o, s = e.labels, l = e._recent || Qs, c = e.duration() >= Ao ? l.endTime(!1) : e._dur; return No(n) && (isNaN(n) || n in s) ? (a = n.charAt(0), o = "%" === n.substr(-1), i = n.indexOf("="), "<" === a || ">" === a ? (i >= 0 && (n = n.replace(/=/, "")), ("<" === a ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (i < 0 ? l : r).totalDuration() / 100 : 1)) : i < 0 ? (n in s || (s[n] = c), s[n]) : (a = parseFloat(n.charAt(i - 1) + n.substr(i + 1)), o && r && (a = a / 100 * (Wo(r) ? r[0] : r).totalDuration()), i > 1 ? t(e, n.substr(0, i - 1), r) + a : c + a)) : null == n ? c : +n }, tl = function (t, e, n) { var r, i, a = Fo(e[1]), o = (a ? 2 : 1) + (t < 2 ? 0 : 1), s = e[o]; if (a && (s.duration = e[1]), s.parent = n, t) { for (r = s, i = n; i && !("immediateRender" in r);)r = i.vars.defaults || {}, i = Bo(i.vars.inherit) && i.parent; s.immediateRender = Bo(r.immediateRender), t < 2 ? s.runBackwards = 1 : s.startAt = e[o - 1] } return new ec(e[0], s, e[o + 1]) }, el = function (t, e) { return t || 0 === t ? e(t) : e }, nl = function (t, e, n) { return n < t ? t : n > e ? e : n }, rl = function (t, e) { return No(t) && (e = Jo.exec(t)) ? e[1] : "" }, il = [].slice, al = function (t, e) { return t && ko(t) && "length" in t && (!e && !t.length || t.length - 1 in t && ko(t[0])) && !t.nodeType && t !== po }, ol = function (t, e, n) { return ho && !e && ho.selector ? ho.selector(t) : !No(t) || n || !mo && Pl() ? Wo(t) ? function (t, e, n) { return void 0 === n && (n = []), t.forEach((function (t) { var r; return No(t) && !e || al(t, 1) ? (r = n).push.apply(r, ol(t)) : n.push(t) })) || n }(t, n) : al(t) ? il.call(t, 0) : t ? [t] : [] : il.call((e || go).querySelectorAll(t), 0) }, sl = function (t) { return t = ol(t)[0] || ns("Invalid scope") || {}, function (e) { var n = t.current || t.nativeElement || t; return ol(e, n.querySelectorAll ? n : n === t ? ns("Invalid scope") || go.createElement("div") : t) } }, ll = function (t) { return t.sort((function () { return .5 - Math.random() })) }, cl = function (t) { if (zo(t)) return t; var e = ko(t) ? t : { each: t }, n = Fl(e.ease), r = e.from || 0, i = parseFloat(e.base) || 0, a = {}, o = r > 0 && r < 1, s = isNaN(r) || o, l = e.axis, c = r, u = r; return No(r) ? c = u = { center: .5, edges: .5, end: 1 }[r] || 0 : !o && s && (c = r[0], u = r[1]), function (t, o, h) { var d, f, p, m, g, v, _, y, x, b = (h || e).length, M = a[b]; if (!M) { if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, Ao])[1])) { for (_ = -Ao; _ < (_ = h[x++].getBoundingClientRect().left) && x < b;); x-- } for (M = a[b] = [], d = s ? Math.min(x, b) * c - .5 : r % x, f = x === Ao ? 0 : s ? b * u / x - .5 : r / x | 0, _ = 0, y = Ao, v = 0; v < b; v++)p = v % x - d, m = f - (v / x | 0), M[v] = g = l ? Math.abs("y" === l ? m : p) : Do(p * p + m * m), g > _ && (_ = g), g < y && (y = g); "random" === r && ll(M), M.max = _ - y, M.min = y, M.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === r ? -1 : 1), M.b = b < 0 ? i - b : i, M.u = rl(e.amount || e.each) || 0, n = n && b < 0 ? Nl(n) : n } return b = (M[t] - M.min) / M.max || 0, xs(M.b + (n ? n(b) : b) * M.v) + M.u } }, ul = function (t) { var e = Math.pow(10, ((t + "").split(".")[1] || "").length); return function (n) { var r = xs(Math.round(parseFloat(n) / t) * t * e); return (r - r % 1) / e + (Fo(n) ? 0 : rl(n)) } }, hl = function (t, e) { var n, r, i = Wo(t); return !i && ko(t) && (n = i = t.radius || Ao, t.values ? (t = ol(t.values), (r = !Fo(t[0])) && (n *= n)) : t = ul(t.increment)), el(e, i ? zo(t) ? function (e) { return r = t(e), Math.abs(r - e) <= n ? r : e } : function (e) { for (var i, a, o = parseFloat(r ? e.x : e), s = parseFloat(r ? e.y : 0), l = Ao, c = 0, u = t.length; u--;)(i = r ? (i = t[u].x - o) * i + (a = t[u].y - s) * a : Math.abs(t[u] - o)) < l && (l = i, c = u); return c = !n || l <= n ? t[c] : e, r || c === e || Fo(e) ? c : c + rl(e) } : ul(t)) }, dl = function (t, e, n, r) { return el(Wo(t) ? !e : !0 === n ? !!(n = 0) : !r, (function () { return Wo(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * r) / r })) }, fl = function (t, e, n) { return el(n, (function (n) { return t[~~e(n)] })) }, pl = function (t) { for (var e, n, r, i, a = 0, o = ""; ~(e = t.indexOf("random(", a));)r = t.indexOf(")", e), i = "[" === t.charAt(e + 7), n = t.substr(e + 7, r - e - 7).match(i ? Ko : jo), o += t.substr(a, e - a) + dl(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5), a = r + 1; return o + t.substr(a, t.length - a) }, ml = function (t, e, n, r, i) { var a = e - t, o = r - n; return el(i, (function (e) { return n + ((e - t) / a * o || 0) })) }, gl = function (t, e, n) { var r, i, a, o = t.labels, s = Ao; for (r in o) (i = o[r] - e) < 0 == !!n && i && s > (i = Math.abs(i)) && (a = r, s = i); return a }, vl = function (t, e, n) { var r, i, a, o = t.vars, s = o[e], l = ho, c = t._ctx; if (s) return r = o[e + "Params"], i = o.callbackScope || t, n && ls.length && ws(), c && (ho = c), a = r ? s.apply(i, r) : s.call(i), ho = l, a }, _l = function (t) { return Os(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && vl(t, "onInterrupt"), t }, yl = function (t) { var e = (t = !t.name && t.default || t).name, n = zo(t), r = e && !n && t.init ? function () { this._props = [] } : t, i = { init: is, render: uc, add: Yl, kill: dc, modifier: hc, rawVars: 0 }, a = { targetTest: 0, get: 0, getSetter: oc, aliases: {}, register: 0 }; if (Pl(), t !== r) { if (us[e]) return; As(r, As(Ps(t, i), a)), Cs(r.prototype, Cs(i, Ps(t, a))), us[r.prop = e] = r, t.targetTest && (fs.push(r), ss[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin" } rs(e, r), t.register && t.register(Ac, r, mc) }, xl = 255, bl = { aqua: [0, xl, xl], lime: [0, xl, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, xl], navy: [0, 0, 128], white: [xl, xl, xl], olive: [128, 128, 0], yellow: [xl, xl, 0], orange: [xl, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [xl, 0, 0], pink: [xl, 192, 203], cyan: [0, xl, xl], transparent: [xl, xl, xl, 0] }, Ml = function (t, e, n) { return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * xl + .5 | 0 }, wl = function (t, e, n) { var r, i, a, o, s, l, c, u, h, d, f = t ? Fo(t) ? [t >> 16, t >> 8 & xl, t & xl] : 0 : bl.black; if (!f) { if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), bl[t]) f = bl[t]; else if ("#" === t.charAt(0)) { if (t.length < 6 && (r = t.charAt(1), i = t.charAt(2), a = t.charAt(3), t = "#" + r + r + i + i + a + a + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(f = parseInt(t.substr(1, 6), 16)) >> 16, f >> 8 & xl, f & xl, parseInt(t.substr(7), 16) / 255]; f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & xl, t & xl] } else if ("hsl" === t.substr(0, 3)) if (f = d = t.match(jo), e) { if (~t.indexOf("=")) return f = t.match(qo), n && f.length < 4 && (f[3] = 1), f } else o = +f[0] % 360 / 360, s = +f[1] / 100, r = 2 * (l = +f[2] / 100) - (i = l <= .5 ? l * (s + 1) : l + s - l * s), f.length > 3 && (f[3] *= 1), f[0] = Ml(o + 1 / 3, r, i), f[1] = Ml(o, r, i), f[2] = Ml(o - 1 / 3, r, i); else f = t.match(jo) || bl.transparent; f = f.map(Number) } return e && !d && (r = f[0] / xl, i = f[1] / xl, a = f[2] / xl, l = ((c = Math.max(r, i, a)) + (u = Math.min(r, i, a))) / 2, c === u ? o = s = 0 : (h = c - u, s = l > .5 ? h / (2 - c - u) : h / (c + u), o = c === r ? (i - a) / h + (i < a ? 6 : 0) : c === i ? (a - r) / h + 2 : (r - i) / h + 4, o *= 60), f[0] = ~~(o + .5), f[1] = ~~(100 * s + .5), f[2] = ~~(100 * l + .5)), n && f.length < 4 && (f[3] = 1), f }, Sl = function (t) { var e = [], n = [], r = -1; return t.split(El).forEach((function (t) { var i = t.match(Xo) || []; e.push.apply(e, i), n.push(r += i.length + 1) })), e.c = n, e }, Tl = function (t, e, n) { var r, i, a, o, s = "", l = (t + s).match(El), c = e ? "hsla(" : "rgba(", u = 0; if (!l) return t; if (l = l.map((function (t) { return (t = wl(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")" })), n && (a = Sl(t), (r = n.c).join(s) !== a.c.join(s))) for (o = (i = t.replace(El, "1").split(Xo)).length - 1; u < o; u++)s += i[u] + (~r.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (a.length ? a : l.length ? l : n).shift()); if (!i) for (o = (i = t.split(El)).length - 1; u < o; u++)s += i[u] + l[u]; return s + i[o] }, El = function () { var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b"; for (t in bl) e += "|" + t + "\\b"; return new RegExp(e + ")", "gi") }(), Al = /hsl[a]?\(/, Cl = function (t) { var e, n = t.join(" "); if (El.lastIndex = 0, El.test(n)) return e = Al.test(n), t[1] = Tl(t[1], e), t[0] = Tl(t[0], e, Sl(t[1])), !0 }, Ll = function () { var t, e, n, r, i, a, o = Date.now, s = 500, l = 33, c = o(), u = c, h = 1e3 / 240, d = h, f = [], p = function n(p) { var m, g, v, _, y = o() - u, x = !0 === p; if (y > s && (c += y - l), ((m = (v = (u += y) - c) - d) > 0 || x) && (_ = ++r.frame, i = v - 1e3 * r.time, r.time = v /= 1e3, d += m + (m >= h ? 4 : h - m), g = 1), x || (t = e(n)), g) for (a = 0; a < f.length; a++)f[a](v, i, _, p) }; return r = { time: 0, frame: 0, tick: function () { p(!0) }, deltaRatio: function (t) { return i / (1e3 / (t || 60)) }, wake: function () { vo && (!mo && Vo() && (po = mo = window, go = po.document || {}, Qo.gsap = Ac, (po.gsapVersions || (po.gsapVersions = [])).push(Ac.version), ts($o || po.GreenSockGlobals || !po.gsap && po || {}), n = po.requestAnimationFrame), t && r.sleep(), e = n || function (t) { return setTimeout(t, d - 1e3 * r.time + 1 | 0) }, xo = 1, p(2)) }, sleep: function () { (n ? po.cancelAnimationFrame : clearTimeout)(t), xo = 0, e = is }, lagSmoothing: function (t, e) { s = t || 1e8, l = Math.min(e, s, 0) }, fps: function (t) { h = 1e3 / (t || 240), d = 1e3 * r.time + h }, add: function (t, e, n) { var i = e ? function (e, n, a, o) { t(e, n, a, o), r.remove(i) } : t; return r.remove(t), f[n ? "unshift" : "push"](i), Pl(), i }, remove: function (t, e) { ~(e = f.indexOf(t)) && f.splice(e, 1) && a >= e && a-- }, _listeners: f } }(), Pl = function () { return !xo && Ll.wake() }, Rl = {}, Dl = /^[\d.\-M][\d.\-,\s]/, Il = /["']/g, Ol = function (t) { for (var e, n, r, i = {}, a = t.substr(1, t.length - 3).split(":"), o = a[0], s = 1, l = a.length; s < l; s++)n = a[s], e = s !== l - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), i[o] = isNaN(r) ? r.replace(Il, "").trim() : +r, o = n.substr(e + 1).trim(); return i }, Nl = function (t) { return function (e) { return 1 - t(1 - e) } }, zl = function t(e, n) { for (var r, i = e._first; i;)i instanceof Wl ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = n)), i = i._next }, Fl = function (t, e) { return t && (zo(t) ? t : Rl[t] || function (t) { var e, n, r, i, a = (t + "").split("("), o = Rl[a[0]]; return o && a.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [Ol(a[1])] : (e = t, n = e.indexOf("(") + 1, r = e.indexOf(")"), i = e.indexOf("(", n), e.substring(n, ~i && i < r ? e.indexOf(")", r + 1) : r)).split(",").map(Ts)) : Rl._CE && Dl.test(t) ? Rl._CE("", t) : o }(t)) || e }, Ul = function (t, e, n, r) { void 0 === n && (n = function (t) { return 1 - e(1 - t) }), void 0 === r && (r = function (t) { return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2 }); var i, a = { easeIn: e, easeOut: n, easeInOut: r }; return _s(t, (function (t) { for (var e in Rl[t] = Qo[t] = a, Rl[i = t.toLowerCase()] = n, a) Rl[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Rl[t + "." + e] = a[e] })), a }, kl = function (t) { return function (e) { return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2 } }, Bl = function t(e, n, r) { var i = n >= 1 ? n : 1, a = (r || (e ? .3 : .45)) / (n < 1 ? n : 1), o = a / Lo * (Math.asin(1 / i) || 0), s = function (t) { return 1 === t ? 1 : i * Math.pow(2, -10 * t) * Oo((t - o) * a) + 1 }, l = "out" === e ? s : "in" === e ? function (t) { return 1 - s(1 - t) } : kl(s); return a = Lo / a, l.config = function (n, r) { return t(e, n, r) }, l }, Vl = function t(e, n) { void 0 === n && (n = 1.70158); var r = function (t) { return t ? --t * t * ((n + 1) * t + n) + 1 : 0 }, i = "out" === e ? r : "in" === e ? function (t) { return 1 - r(1 - t) } : kl(r); return i.config = function (n) { return t(e, n) }, i }; _s("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) { var n = e < 5 ? e + 1 : e; Ul(t + ",Power" + (n - 1), e ? function (t) { return Math.pow(t, n) } : function (t) { return t }, (function (t) { return 1 - Math.pow(1 - t, n) }), (function (t) { return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2 })) })), Rl.Linear.easeNone = Rl.none = Rl.Linear.easeIn, Ul("Elastic", Bl("in"), Bl("out"), Bl()), bo = 7.5625, wo = 1 / (Mo = 2.75), Ul("Bounce", (function (t) { return 1 - So(1 - t) }), So = function (t) { return t < wo ? bo * t * t : t < .7272727272727273 ? bo * Math.pow(t - 1.5 / Mo, 2) + .75 : t < .9090909090909092 ? bo * (t -= 2.25 / Mo) * t + .9375 : bo * Math.pow(t - 2.625 / Mo, 2) + .984375 }), Ul("Expo", (function (t) { return t ? Math.pow(2, 10 * (t - 1)) : 0 })), Ul("Circ", (function (t) { return -(Do(1 - t * t) - 1) })), Ul("Sine", (function (t) { return 1 === t ? 1 : 1 - Io(t * Po) })), Ul("Back", Vl("in"), Vl("out"), Vl()), Rl.SteppedEase = Rl.steps = Qo.SteppedEase = { config: function (t, e) { void 0 === t && (t = 1); var n = 1 / t, r = t + (e ? 0 : 1), i = e ? 1 : 0; return function (t) { return ((r * nl(0, .99999999, t) | 0) + i) * n } } }, Eo.ease = Rl["quad.out"], _s("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) { return ps += t + "," + t + "Params," })); var Gl = function (t, e) { this.id = Ro++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : vs, this.set = e ? e.getSetter : oc }, Hl = function () { function t(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ks(this, +t.duration, 1, 1), this.data = t.data, ho && (this._ctx = ho, ho.data.push(this)), xo || Ll.wake() } var e = t.prototype; return e.delay = function (t) { return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay }, e.duration = function (t) { return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur }, e.totalDuration = function (t) { return arguments.length ? (this._dirty = 0, Ks(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (t, e) { if (Pl(), !arguments.length) return this._tTime; var n = this._dp; if (n && n.smoothChildTiming && this._ts) { for (Hs(this, t), !n._dp || n.parent || Ws(n, this); n && n.parent;)n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && js(this._dp, this, this._start - this._delay) } return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === Co || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), Ss(this, t, e)), this }, e.time = function (t, e) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + ks(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time }, e.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, e.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + ks(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, e.iteration = function (t, e) { var n = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Bs(this._tTime, n) + 1 : 1 }, e.timeScale = function (t) { if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts; if (this._rts === t) return this; var e = this.parent && this._ts ? Vs(this.parent._time, this) : this._tTime; return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, this.totalTime(nl(-this._delay, this._tDur, e), !0), Gs(this), zs(this) }, e.paused = function (t) { return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Pl(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== Co && (this._tTime -= Co)))), this) : this._ps }, e.startTime = function (t) { if (arguments.length) { this._start = t; var e = this.parent || this._dp; return e && (e._sort || !this.parent) && js(e, this, t - this._delay), this } return this._start }, e.endTime = function (t) { return this._start + (Bo(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, e.rawTime = function (t) { var e = this.parent || this._dp; return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Vs(e.rawTime(t), this) : this._tTime : this._tTime }, e.revert = function (t) { void 0 === t && (t = os); var e = uo; return uo = t, this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents), "nested" !== this.data && Os(this), uo = e, this }, e.globalTime = function (t) { for (var e = this, n = arguments.length ? t : e.rawTime(); e;)n = e._start + n / (e._ts || 1), e = e._dp; return !this.parent && this.vars.immediateRender ? -1 : n }, e.repeat = function (t) { return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Js(this)) : -2 === this._repeat ? 1 / 0 : this._repeat }, e.repeatDelay = function (t) { if (arguments.length) { var e = this._time; return this._rDelay = t, Js(this), e ? this.time(e) : this } return this._rDelay }, e.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, e.seek = function (t, e) { return this.totalTime($s(this, t), Bo(e)) }, e.restart = function (t, e) { return this.play().totalTime(t ? -this._delay : 0, Bo(e)) }, e.play = function (t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, e.reverse = function (t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, e.pause = function (t, e) { return null != t && this.seek(t, e), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (t) { return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = this._act = 0, this._zTime = -1e-8, this }, e.isActive = function () { var t, e = this.parent || this._dp, n = this._start; return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - Co)) }, e.eventCallback = function (t, e, n) { var r = this.vars; return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t] }, e.then = function (t) { var e = this; return new Promise((function (n) { var r = zo(t) ? t : Es, i = function () { var t = e.then; e.then = null, zo(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t }; e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i })) }, e.kill = function () { _l(this) }, t }(); As(Hl.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 }); var Wl = function (t) { function e(e, n) { var r; return void 0 === e && (e = {}), (r = t.call(this, e) || this).labels = {}, r.smoothChildTiming = !!e.smoothChildTiming, r.autoRemoveChildren = !!e.autoRemoveChildren, r._sort = Bo(e.sortChildren), fo && js(e.parent || fo, so(r), n), e.reversed && r.reverse(), e.paused && r.paused(!0), e.scrollTrigger && qs(so(r), e.scrollTrigger), r } lo(e, t); var n = e.prototype; return n.to = function (t, e, n) { return tl(0, arguments, this), this }, n.from = function (t, e, n) { return tl(1, arguments, this), this }, n.fromTo = function (t, e, n, r) { return tl(2, arguments, this), this }, n.set = function (t, e, n) { return e.duration = 0, e.parent = this, Rs(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new ec(t, e, $s(this, n), 1), this }, n.call = function (t, e, n) { return js(this, ec.delayedCall(0, t, e), n) }, n.staggerTo = function (t, e, n, r, i, a, o) { return n.duration = e, n.stagger = n.stagger || r, n.onComplete = a, n.onCompleteParams = o, n.parent = this, new ec(t, n, $s(this, i)), this }, n.staggerFrom = function (t, e, n, r, i, a, o) { return n.runBackwards = 1, Rs(n).immediateRender = Bo(n.immediateRender), this.staggerTo(t, e, n, r, i, a, o) }, n.staggerFromTo = function (t, e, n, r, i, a, o, s) { return r.startAt = n, Rs(r).immediateRender = Bo(r.immediateRender), this.staggerTo(t, e, r, i, a, o, s) }, n.render = function (t, e, n) { var r, i, a, o, s, l, c, u, h, d, f, p, m = this._time, g = this._dirty ? this.totalDuration() : this._tDur, v = this._dur, _ = t <= 0 ? 0 : xs(t), y = this._zTime < 0 != t < 0 && (this._initted || !v); if (this !== fo && _ > g && t >= 0 && (_ = g), _ !== this._tTime || n || y) { if (m !== this._time && v && (_ += this._time - m, t += this._time - m), r = _, h = this._start, l = !(u = this._ts), y && (v || (m = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) { if (f = this._yoyo, s = v + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * s + t, e, n); if (r = xs(_ % s), _ === g ? (o = this._repeat, r = v) : ((o = ~~(_ / s)) && o === _ / s && (r = v, o--), r > v && (r = v)), d = Bs(this._tTime, s), !m && this._tTime && d !== o && (d = o), f && 1 & o && (r = v - r, p = 1), o !== d && !this._lock) { var x = f && 1 & d, b = x === (f && 1 & o); if (o < d && (x = !x), m = x ? 0 : v, this._lock = 1, this.render(m || (p ? 0 : xs(o * s)), e, !v)._lock = 0, this._tTime = _, !e && this.parent && vl(this, "onRepeat"), this.vars.repeatRefresh && !p && (this.invalidate()._lock = 1), m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (v = this._dur, g = this._tDur, b && (this._lock = 2, m = x ? v : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !p && this.invalidate()), this._lock = 0, !this._ts && !l) return this; zl(this, p) } } if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (t, e, n) { var r; if (n > e) for (r = t._first; r && r._start <= n;) { if ("isPause" === r.data && r._start > e) return r; r = r._next } else for (r = t._last; r && r._start >= n;) { if ("isPause" === r.data && r._start < e) return r; r = r._prev } }(this, xs(m), xs(r)), c && (_ -= r - (r = c._start))), this._tTime = _, this._time = r, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, m = 0), !m && r && !e && (vl(this, "onStart"), this._tTime !== _)) return this; if (r >= m && t >= 0) for (i = this._first; i;) { if (a = i._next, (i._act || r >= i._start) && i._ts && c !== i) { if (i.parent !== this) return this.render(t, e, n); if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) { c = 0, a && (_ += this._zTime = -1e-8); break } } i = a } else { n = n || uo, i = this._last; for (var M = t < 0 ? t : r; i;) { if (a = i._prev, (i._act || M <= i._end) && i._ts && c !== i) { if (i.parent !== this) return this.render(t, e, n); if (i.render(i._ts > 0 ? (M - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (M - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) { c = 0, a && (_ += this._zTime = M ? -1e-8 : Co); break } } i = a } } if (c && !e && (this.pause(), c.render(r >= m ? 0 : -1e-8)._zTime = r >= m ? 1 : -1, this._ts)) return this._start = h, Gs(this), this.render(t, e, n); this._onUpdate && !e && vl(this, "onUpdate", !0), (_ === g && this._tTime >= this.totalDuration() || !_ && m) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !v) && (_ === g && this._ts > 0 || !_ && this._ts < 0) && Os(this, 1), e || t < 0 && !m || !_ && !m && g || (vl(this, _ === g && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < g && this.timeScale() > 0) && this._prom()))) } return this }, n.add = function (t, e) { var n = this; if (Fo(e) || (e = $s(this, e, t)), !(t instanceof Hl)) { if (Wo(t)) return t.forEach((function (t) { return n.add(t, e) })), this; if (No(t)) return this.addLabel(t, e); if (!zo(t)) return this; t = ec.delayedCall(0, t) } return this !== t ? js(this, t, e) : this }, n.getChildren = function (t, e, n, r) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -Ao); for (var i = [], a = this._first; a;)a._start >= r && (a instanceof ec ? e && i.push(a) : (n && i.push(a), t && i.push.apply(i, a.getChildren(!0, e, n)))), a = a._next; return i }, n.getById = function (t) { for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)if (e[n].vars.id === t) return e[n] }, n.remove = function (t) { return No(t) ? this.removeLabel(t) : zo(t) ? this.killTweensOf(t) : (Is(this, t), t === this._recent && (this._recent = this._last), Ns(this)) }, n.totalTime = function (e, n) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = xs(Ll.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime }, n.addLabel = function (t, e) { return this.labels[t] = $s(this, e), this }, n.removeLabel = function (t) { return delete this.labels[t], this }, n.addPause = function (t, e, n) { var r = ec.delayedCall(0, e || is, n); return r.data = "isPause", this._hasPause = 1, js(this, r, $s(this, t)) }, n.removePause = function (t) { var e = this._first; for (t = $s(this, t); e;)e._start === t && "isPause" === e.data && Os(e), e = e._next }, n.killTweensOf = function (t, e, n) { for (var r = this.getTweensOf(t, n), i = r.length; i--;)jl !== r[i] && r[i].kill(t, e); return this }, n.getTweensOf = function (t, e) { for (var n, r = [], i = ol(t), a = this._first, o = Fo(e); a;)a instanceof ec ? Ms(a._targets, i) && (o ? (!jl || a._initted && a._ts) && a.globalTime(0) <= e && a.globalTime(a.totalDuration()) > e : !e || a.isActive()) && r.push(a) : (n = a.getTweensOf(i, e)).length && r.push.apply(r, n), a = a._next; return r }, n.tweenTo = function (t, e) { e = e || {}; var n, r = this, i = $s(r, t), a = e, o = a.startAt, s = a.onStart, l = a.onStartParams, c = a.immediateRender, u = ec.to(r, As({ ease: e.ease || "none", lazy: !1, immediateRender: !1, time: i, overwrite: "auto", duration: e.duration || Math.abs((i - (o && "time" in o ? o.time : r._time)) / r.timeScale()) || Co, onStart: function () { if (r.pause(), !n) { var t = e.duration || Math.abs((i - (o && "time" in o ? o.time : r._time)) / r.timeScale()); u._dur !== t && Ks(u, t, 0, 1).render(u._time, !0, !0), n = 1 } s && s.apply(u, l || []) } }, e)); return c ? u.render(0) : u }, n.tweenFromTo = function (t, e, n) { return this.tweenTo(e, As({ startAt: { time: $s(this, t) } }, n)) }, n.recent = function () { return this._recent }, n.nextLabel = function (t) { return void 0 === t && (t = this._time), gl(this, $s(this, t)) }, n.previousLabel = function (t) { return void 0 === t && (t = this._time), gl(this, $s(this, t), 1) }, n.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + Co) }, n.shiftChildren = function (t, e, n) { void 0 === n && (n = 0); for (var r, i = this._first, a = this.labels; i;)i._start >= n && (i._start += t, i._end += t), i = i._next; if (e) for (r in a) a[r] >= n && (a[r] += t); return Ns(this) }, n.invalidate = function () { var e = this._first; for (this._lock = 0; e;)e.invalidate(), e = e._next; return t.prototype.invalidate.call(this) }, n.clear = function (t) { void 0 === t && (t = !0); for (var e, n = this._first; n;)e = n._next, this.remove(n), n = e; return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Ns(this) }, n.totalDuration = function (t) { var e, n, r, i = 0, a = this, o = a._last, s = Ao; if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -t : t)); if (a._dirty) { for (r = a.parent; o;)e = o._prev, o._dirty && o.totalDuration(), (n = o._start) > s && a._sort && o._ts && !a._lock ? (a._lock = 1, js(a, o, n - o._delay, 1)._lock = 0) : s = n, n < 0 && o._ts && (i -= n, (!r && !a._dp || r && r.smoothChildTiming) && (a._start += n / a._ts, a._time -= n, a._tTime -= n), a.shiftChildren(-n, !1, -Infinity), s = 0), o._end > i && o._ts && (i = o._end), o = e; Ks(a, a === fo && a._time > i ? a._time : i, 1, 1), a._dirty = 0 } return a._tDur }, e.updateRoot = function (t) { if (fo._ts && (Ss(fo, Vs(t, fo)), _o = Ll.frame), Ll.frame >= ds) { ds += To.autoSleep || 120; var e = fo._first; if ((!e || !e._ts) && To.autoSleep && Ll._listeners.length < 2) { for (; e && !e._ts;)e = e._next; e || Ll.sleep() } } }, e }(Hl); As(Wl.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var jl, ql, Xl = function (t, e, n, r, i, a, o) { var s, l, c, u, h, d, f, p, m = new mc(this._pt, t, e, 0, 1, cc, null, i), g = 0, v = 0; for (m.b = n, m.e = r, n += "", (f = ~(r += "").indexOf("random(")) && (r = pl(r)), a && (a(p = [n, r], t, e), n = p[0], r = p[1]), l = n.match(Yo) || []; s = Yo.exec(r);)u = s[0], h = r.substring(g, s.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = { _next: m._pt, p: h || 1 === v ? h : ",", s: d, c: "=" === u.charAt(1) ? bs(d, u) - d : parseFloat(u) - d, m: c && c < 4 ? Math.round : 0 }, g = Yo.lastIndex); return m.c = g < r.length ? r.substring(g, r.length) : "", m.fp = o, (Zo.test(r) || f) && (m.e = 0), this._pt = m, m }, Yl = function (t, e, n, r, i, a, o, s, l, c) { zo(r) && (r = r(i || 0, t, a)); var u, h = t[e], d = "get" !== n ? n : zo(h) ? l ? t[e.indexOf("set") || !zo(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h, f = zo(h) ? l ? ic : rc : nc; if (No(r) && (~r.indexOf("random(") && (r = pl(r)), "=" === r.charAt(1) && ((u = bs(d, r) + (rl(d) || 0)) || 0 === u) && (r = u)), !c || d !== r || ql) return isNaN(d * r) || "" === r ? (!h && !(e in t) && es(e, r), Xl.call(this, t, e, d, r, f, s || To.stringFilter, l)) : (u = new mc(this._pt, t, e, +d || 0, r - (d || 0), "boolean" == typeof h ? lc : sc, 0, f), l && (u.fp = l), o && u.modifier(o, this, t), this._pt = u) }, Zl = function (t, e, n, r, i, a) { var o, s, l, c; if (us[t] && !1 !== (o = new us[t]).init(i, o.rawVars ? e[t] : function (t, e, n, r, i) { if (zo(t) && (t = Ql(t, i, e, n, r)), !ko(t) || t.style && t.nodeType || Wo(t) || Ho(t)) return No(t) ? Ql(t, i, e, n, r) : t; var a, o = {}; for (a in t) o[a] = Ql(t[a], i, e, n, r); return o }(e[t], r, i, a, n), n, r, a) && (n._pt = s = new mc(n._pt, i, t, 0, 1, o.render, o, 0, o.priority), n !== yo)) for (l = n._ptLookup[n._targets.indexOf(i)], c = o._props.length; c--;)l[o._props[c]] = s; return o }, Kl = function t(e, n) { var r, i, a, o, s, l, c, u, h, d, f, p, m, g = e.vars, v = g.ease, _ = g.startAt, y = g.immediateRender, x = g.lazy, b = g.onUpdate, M = g.onUpdateParams, w = g.callbackScope, S = g.runBackwards, T = g.yoyoEase, E = g.keyframes, A = g.autoRevert, C = e._dur, L = e._startAt, P = e._targets, R = e.parent, D = R && "nested" === R.data ? R.parent._targets : P, I = "auto" === e._overwrite && !co, O = e.timeline; if (O && (!E || !v) && (v = "none"), e._ease = Fl(v, Eo.ease), e._yEase = T ? Nl(Fl(!0 === T ? v : T, Eo.ease)) : 0, T && e._yoyo && !e._repeat && (T = e._yEase, e._yEase = e._ease, e._ease = T), e._from = !O && !!g.runBackwards, !O || E && !g.stagger) { if (p = (u = P[0] ? gs(P[0]).harness : 0) && g[u.prop], r = Ps(g, ss), L && (L.revert(S && C ? os : as), L._lazy = 0), _) { if (Os(e._startAt = ec.set(P, As({ data: "isStart", overwrite: !1, parent: R, immediateRender: !0, lazy: Bo(x), startAt: null, delay: 0, onUpdate: b, onUpdateParams: M, callbackScope: w, stagger: 0 }, _))), n < 0 && (uo || !y && !A) && e._startAt.revert(os), y && C && n <= 0) return void (n && (e._zTime = n)) } else if (S && C && !L) if (n && (y = !1), a = As({ overwrite: !1, data: "isFromStart", lazy: y && Bo(x), immediateRender: y, stagger: 0, parent: R }, r), p && (a[u.prop] = p), Os(e._startAt = ec.set(P, a)), n < 0 && (uo ? e._startAt.revert(os) : e._startAt.render(-1, !0)), e._zTime = n, y) { if (!n) return } else t(e._startAt, Co); for (e._pt = e._ptCache = 0, x = C && Bo(x) || x && !C, i = 0; i < P.length; i++) { if (c = (s = P[i])._gsap || ms(P)[i]._gsap, e._ptLookup[i] = d = {}, cs[c.id] && ls.length && ws(), f = D === P ? i : D.indexOf(s), u && !1 !== (h = new u).init(s, p || r, e, f, D) && (e._pt = o = new mc(e._pt, s, h.name, 0, 1, h.render, h, 0, h.priority), h._props.forEach((function (t) { d[t] = o })), h.priority && (l = 1)), !u || p) for (a in r) us[a] && (h = Zl(a, r, e, f, s, D)) ? h.priority && (l = 1) : d[a] = o = Yl.call(e, s, a, "get", r[a], f, D, 0, g.stringFilter); e._op && e._op[i] && e.kill(s, e._op[i]), I && e._pt && (jl = e, fo.killTweensOf(s, d, e.globalTime(n)), m = !e.parent, jl = 0), e._pt && x && (cs[c.id] = 1) } l && pc(e), e._onInit && e._onInit(e) } e._onUpdate = b, e._initted = (!e._op || e._pt) && !m, E && n <= 0 && O.render(Ao, !0, !0) }, Jl = function (t, e, n, r) { var i, a, o = e.ease || r || "power1.inOut"; if (Wo(e)) a = n[t] || (n[t] = []), e.forEach((function (t, n) { return a.push({ t: n / (e.length - 1) * 100, v: t, e: o }) })); else for (i in e) a = n[i] || (n[i] = []), "ease" === i || a.push({ t: parseFloat(t), v: e[i], e: o }) }, Ql = function (t, e, n, r, i) { return zo(t) ? t.call(e, n, r, i) : No(t) && ~t.indexOf("random(") ? pl(t) : t }, $l = ps + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", tc = {}; _s($l + ",id,stagger,delay,duration,paused,scrollTrigger", (function (t) { return tc[t] = 1 })); var ec = function (t) { function e(e, n, r, i) { var a; "number" == typeof n && (r.duration = n, n = r, r = null); var o, s, l, c, u, h, d, f, p = (a = t.call(this, i ? n : Rs(n)) || this).vars, m = p.duration, g = p.delay, v = p.immediateRender, _ = p.stagger, y = p.overwrite, x = p.keyframes, b = p.defaults, M = p.scrollTrigger, w = p.yoyoEase, S = n.parent || fo, T = (Wo(e) || Ho(e) ? Fo(e[0]) : "length" in n) ? [e] : ol(e); if (a._targets = T.length ? ms(T) : ns("GSAP target " + e + " not found. https://greensock.com", !To.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = y, x || _ || Go(m) || Go(g)) { if (n = a.vars, (o = a.timeline = new Wl({ data: "nested", defaults: b || {} })).kill(), o.parent = o._dp = so(a), o._start = 0, _ || Go(m) || Go(g)) { if (c = T.length, d = _ && cl(_), ko(_)) for (u in _) ~$l.indexOf(u) && (f || (f = {}), f[u] = _[u]); for (s = 0; s < c; s++)(l = Ps(n, tc)).stagger = 0, w && (l.yoyoEase = w), f && Cs(l, f), h = T[s], l.duration = +Ql(m, so(a), s, h, T), l.delay = (+Ql(g, so(a), s, h, T) || 0) - a._delay, !_ && 1 === c && l.delay && (a._delay = g = l.delay, a._start += g, l.delay = 0), o.to(h, l, d ? d(s, h, T) : 0), o._ease = Rl.none; o.duration() ? m = g = 0 : a.timeline = 0 } else if (x) { Rs(As(o.vars.defaults, { ease: "none" })), o._ease = Fl(x.ease || n.ease || "none"); var E, A, C, L = 0; if (Wo(x)) x.forEach((function (t) { return o.to(T, t, ">") })), o.duration(); else { for (u in l = {}, x) "ease" === u || "easeEach" === u || Jl(u, x[u], l, x.easeEach); for (u in l) for (E = l[u].sort((function (t, e) { return t.t - e.t })), L = 0, s = 0; s < E.length; s++)(C = { ease: (A = E[s]).e, duration: (A.t - (s ? E[s - 1].t : 0)) / 100 * m })[u] = A.v, o.to(T, C, L), L += C.duration; o.duration() < m && o.to({}, { duration: m - o.duration() }) } } m || a.duration(m = o.duration()) } else a.timeline = 0; return !0 !== y || co || (jl = so(a), fo.killTweensOf(T), jl = 0), js(S, so(a), r), n.reversed && a.reverse(), n.paused && a.paused(!0), (v || !m && !x && a._start === xs(S._time) && Bo(v) && Us(so(a)) && "nested" !== S.data) && (a._tTime = -1e-8, a.render(Math.max(0, -g))), M && qs(so(a), M), a } lo(e, t); var n = e.prototype; return n.render = function (t, e, n) { var r, i, a, o, s, l, c, u, h, d = this._time, f = this._tDur, p = this._dur, m = t < 0, g = t > f - Co && !m ? f : t < Co ? 0 : t; if (p) { if (g !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m) { if (r = g, u = this.timeline, this._repeat) { if (o = p + this._rDelay, this._repeat < -1 && m) return this.totalTime(100 * o + t, e, n); if (r = xs(g % o), g === f ? (a = this._repeat, r = p) : ((a = ~~(g / o)) && a === g / o && (r = p, a--), r > p && (r = p)), (l = this._yoyo && 1 & a) && (h = this._yEase, r = p - r), s = Bs(this._tTime, o), r === d && !n && this._initted) return this._tTime = g, this; a !== s && (u && this._yEase && zl(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(xs(o * a), !0).invalidate()._lock = 0)) } if (!this._initted) { if (Xs(this, m ? t : r, n, e)) return this._tTime = 0, this; if (d !== this._time) return this; if (p !== this._dur) return this.render(t, e, n) } if (this._tTime = g, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(r / p), this._from && (this.ratio = c = 1 - c), r && !d && !e && (vl(this, "onStart"), this._tTime !== g)) return this; for (i = this._pt; i;)i.r(c, i.d), i = i._next; u && u.render(t < 0 ? t : !r && l ? -1e-8 : u._dur * u._ease(r / this._dur), e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (m && Fs(this, t, 0, n), vl(this, "onUpdate")), this._repeat && a !== s && this.vars.onRepeat && !e && this.parent && vl(this, "onRepeat"), g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && Fs(this, t, 0, !0), (t || !p) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && Os(this, 1), e || m && !d || !g && !d || (vl(this, g === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < f && this.timeScale() > 0) && this._prom())) } } else !function (t, e, n, r) { var i, a, o, s = t.ratio, l = e < 0 || !e && (!t._start && Ys(t) && (t._initted || !Zs(t)) || (t._ts < 0 || t._dp._ts < 0) && !Zs(t)) ? 0 : 1, c = t._rDelay, u = 0; if (c && t._repeat && (u = nl(0, t._tDur, e), a = Bs(u, c), t._yoyo && 1 & a && (l = 1 - l), a !== Bs(t._tTime, c) && (s = 1 - l, t.vars.repeatRefresh && t._initted && t.invalidate())), l !== s || uo || r || t._zTime === Co || !e && t._zTime) { if (!t._initted && Xs(t, e, r, n)) return; for (o = t._zTime, t._zTime = e || (n ? Co : 0), n || (n = e && !o), t.ratio = l, t._from && (l = 1 - l), t._time = 0, t._tTime = u, i = t._pt; i;)i.r(l, i.d), i = i._next; e < 0 && Fs(t, e, 0, !0), t._onUpdate && !n && vl(t, "onUpdate"), u && t._repeat && !n && t.parent && vl(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === l && (l && Os(t, 1), n || (vl(t, l ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom())) } else t._zTime || (t._zTime = e) }(this, t, e, n); return this }, n.targets = function () { return this._targets }, n.invalidate = function () { return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this) }, n.resetTo = function (t, e, n, r) { xo || Ll.wake(), this._ts || this.play(); var i = Math.min(this._dur, (this._dp._time - this._start) * this._ts); return this._initted || Kl(this, i), function (t, e, n, r, i, a, o) { var s, l, c, u, h = (t._pt && t._ptCache || (t._ptCache = {}))[e]; if (!h) for (h = t._ptCache[e] = [], c = t._ptLookup, u = t._targets.length; u--;) { if ((s = c[u][e]) && s.d && s.d._pt) for (s = s.d._pt; s && s.p !== e && s.fp !== e;)s = s._next; if (!s) return ql = 1, t.vars[e] = "+=0", Kl(t, o), ql = 0, 1; h.push(s) } for (u = h.length; u--;)(s = (l = h[u])._pt || l).s = !r && 0 !== r || i ? s.s + (r || 0) + a * s.c : r, s.c = n - s.s, l.e && (l.e = ys(n) + rl(l.e)), l.b && (l.b = s.s + rl(l.b)) }(this, t, e, n, r, this._ease(i / this._dur), i) ? this.resetTo(t, e, n, r) : (Hs(this, 0), this.parent || Ds(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, n.kill = function (t, e) { if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? _l(this) : this; if (this.timeline) { var n = this.timeline.totalDuration(); return this.timeline.killTweensOf(t, e, jl && !0 !== jl.vars.overwrite)._first || _l(this), this.parent && n !== this.timeline.totalDuration() && Ks(this, this._dur * this.timeline._tDur / n, 0, 1), this } var r, i, a, o, s, l, c, u = this._targets, h = t ? ol(t) : u, d = this._ptLookup, f = this._pt; if ((!e || "all" === e) && function (t, e) { for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n];); return n < 0 }(u, h)) return "all" === e && (this._pt = 0), _l(this); for (r = this._op = this._op || [], "all" !== e && (No(e) && (s = {}, _s(e, (function (t) { return s[t] = 1 })), e = s), e = function (t, e) { var n, r, i, a, o = t[0] ? gs(t[0]).harness : 0, s = o && o.aliases; if (!s) return e; for (r in n = Cs({}, e), s) if (r in n) for (i = (a = s[r].split(",")).length; i--;)n[a[i]] = n[r]; return n }(u, e)), c = u.length; c--;)if (~h.indexOf(u[c])) for (s in i = d[c], "all" === e ? (r[c] = e, o = i, a = {}) : (a = r[c] = r[c] || {}, o = e), o) (l = i && i[s]) && ("kill" in l.d && !0 !== l.d.kill(s) || Is(this, l, "_pt"), delete i[s]), "all" !== a && (a[s] = 1); return this._initted && !this._pt && f && _l(this), this }, e.to = function (t, n) { return new e(t, n, arguments[2]) }, e.from = function (t, e) { return tl(1, arguments) }, e.delayedCall = function (t, n, r, i) { return new e(n, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: t, onComplete: n, onReverseComplete: n, onCompleteParams: r, onReverseCompleteParams: r, callbackScope: i }) }, e.fromTo = function (t, e, n) { return tl(2, arguments) }, e.set = function (t, n) { return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n) }, e.killTweensOf = function (t, e, n) { return fo.killTweensOf(t, e, n) }, e }(Hl); As(ec.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), _s("staggerTo,staggerFrom,staggerFromTo", (function (t) { ec[t] = function () { var e = new Wl, n = il.call(arguments, 0); return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n) } })); var nc = function (t, e, n) { return t[e] = n }, rc = function (t, e, n) { return t[e](n) }, ic = function (t, e, n, r) { return t[e](r.fp, n) }, ac = function (t, e, n) { return t.setAttribute(e, n) }, oc = function (t, e) { return zo(t[e]) ? rc : Uo(t[e]) && t.setAttribute ? ac : nc }, sc = function (t, e) { return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e) }, lc = function (t, e) { return e.set(e.t, e.p, !!(e.s + e.c * t), e) }, cc = function (t, e) { var n = e._pt, r = ""; if (!t && e.b) r = e.b; else if (1 === t && e.e) r = e.e; else { for (; n;)r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r, n = n._next; r += e.c } e.set(e.t, e.p, r, e) }, uc = function (t, e) { for (var n = e._pt; n;)n.r(t, n.d), n = n._next }, hc = function (t, e, n, r) { for (var i, a = this._pt; a;)i = a._next, a.p === r && a.modifier(t, e, n), a = i }, dc = function (t) { for (var e, n, r = this._pt; r;)n = r._next, r.p === t && !r.op || r.op === t ? Is(this, r, "_pt") : r.dep || (e = 1), r = n; return !e }, fc = function (t, e, n, r) { r.mSet(t, e, r.m.call(r.tween, n, r.mt), r) }, pc = function (t) { for (var e, n, r, i, a = t._pt; a;) { for (e = a._next, n = r; n && n.pr > a.pr;)n = n._next; (a._prev = n ? n._prev : i) ? a._prev._next = a : r = a, (a._next = n) ? n._prev = a : i = a, a = e } t._pt = r }, mc = function () { function t(t, e, n, r, i, a, o, s, l) { this.t = e, this.s = r, this.c = i, this.p = n, this.r = a || sc, this.d = o || this, this.set = s || nc, this.pr = l || 0, this._next = t, t && (t._prev = this) } return t.prototype.modifier = function (t, e, n) { this.mSet = this.mSet || this.set, this.set = fc, this.m = t, this.mt = n, this.tween = e }, t }(); _s(ps + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) { return ss[t] = 1 })), Qo.TweenMax = Qo.TweenLite = ec, Qo.TimelineLite = Qo.TimelineMax = Wl, fo = new Wl({ sortChildren: !1, defaults: Eo, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), To.stringFilter = Cl; var gc = [], vc = {}, _c = [], yc = 0, xc = function (t) { return (vc[t] || _c).map((function (t) { return t() })) }, bc = function () { var t = Date.now(), e = []; t - yc > 2 && (xc("matchMediaInit"), gc.forEach((function (t) { var n, r, i, a, o = t.queries, s = t.conditions; for (r in o) (n = po.matchMedia(o[r]).matches) && (i = 1), n !== s[r] && (s[r] = n, a = 1); a && (t.revert(), i && e.push(t)) })), xc("matchMediaRevert"), e.forEach((function (t) { return t.onMatch(t) })), yc = t, xc("matchMedia")) }, Mc = function () { function t(t, e) { this.selector = e && sl(e), this.data = [], this._r = [], this.isReverted = !1, t && this.add(t) } var e = t.prototype; return e.add = function (t, e, n) { zo(t) && (n = e, e = t, t = zo); var r = this, i = function () { var t, i = ho, a = r.selector; return i && i.data.push(r), n && (r.selector = sl(n)), ho = r, t = e.apply(r, arguments), zo(t) && r._r.push(t), ho = i, r.selector = a, r.isReverted = !1, t }; return r.last = i, t === zo ? i(r) : t ? r[t] = i : i }, e.ignore = function (t) { var e = ho; ho = null, t(this), ho = e }, e.getTweens = function () { var e = []; return this.data.forEach((function (n) { return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof ec && n._targets[0] !== n.vars.onComplete && e.push(n) })), e }, e.clear = function () { this._r.length = this.data.length = 0 }, e.kill = function (t, e) { var n = this; if (t ? (this.getTweens().map((function (t) { return { g: t.globalTime(0), t } })).sort((function (t, e) { return e.g - t.g || -1 })).forEach((function (e) { return e.t.revert(t) })), this.data.forEach((function (e) { return !(e instanceof Hl) && e.revert && e.revert(t) })), this._r.forEach((function (e) { return e(t, n) })), this.isReverted = !0) : this.data.forEach((function (t) { return t.kill && t.kill() })), this.clear(), e) { var r = gc.indexOf(this); ~r && gc.splice(r, 1) } }, e.revert = function (t) { this.kill(t || {}) }, t }(), wc = function () { function t(t) { this.contexts = [], this.scope = t } var e = t.prototype; return e.add = function (t, e, n) { ko(t) || (t = { matches: t }); var r, i, a, o = new Mc(0, n || this.scope), s = o.conditions = {}; for (i in this.contexts.push(o), e = o.add("onMatch", e), o.queries = t, t) "all" === i ? a = 1 : (r = po.matchMedia(t[i])) && (gc.indexOf(o) < 0 && gc.push(o), (s[i] = r.matches) && (a = 1), r.addListener ? r.addListener(bc) : r.addEventListener("change", bc)); return a && e(o), this }, e.revert = function (t) { this.kill(t || {}) }, e.kill = function (t) { this.contexts.forEach((function (e) { return e.kill(t, !0) })) }, t }(), Sc = { registerPlugin: function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; e.forEach((function (t) { return yl(t) })) }, timeline: function (t) { return new Wl(t) }, getTweensOf: function (t, e) { return fo.getTweensOf(t, e) }, getProperty: function (t, e, n, r) { No(t) && (t = ol(t)[0]); var i = gs(t || {}).get, a = n ? Es : Ts; return "native" === n && (n = ""), t ? e ? a((us[e] && us[e].get || i)(t, e, n, r)) : function (e, n, r) { return a((us[e] && us[e].get || i)(t, e, n, r)) } : t }, quickSetter: function (t, e, n) { if ((t = ol(t)).length > 1) { var r = t.map((function (t) { return Ac.quickSetter(t, e, n) })), i = r.length; return function (t) { for (var e = i; e--;)r[e](t) } } t = t[0] || {}; var a = us[e], o = gs(t), s = o.harness && (o.harness.aliases || {})[e] || e, l = a ? function (e) { var r = new a; yo._pt = 0, r.init(t, n ? e + n : e, yo, 0, [t]), r.render(1, r), yo._pt && uc(1, yo) } : o.set(t, s); return a ? l : function (e) { return l(t, s, n ? e + n : e, o, 1) } }, quickTo: function (t, e, n) { var r, i = Ac.to(t, Cs(((r = {})[e] = "+=0.1", r.paused = !0, r), n || {})), a = function (t, n, r) { return i.resetTo(e, t, n, r) }; return a.tween = i, a }, isTweening: function (t) { return fo.getTweensOf(t, !0).length > 0 }, defaults: function (t) { return t && t.ease && (t.ease = Fl(t.ease, Eo.ease)), Ls(Eo, t || {}) }, config: function (t) { return Ls(To, t || {}) }, registerEffect: function (t) { var e = t.name, n = t.effect, r = t.plugins, i = t.defaults, a = t.extendTimeline; (r || "").split(",").forEach((function (t) { return t && !us[t] && !Qo[t] && ns(e + " effect requires " + t + " plugin.") })), hs[e] = function (t, e, r) { return n(ol(t), As(e || {}, i), r) }, a && (Wl.prototype[e] = function (t, n, r) { return this.add(hs[e](t, ko(n) ? n : (r = n) && {}, this), r) }) }, registerEase: function (t, e) { Rl[t] = Fl(e) }, parseEase: function (t, e) { return arguments.length ? Fl(t, e) : Rl }, getById: function (t) { return fo.getById(t) }, exportRoot: function (t, e) { void 0 === t && (t = {}); var n, r, i = new Wl(t); for (i.smoothChildTiming = Bo(t.smoothChildTiming), fo.remove(i), i._dp = 0, i._time = i._tTime = fo._time, n = fo._first; n;)r = n._next, !e && !n._dur && n instanceof ec && n.vars.onComplete === n._targets[0] || js(i, n, n._start - n._delay), n = r; return js(fo, i, 0), i }, context: function (t, e) { return t ? new Mc(t, e) : ho }, matchMedia: function (t) { return new wc(t) }, matchMediaRefresh: function () { return gc.forEach((function (t) { var e, n, r = t.conditions; for (n in r) r[n] && (r[n] = !1, e = 1); e && t.revert() })) || bc() }, addEventListener: function (t, e) { var n = vc[t] || (vc[t] = []); ~n.indexOf(e) || n.push(e) }, removeEventListener: function (t, e) { var n = vc[t], r = n && n.indexOf(e); r >= 0 && n.splice(r, 1) }, utils: { wrap: function t(e, n, r) { var i = n - e; return Wo(e) ? fl(e, t(0, e.length), n) : el(r, (function (t) { return (i + (t - e) % i) % i + e })) }, wrapYoyo: function t(e, n, r) { var i = n - e, a = 2 * i; return Wo(e) ? fl(e, t(0, e.length - 1), n) : el(r, (function (t) { return e + ((t = (a + (t - e) % a) % a || 0) > i ? a - t : t) })) }, distribute: cl, random: dl, snap: hl, normalize: function (t, e, n) { return ml(t, e, 0, 1, n) }, getUnit: rl, clamp: function (t, e, n) { return el(n, (function (n) { return nl(t, e, n) })) }, splitColor: wl, toArray: ol, selector: sl, mapRange: ml, pipe: function () { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return function (t) { return e.reduce((function (t, e) { return e(t) }), t) } }, unitize: function (t, e) { return function (n) { return t(parseFloat(n)) + (e || rl(n)) } }, interpolate: function t(e, n, r, i) { var a = isNaN(e + n) ? 0 : function (t) { return (1 - t) * e + t * n }; if (!a) { var o, s, l, c, u, h = No(e), d = {}; if (!0 === r && (i = 1) && (r = null), h) e = { p: e }, n = { p: n }; else if (Wo(e) && !Wo(n)) { for (l = [], c = e.length, u = c - 2, s = 1; s < c; s++)l.push(t(e[s - 1], e[s])); c--, a = function (t) { t *= c; var e = Math.min(u, ~~t); return l[e](t - e) }, r = n } else i || (e = Cs(Wo(e) ? [] : {}, e)); if (!l) { for (o in n) Yl.call(d, e, o, "get", n[o]); a = function (t) { return uc(t, d) || (h ? e.p : e) } } } return el(r, a) }, shuffle: ll }, install: ts, effects: hs, ticker: Ll, updateRoot: Wl.updateRoot, plugins: us, globalTimeline: fo, core: { PropTween: mc, globals: rs, Tween: ec, Timeline: Wl, Animation: Hl, getCache: gs, _removeLinkedListItem: Is, reverting: function () { return uo }, context: function (t) { return t && ho && (ho.data.push(t), t._ctx = ho), ho }, suppressOverwrites: function (t) { return co = t } } }; _s("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) { return Sc[t] = ec[t] })), Ll.add(Wl.updateRoot), yo = Sc.to({}, { duration: 0 }); var Tc = function (t, e) { for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;)n = n._next; return n }, Ec = function (t, e) { return { name: t, rawVars: 1, init: function (t, n, r) { r._onInit = function (t) { var r, i; if (No(n) && (r = {}, _s(n, (function (t) { return r[t] = 1 })), n = r), e) { for (i in r = {}, n) r[i] = e(n[i]); n = r } !function (t, e) { var n, r, i, a = t._targets; for (n in e) for (r = a.length; r--;)(i = t._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = Tc(i, n)), i && i.modifier && i.modifier(e[n], t, a[r], n)) }(t, n) } } } }, Ac = Sc.registerPlugin({ name: "attr", init: function (t, e, n, r, i) { var a, o, s; for (a in this.tween = n, e) s = t.getAttribute(a) || "", (o = this.add(t, "setAttribute", (s || 0) + "", e[a], r, i, 0, 0, a)).op = a, o.b = s, this._props.push(a) }, render: function (t, e) { for (var n = e._pt; n;)uo ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), n = n._next } }, { name: "endArray", init: function (t, e) { for (var n = e.length; n--;)this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1) } }, Ec("roundProps", ul), Ec("modifiers"), Ec("snap", hl)) || Sc; ec.version = Wl.version = Ac.version = "3.11.0", vo = 1, Vo() && Pl(), Rl.Power0, Rl.Power1, Rl.Power2, Rl.Power3, Rl.Power4, Rl.Linear, Rl.Quad, Rl.Cubic, Rl.Quart, Rl.Quint, Rl.Strong, Rl.Elastic, Rl.Back, Rl.SteppedEase, Rl.Bounce, Rl.Sine, Rl.Expo, Rl.Circ; var Cc, Lc, Pc, Rc, Dc, Ic, Oc, Nc, zc = {}, Fc = 180 / Math.PI, Uc = Math.PI / 180, kc = Math.atan2, Bc = /([A-Z])/g, Vc = /(left|right|width|margin|padding|x)/i, Gc = /[\s,\(]\S/, Hc = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, Wc = function (t, e) { return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, jc = function (t, e) { return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e) }, qc = function (t, e) { return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e) }, Xc = function (t, e) { var n = e.s + e.c * t; e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e) }, Yc = function (t, e) { return e.set(e.t, e.p, t ? e.e : e.b, e) }, Zc = function (t, e) { return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e) }, Kc = function (t, e, n) { return t.style[e] = n }, Jc = function (t, e, n) { return t.style.setProperty(e, n) }, Qc = function (t, e, n) { return t._gsap[e] = n }, $c = function (t, e, n) { return t._gsap.scaleX = t._gsap.scaleY = n }, tu = function (t, e, n, r, i) { var a = t._gsap; a.scaleX = a.scaleY = n, a.renderTransform(i, a) }, eu = function (t, e, n, r, i) { var a = t._gsap; a[e] = n, a.renderTransform(i, a) }, nu = "transform", ru = nu + "Origin", iu = function (t) { var e = this, n = this.target, r = n.style; if (t in zc) { if (this.tfm = this.tfm || {}, "transform" !== t && (~(t = Hc[t] || t).indexOf(",") ? t.split(",").forEach((function (t) { return e.tfm[t] = Mu(n, t) })) : this.tfm[t] = n._gsap.x ? n._gsap[t] : Mu(n, t)), n._gsap.svg && (this.svg = n.getAttribute(t) || ""), this.props.indexOf(nu) >= 0) return; t = nu } r && this.props.push(t, r[t]) }, au = function (t) { t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate")) }, ou = function () { var t, e, n = this.props, r = this.target, i = r.style, a = r._gsap; for (t = 0; t < n.length; t += 2)n[t + 1] ? i[n[t]] = n[t + 1] : i.removeProperty(n[t].replace(Bc, "-$1").toLowerCase()); if (this.tfm) { for (e in a.svg && r.setAttribute("transform", this.svg || ""), this.tfm) a[e] = this.tfm[e]; !(t = Oc()) || t.isStart || i[nu] || (au(i), a.uncache = 1) } }, su = function (t, e) { var n = { target: t, props: [], revert: ou, save: iu }; return e && e.split(",").forEach((function (t) { return n.save(t) })), n }, lu = function (t, e) { var n = Lc.createElementNS ? Lc.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Lc.createElement(t); return n.style ? n : Lc.createElement(t) }, cu = function t(e, n, r) { var i = getComputedStyle(e); return i[n] || i.getPropertyValue(n.replace(Bc, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && t(e, hu(n) || n, 1) || "" }, uu = "O,Moz,ms,Ms,Webkit".split(","), hu = function (t, e, n) { var r = (e || Dc).style, i = 5; if (t in r && !n) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(uu[i] + t in r);); return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? uu[i] : "") + t }, du = function () { "undefined" != typeof window && window.document && (Cc = window, Lc = Cc.document, Pc = Lc.documentElement, Dc = lu("div") || { style: {} }, lu("div"), nu = hu(nu), ru = nu + "Origin", Dc.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Nc = !!hu("perspective"), Oc = Ac.core.reverting, Rc = 1) }, fu = function t(e) { var n, r = lu("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, a = this.nextSibling, o = this.style.cssText; if (Pc.appendChild(r), r.appendChild(this), this.style.display = "block", e) try { n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t } catch (t) { } else this._gsapBBox && (n = this._gsapBBox()); return i && (a ? i.insertBefore(this, a) : i.appendChild(this)), Pc.removeChild(r), this.style.cssText = o, n }, pu = function (t, e) { for (var n = e.length; n--;)if (t.hasAttribute(e[n])) return t.getAttribute(e[n]) }, mu = function (t) { var e; try { e = t.getBBox() } catch (n) { e = fu.call(t, !0) } return e && (e.width || e.height) || t.getBBox === fu || (e = fu.call(t, !0)), !e || e.width || e.x || e.y ? e : { x: +pu(t, ["x", "cx", "x1"]) || 0, y: +pu(t, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, gu = function (t) { return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !mu(t)) }, vu = function (t, e) { if (e) { var n = t.style; e in zc && e !== ru && (e = nu), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(Bc, "-$1").toLowerCase())) : n.removeAttribute(e) } }, _u = function (t, e, n, r, i, a) { var o = new mc(t._pt, e, n, 0, 1, a ? Zc : Yc); return t._pt = o, o.b = r, o.e = i, t._props.push(n), o }, yu = { deg: 1, rad: 1, turn: 1 }, xu = { grid: 1, flex: 1 }, bu = function t(e, n, r, i) { var a, o, s, l, c = parseFloat(r) || 0, u = (r + "").trim().substr((c + "").length) || "px", h = Dc.style, d = Vc.test(n), f = "svg" === e.tagName.toLowerCase(), p = (f ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === i, v = "%" === i; return i === u || !c || yu[i] || yu[u] ? c : ("px" !== u && !g && (c = t(e, n, r, "px")), l = e.getCTM && gu(e), !v && "%" !== u || !zc[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : i), o = ~n.indexOf("adius") || "em" === i && e.appendChild && !f ? e : e.parentNode, l && (o = (e.ownerSVGElement || {}).parentNode), o && o !== Lc && o.appendChild || (o = Lc.body), (s = o._gsap) && v && s.width && d && s.time === Ll.time && !s.uncache ? ys(c / s.width * m) : ((v || "%" === u) && !xu[cu(o, "display")] && (h.position = cu(e, "position")), o === e && (h.position = "static"), o.appendChild(Dc), a = Dc[p], o.removeChild(Dc), h.position = "absolute", d && v && ((s = gs(o)).time = Ll.time, s.width = o[p]), ys(g ? a * c / m : a && c ? m / a * c : 0))) : (a = l ? e.getBBox()[d ? "width" : "height"] : e[p], ys(v ? c / a * m : c / 100 * a))) }, Mu = function (t, e, n, r) { var i; return Rc || du(), e in Hc && "transform" !== e && ~(e = Hc[e]).indexOf(",") && (e = e.split(",")[0]), zc[e] && "transform" !== e ? (i = Iu(t, r), i = "transformOrigin" !== e ? i[e] : i.svg ? i.origin : Ou(cu(t, ru)) + " " + i.zOrigin + "px") : (!(i = t.style[e]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = Eu[e] && Eu[e](t, e, n) || cu(t, e) || vs(t, e) || ("opacity" === e ? 1 : 0)), n && !~(i + "").trim().indexOf(" ") ? bu(t, e, i, n) + n : i }, wu = function (t, e, n, r) { if (!n || "none" === n) { var i = hu(e, t, 1), a = i && cu(t, i, 1); a && a !== n ? (e = i, n = a) : "borderColor" === e && (n = cu(t, "borderTopColor")) } var o, s, l, c, u, h, d, f, p, m, g, v = new mc(this._pt, t.style, e, 0, 1, cc), _ = 0, y = 0; if (v.b = n, v.e = r, n += "", "auto" == (r += "") && (t.style[e] = r, r = cu(t, e) || r, t.style[e] = n), Cl(o = [n, r]), r = o[1], l = (n = o[0]).match(Xo) || [], (r.match(Xo) || []).length) { for (; s = Xo.exec(r);)d = s[0], p = r.substring(_, s.index), u ? u = (u + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (u = 1), d !== (h = l[y++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), "=" === d.charAt(1) && (d = bs(c, d) + g), f = parseFloat(d), m = d.substr((f + "").length), _ = Xo.lastIndex - m.length, m || (m = m || To.units[e] || g, _ === r.length && (r += m, v.e += m)), g !== m && (c = bu(t, e, h, m) || 0), v._pt = { _next: v._pt, p: p || 1 === y ? p : ",", s: c, c: f - c, m: u && u < 4 || "zIndex" === e ? Math.round : 0 }); v.c = _ < r.length ? r.substring(_, r.length) : "" } else v.r = "display" === e && "none" === r ? Zc : Yc; return Zo.test(r) && (v.e = 0), this._pt = v, v }, Su = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, Tu = function (t, e) { if (e.tween && e.tween._time === e.tween._dur) { var n, r, i, a = e.t, o = a.style, s = e.u, l = a._gsap; if ("all" === s || !0 === s) o.cssText = "", r = 1; else for (i = (s = s.split(",")).length; --i > -1;)n = s[i], zc[n] && (r = 1, n = "transformOrigin" === n ? ru : nu), vu(a, n); r && (vu(a, nu), l && (l.svg && a.removeAttribute("transform"), Iu(a, 1), l.uncache = 1, au(o))) } }, Eu = { clearProps: function (t, e, n, r, i) { if ("isFromStart" !== i.data) { var a = t._pt = new mc(t._pt, e, n, 0, 0, Tu); return a.u = r, a.pr = -10, a.tween = i, t._props.push(n), 1 } } }, Au = [1, 0, 0, 1, 0, 0], Cu = {}, Lu = function (t) { return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t }, Pu = function (t) { var e = cu(t, nu); return Lu(e) ? Au : e.substr(7).match(qo).map(ys) }, Ru = function (t, e) { var n, r, i, a, o = t._gsap || gs(t), s = t.style, l = Pu(t); return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? Au : l : (l !== Au || t.offsetParent || t === Pc || o.svg || (i = s.display, s.display = "block", (n = t.parentNode) && t.offsetParent || (a = 1, r = t.nextElementSibling, Pc.appendChild(t)), l = Pu(t), i ? s.display = i : vu(t, "display"), a && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : Pc.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l) }, Du = function (t, e, n, r, i, a) { var o, s, l, c = t._gsap, u = i || Ru(t, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, f = c.xOffset || 0, p = c.yOffset || 0, m = u[0], g = u[1], v = u[2], _ = u[3], y = u[4], x = u[5], b = e.split(" "), M = parseFloat(b[0]) || 0, w = parseFloat(b[1]) || 0; n ? u !== Au && (s = m * _ - g * v) && (l = M * (-g / s) + w * (m / s) - (m * x - g * y) / s, M = M * (_ / s) + w * (-v / s) + (v * x - _ * y) / s, w = l) : (M = (o = mu(t)).x + (~b[0].indexOf("%") ? M / 100 * o.width : M), w = o.y + (~(b[1] || b[0]).indexOf("%") ? w / 100 * o.height : w)), r || !1 !== r && c.smooth ? (y = M - h, x = w - d, c.xOffset = f + (y * m + x * v) - y, c.yOffset = p + (y * g + x * _) - x) : c.xOffset = c.yOffset = 0, c.xOrigin = M, c.yOrigin = w, c.smooth = !!r, c.origin = e, c.originIsAbsolute = !!n, t.style[ru] = "0px 0px", a && (_u(a, c, "xOrigin", h, M), _u(a, c, "yOrigin", d, w), _u(a, c, "xOffset", f, c.xOffset), _u(a, c, "yOffset", p, c.yOffset)), t.setAttribute("data-svg-origin", M + " " + w) }, Iu = function (t, e) { var n = t._gsap || new Gl(t); if ("x" in n && !e && !n.uncache) return n; var r, i, a, o, s, l, c, u, h, d, f, p, m, g, v, _, y, x, b, M, w, S, T, E, A, C, L, P, R, D, I, O, N = t.style, z = n.scaleX < 0, F = "px", U = "deg", k = getComputedStyle(t), B = cu(t, ru) || "0"; return r = i = a = l = c = u = h = d = f = 0, o = s = 1, n.svg = !(!t.getCTM || !gu(t)), k.translate && ("none" === k.translate && "none" === k.scale && "none" === k.rotate || (N[nu] = ("none" !== k.translate ? "translate3d(" + (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") + ("none" !== k.scale ? "scale(" + k.scale.split(" ").join(",") + ") " : "") + k[nu]), N.scale = N.rotate = N.translate = "none"), g = Ru(t, n.svg), n.svg && (E = (!n.uncache || "0px 0px" === B) && !e && t.getAttribute("data-svg-origin"), Du(t, E || B, !!E || n.originIsAbsolute, !1 !== n.smooth, g)), p = n.xOrigin || 0, m = n.yOrigin || 0, g !== Au && (x = g[0], b = g[1], M = g[2], w = g[3], r = S = g[4], i = T = g[5], 6 === g.length ? (o = Math.sqrt(x * x + b * b), s = Math.sqrt(w * w + M * M), l = x || b ? kc(b, x) * Fc : 0, (h = M || w ? kc(M, w) * Fc + l : 0) && (s *= Math.abs(Math.cos(h * Uc))), n.svg && (r -= p - (p * x + m * M), i -= m - (p * b + m * w))) : (O = g[6], D = g[7], L = g[8], P = g[9], R = g[10], I = g[11], r = g[12], i = g[13], a = g[14], c = (v = kc(O, R)) * Fc, v && (E = S * (_ = Math.cos(-v)) + L * (y = Math.sin(-v)), A = T * _ + P * y, C = O * _ + R * y, L = S * -y + L * _, P = T * -y + P * _, R = O * -y + R * _, I = D * -y + I * _, S = E, T = A, O = C), u = (v = kc(-M, R)) * Fc, v && (_ = Math.cos(-v), I = w * (y = Math.sin(-v)) + I * _, x = E = x * _ - L * y, b = A = b * _ - P * y, M = C = M * _ - R * y), l = (v = kc(b, x)) * Fc, v && (E = x * (_ = Math.cos(v)) + b * (y = Math.sin(v)), A = S * _ + T * y, b = b * _ - x * y, T = T * _ - S * y, x = E, S = A), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), o = ys(Math.sqrt(x * x + b * b + M * M)), s = ys(Math.sqrt(T * T + O * O)), v = kc(S, T), h = Math.abs(v) > 2e-4 ? v * Fc : 0, f = I ? 1 / (I < 0 ? -I : I) : 0), n.svg && (E = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Lu(cu(t, nu)), E && t.setAttribute("transform", E))), Math.abs(h) > 90 && Math.abs(h) < 270 && (z ? (o *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (s *= -1, h += h <= 0 ? 180 : -180)), e = e || n.uncache, n.x = r - ((n.xPercent = r && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + F, n.y = i - ((n.yPercent = i && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + F, n.z = a + F, n.scaleX = ys(o), n.scaleY = ys(s), n.rotation = ys(l) + U, n.rotationX = ys(c) + U, n.rotationY = ys(u) + U, n.skewX = h + U, n.skewY = d + U, n.transformPerspective = f + F, (n.zOrigin = parseFloat(B.split(" ")[2]) || 0) && (N[ru] = Ou(B)), n.xOffset = n.yOffset = 0, n.force3D = To.force3D, n.renderTransform = n.svg ? Vu : Nc ? Bu : zu, n.uncache = 0, n }, Ou = function (t) { return (t = t.split(" "))[0] + " " + t[1] }, Nu = function (t, e, n) { var r = rl(e); return ys(parseFloat(e) + parseFloat(bu(t, "x", n + "px", r))) + r }, zu = function (t, e) { e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Bu(t, e) }, Fu = "0deg", Uu = "0px", ku = ") ", Bu = function (t, e) { var n = e || this, r = n.xPercent, i = n.yPercent, a = n.x, o = n.y, s = n.z, l = n.rotation, c = n.rotationY, u = n.rotationX, h = n.skewX, d = n.skewY, f = n.scaleX, p = n.scaleY, m = n.transformPerspective, g = n.force3D, v = n.target, _ = n.zOrigin, y = "", x = "auto" === g && t && 1 !== t || !0 === g; if (_ && (u !== Fu || c !== Fu)) { var b, M = parseFloat(c) * Uc, w = Math.sin(M), S = Math.cos(M); M = parseFloat(u) * Uc, b = Math.cos(M), a = Nu(v, a, w * b * -_), o = Nu(v, o, -Math.sin(M) * -_), s = Nu(v, s, S * b * -_ + _) } m !== Uu && (y += "perspective(" + m + ku), (r || i) && (y += "translate(" + r + "%, " + i + "%) "), (x || a !== Uu || o !== Uu || s !== Uu) && (y += s !== Uu || x ? "translate3d(" + a + ", " + o + ", " + s + ") " : "translate(" + a + ", " + o + ku), l !== Fu && (y += "rotate(" + l + ku), c !== Fu && (y += "rotateY(" + c + ku), u !== Fu && (y += "rotateX(" + u + ku), h === Fu && d === Fu || (y += "skew(" + h + ", " + d + ku), 1 === f && 1 === p || (y += "scale(" + f + ", " + p + ku), v.style[nu] = y || "translate(0, 0)" }, Vu = function (t, e) { var n, r, i, a, o, s = e || this, l = s.xPercent, c = s.yPercent, u = s.x, h = s.y, d = s.rotation, f = s.skewX, p = s.skewY, m = s.scaleX, g = s.scaleY, v = s.target, _ = s.xOrigin, y = s.yOrigin, x = s.xOffset, b = s.yOffset, M = s.forceCSS, w = parseFloat(u), S = parseFloat(h); d = parseFloat(d), f = parseFloat(f), (p = parseFloat(p)) && (f += p = parseFloat(p), d += p), d || f ? (d *= Uc, f *= Uc, n = Math.cos(d) * m, r = Math.sin(d) * m, i = Math.sin(d - f) * -g, a = Math.cos(d - f) * g, f && (p *= Uc, o = Math.tan(f - p), i *= o = Math.sqrt(1 + o * o), a *= o, p && (o = Math.tan(p), n *= o = Math.sqrt(1 + o * o), r *= o)), n = ys(n), r = ys(r), i = ys(i), a = ys(a)) : (n = m, a = g, r = i = 0), (w && !~(u + "").indexOf("px") || S && !~(h + "").indexOf("px")) && (w = bu(v, "x", u, "px"), S = bu(v, "y", h, "px")), (_ || y || x || b) && (w = ys(w + _ - (_ * n + y * i) + x), S = ys(S + y - (_ * r + y * a) + b)), (l || c) && (o = v.getBBox(), w = ys(w + l / 100 * o.width), S = ys(S + c / 100 * o.height)), o = "matrix(" + n + "," + r + "," + i + "," + a + "," + w + "," + S + ")", v.setAttribute("transform", o), M && (v.style[nu] = o) }, Gu = function (t, e, n, r, i) { var a, o, s = 360, l = No(i), c = parseFloat(i) * (l && ~i.indexOf("rad") ? Fc : 1) - r, u = r + c + "deg"; return l && ("short" === (a = i.split("_")[1]) && (c %= s) != c % 180 && (c += c < 0 ? s : -360), "cw" === a && c < 0 ? c = (c + 36e9) % s - ~~(c / s) * s : "ccw" === a && c > 0 && (c = (c - 36e9) % s - ~~(c / s) * s)), t._pt = o = new mc(t._pt, e, n, r, c, jc), o.e = u, o.u = "deg", t._props.push(n), o }, Hu = function (t, e) { for (var n in e) t[n] = e[n]; return t }, Wu = function (t, e, n) { var r, i, a, o, s, l, c, u = Hu({}, n._gsap), h = n.style; for (i in u.svg ? (a = n.getAttribute("transform"), n.setAttribute("transform", ""), h[nu] = e, r = Iu(n, 1), vu(n, nu), n.setAttribute("transform", a)) : (a = getComputedStyle(n)[nu], h[nu] = e, r = Iu(n, 1), h[nu] = a), zc) (a = u[i]) !== (o = r[i]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) < 0 && (s = rl(a) !== (c = rl(o)) ? bu(n, i, a, c) : parseFloat(a), l = parseFloat(o), t._pt = new mc(t._pt, r, i, s, l - s, Wc), t._pt.u = c || 0, t._props.push(i)); Hu(r, u) }; _s("padding,margin,Width,Radius", (function (t, e) { var n = "Top", r = "Right", i = "Bottom", a = "Left", o = (e < 3 ? [n, r, i, a] : [n + a, n + r, i + r, i + a]).map((function (n) { return e < 2 ? t + n : "border" + n + t })); Eu[e > 1 ? "border" + t : t] = function (t, e, n, r, i) { var a, s; if (arguments.length < 4) return a = o.map((function (e) { return Mu(t, e, n) })), 5 === (s = a.join(" ")).split(a[0]).length ? a[0] : s; a = (r + "").split(" "), s = {}, o.forEach((function (t, e) { return s[t] = a[e] = a[e] || a[(e - 1) / 2 | 0] })), t.init(e, s, i) } })); var ju, qu, Xu = { name: "css", register: du, targetTest: function (t) { return t.style && t.nodeType }, init: function (t, e, n, r, i) { var a, o, s, l, c, u, h, d, f, p, m, g, v, _, y, x, b, M, w, S, T = this._props, E = t.style, A = n.vars.startAt; for (h in Rc || du(), this.styles = this.styles || su(t), x = this.styles.props, this.tween = n, e) if ("autoRound" !== h && (o = e[h], !us[h] || !Zl(h, e, n, r, t, i))) if (c = typeof o, u = Eu[h], "function" === c && (c = typeof (o = o.call(n, r, t, i))), "string" === c && ~o.indexOf("random(") && (o = pl(o)), u) u(this, t, h, o, n) && (y = 1); else if ("--" === h.substr(0, 2)) a = (getComputedStyle(t).getPropertyValue(h) + "").trim(), o += "", El.lastIndex = 0, El.test(a) || (d = rl(a), f = rl(o)), f ? d !== f && (a = bu(t, h, a, f) + f) : d && (o += d), this.add(E, "setProperty", a, o, r, i, 0, 0, h), T.push(h), x.push(h, E[h]); else if ("undefined" !== c) { if (A && h in A ? (a = "function" == typeof A[h] ? A[h].call(n, r, t, i) : A[h], No(a) && ~a.indexOf("random(") && (a = pl(a)), rl(a + "") || (a += To.units[h] || rl(Mu(t, h)) || ""), "=" === (a + "").charAt(1) && (a = Mu(t, h))) : a = Mu(t, h), l = parseFloat(a), (p = "string" === c && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)), s = parseFloat(o), h in Hc && ("autoAlpha" === h && (1 === l && "hidden" === Mu(t, "visibility") && s && (l = 0), x.push("visibility", E.visibility), _u(this, E, "visibility", l ? "inherit" : "hidden", s ? "inherit" : "hidden", !s)), "scale" !== h && "transform" !== h && ~(h = Hc[h]).indexOf(",") && (h = h.split(",")[0])), m = h in zc) if (this.styles.save(h), g || ((v = t._gsap).renderTransform && !e.parseTransform || Iu(t, e.parseTransform), _ = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new mc(this._pt, E, nu, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new mc(this._pt, v, "scaleY", v.scaleY, (p ? bs(v.scaleY, p + s) : s) - v.scaleY || 0, Wc), this._pt.u = 0, T.push("scaleY", h), h += "X"; else { if ("transformOrigin" === h) { x.push(ru, E[ru]), M = void 0, w = void 0, S = void 0, w = (M = (b = o).split(" "))[0], S = M[1] || "50%", "top" !== w && "bottom" !== w && "left" !== S && "right" !== S || (b = w, w = S, S = b), M[0] = Su[w] || w, M[1] = Su[S] || S, o = M.join(" "), v.svg ? Du(t, o, 0, _, 0, this) : ((f = parseFloat(o.split(" ")[2]) || 0) !== v.zOrigin && _u(this, v, "zOrigin", v.zOrigin, f), _u(this, E, h, Ou(a), Ou(o))); continue } if ("svgOrigin" === h) { Du(t, o, 1, _, 0, this); continue } if (h in Cu) { Gu(this, v, h, l, p ? bs(l, p + o) : o); continue } if ("smoothOrigin" === h) { _u(this, v, "smooth", v.smooth, o); continue } if ("force3D" === h) { v[h] = o; continue } if ("transform" === h) { Wu(this, o, t); continue } } else h in E || (h = hu(h) || h); if (m || (s || 0 === s) && (l || 0 === l) && !Gc.test(o) && h in E) s || (s = 0), (d = (a + "").substr((l + "").length)) !== (f = rl(o) || (h in To.units ? To.units[h] : d)) && (l = bu(t, h, a, f)), this._pt = new mc(this._pt, m ? v : E, h, l, (p ? bs(l, p + s) : s) - l, m || "px" !== f && "zIndex" !== h || !1 === e.autoRound ? Wc : Xc), this._pt.u = f || 0, d !== f && "%" !== f && (this._pt.b = a, this._pt.r = qc); else if (h in E) wu.call(this, t, h, a, p ? p + o : o); else { if (!(h in t)) { es(h, o); continue } this.add(t, h, a || t[h], p ? p + o : o, r, i) } m || x.push(h, E[h]), T.push(h) } y && pc(this) }, render: function (t, e) { if (e.tween._time || !Oc()) for (var n = e._pt; n;)n.r(t, n.d), n = n._next; else e.styles.revert() }, get: Mu, aliases: Hc, getSetter: function (t, e, n) { var r = Hc[e]; return r && r.indexOf(",") < 0 && (e = r), e in zc && e !== ru && (t._gsap.x || Mu(t, "x")) ? n && Ic === n ? "scale" === e ? $c : Qc : (Ic = n || {}) && ("scale" === e ? tu : eu) : t.style && !Uo(t.style[e]) ? Kc : ~e.indexOf("-") ? Jc : oc(t, e) }, core: { _removeProperty: vu, _getMatrix: Ru } }; Ac.utils.checkPrefix = hu, Ac.core.getStyleSaver = su, qu = _s("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (ju = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) { zc[t] = 1 })), _s(ju, (function (t) { To.units[t] = "deg", Cu[t] = 1 })), Hc[qu[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + ju, _s("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) { var e = t.split(":"); Hc[e[1]] = qu[e[0]] })), _s("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) { To.units[t] = "px" })), Ac.registerPlugin(Xu); var Yu = Ac.registerPlugin(Xu) || Ac; function Zu(t) { return Zu = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, Zu(t) } function Ku() { Ku = function () { return t }; var t = {}, e = Object.prototype, n = e.hasOwnProperty, r = "function" == typeof Symbol ? Symbol : {}, i = r.iterator || "@@iterator", a = r.asyncIterator || "@@asyncIterator", o = r.toStringTag || "@@toStringTag"; function s(t, e, n) { return Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }), t[e] } try { s({}, "") } catch (t) { s = function (t, e, n) { return t[e] = n } } function l(t, e, n, r) { var i = e && e.prototype instanceof h ? e : h, a = Object.create(i.prototype), o = new w(r || []); return a._invoke = function (t, e, n) { var r = "suspendedStart"; return function (i, a) { if ("executing" === r) throw new Error("Generator is already running"); if ("completed" === r) { if ("throw" === i) throw a; return { value: void 0, done: !0 } } for (n.method = i, n.arg = a; ;) { var o = n.delegate; if (o) { var s = x(o, n); if (s) { if (s === u) continue; return s } } if ("next" === n.method) n.sent = n._sent = n.arg; else if ("throw" === n.method) { if ("suspendedStart" === r) throw r = "completed", n.arg; n.dispatchException(n.arg) } else "return" === n.method && n.abrupt("return", n.arg); r = "executing"; var l = c(t, e, n); if ("normal" === l.type) { if (r = n.done ? "completed" : "suspendedYield", l.arg === u) continue; return { value: l.arg, done: n.done } } "throw" === l.type && (r = "completed", n.method = "throw", n.arg = l.arg) } } }(t, n, o), a } function c(t, e, n) { try { return { type: "normal", arg: t.call(e, n) } } catch (t) { return { type: "throw", arg: t } } } t.wrap = l; var u = {}; function h() { } function d() { } function f() { } var p = {}; s(p, i, (function () { return this })); var m = Object.getPrototypeOf, g = m && m(m(S([]))); g && g !== e && n.call(g, i) && (p = g); var v = f.prototype = h.prototype = Object.create(p); function _(t) { ["next", "throw", "return"].forEach((function (e) { s(t, e, (function (t) { return this._invoke(e, t) })) })) } function y(t, e) { function r(i, a, o, s) { var l = c(t[i], t, a); if ("throw" !== l.type) { var u = l.arg, h = u.value; return h && "object" == Zu(h) && n.call(h, "__await") ? e.resolve(h.__await).then((function (t) { r("next", t, o, s) }), (function (t) { r("throw", t, o, s) })) : e.resolve(h).then((function (t) { u.value = t, o(u) }), (function (t) { return r("throw", t, o, s) })) } s(l.arg) } var i; this._invoke = function (t, n) { function a() { return new e((function (e, i) { r(t, n, e, i) })) } return i = i ? i.then(a, a) : a() } } function x(t, e) { var n = t.iterator[e.method]; if (void 0 === n) { if (e.delegate = null, "throw" === e.method) { if (t.iterator.return && (e.method = "return", e.arg = void 0, x(t, e), "throw" === e.method)) return u; e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method") } return u } var r = c(n, t.iterator, e.arg); if ("throw" === r.type) return e.method = "throw", e.arg = r.arg, e.delegate = null, u; var i = r.arg; return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = void 0), e.delegate = null, u) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, u) } function b(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function M(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function w(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(b, this), this.reset(!0) } function S(t) { if (t) { var e = t[i]; if (e) return e.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var r = -1, a = function e() { for (; ++r < t.length;)if (n.call(t, r)) return e.value = t[r], e.done = !1, e; return e.value = void 0, e.done = !0, e }; return a.next = a } } return { next: T } } function T() { return { value: void 0, done: !0 } } return d.prototype = f, s(v, "constructor", f), s(f, "constructor", d), d.displayName = s(f, o, "GeneratorFunction"), t.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === d || "GeneratorFunction" === (e.displayName || e.name)) }, t.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, f) : (t.__proto__ = f, s(t, o, "GeneratorFunction")), t.prototype = Object.create(v), t }, t.awrap = function (t) { return { __await: t } }, _(y.prototype), s(y.prototype, a, (function () { return this })), t.AsyncIterator = y, t.async = function (e, n, r, i, a) { void 0 === a && (a = Promise); var o = new y(l(e, n, r, i), a); return t.isGeneratorFunction(n) ? o : o.next().then((function (t) { return t.done ? t.value : o.next() })) }, _(v), s(v, o, "Generator"), s(v, i, (function () { return this })), s(v, "toString", (function () { return "[object Generator]" })), t.keys = function (t) { var e = []; for (var n in t) e.push(n); return e.reverse(), function n() { for (; e.length;) { var r = e.pop(); if (r in t) return n.value = r, n.done = !1, n } return n.done = !0, n } }, t.values = S, w.prototype = { constructor: w, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(M), !t) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (t) { if (this.done) throw t; var e = this; function r(n, r) { return o.type = "throw", o.arg = t, e.next = n, r && (e.method = "next", e.arg = void 0), !!r } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var a = this.tryEntries[i], o = a.completion; if ("root" === a.tryLoc) return r("end"); if (a.tryLoc <= this.prev) { var s = n.call(a, "catchLoc"), l = n.call(a, "finallyLoc"); if (s && l) { if (this.prev < a.catchLoc) return r(a.catchLoc, !0); if (this.prev < a.finallyLoc) return r(a.finallyLoc) } else if (s) { if (this.prev < a.catchLoc) return r(a.catchLoc, !0) } else { if (!l) throw new Error("try statement without catch or finally"); if (this.prev < a.finallyLoc) return r(a.finallyLoc) } } } }, abrupt: function (t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var i = this.tryEntries[r]; if (i.tryLoc <= this.prev && n.call(i, "finallyLoc") && this.prev < i.finallyLoc) { var a = i; break } } a && ("break" === t || "continue" === t) && a.tryLoc <= e && e <= a.finallyLoc && (a = null); var o = a ? a.completion : {}; return o.type = t, o.arg = e, a ? (this.method = "next", this.next = a.finallyLoc, u) : this.complete(o) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), u }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), M(n), u } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.tryLoc === t) { var r = n.completion; if ("throw" === r.type) { var i = r.arg; M(n) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function (t, e, n) { return this.delegate = { iterator: S(t), resultName: e, nextLoc: n }, "next" === this.method && (this.arg = void 0), u } }, t } function Ju(t, e, n, r, i, a, o) { try { var s = t[a](o), l = s.value } catch (t) { return void n(t) } s.done ? e(l) : Promise.resolve(l).then(r, i) } function Qu(t) { return function () { var e = this, n = arguments; return new Promise((function (r, i) { var a = t.apply(e, n); function o(t) { Ju(a, r, i, o, s, "next", t) } function s(t) { Ju(a, r, i, o, s, "throw", t) } o(void 0) })) } } function $u(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function th(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } Yu.core.Tween; var eh = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), th(this, "group", void 0), th(this, "earthGroup", void 0), th(this, "around", void 0), th(this, "aroundPoints", void 0), th(this, "options", void 0), th(this, "uniforms", void 0), th(this, "timeValue", void 0), th(this, "earth", void 0), th(this, "punctuationMaterial", void 0), th(this, "markupPoint", void 0), th(this, "waveMeshArr", void 0), th(this, "circleLineList", void 0), th(this, "circleList", void 0), th(this, "x", void 0), th(this, "n", void 0), th(this, "isRotation", void 0), th(this, "flyLineArcGroup", void 0), this.options = e, this.group = new ea, this.group.name = "group", this.group.scale.set(0, 0, 0), this.earthGroup = new ea, this.group.add(this.earthGroup), this.earthGroup.name = "EarthGroup", this.markupPoint = new ea, this.markupPoint.name = "markupPoint", this.waveMeshArr = [], this.circleLineList = [], this.circleList = [], this.x = 0, this.n = 0, this.isRotation = this.options.earth.isRotation, this.timeValue = 1e8, this.uniforms = { glowColor: { value: new rt(840171) }, scale: { type: "f", value: -1 }, bias: { type: "f", value: 1 }, power: { type: "f", value: 3.3 }, time: { type: "f", value: this.timeValue }, isHover: { value: !1 }, map: { value: null } } } var e, n, r; return e = t, n = [{ key: "init", value: (r = Qu(Ku().mark((function t() { var e = this; return Ku().wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.abrupt("return", new Promise(function () { var t = Qu(Ku().mark((function t(n) { return Ku().wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: e.createEarth(), e.show(), n(); case 3: case "end": return t.stop() } }), t) }))); return function (e) { return t.apply(this, arguments) } }())); case 1: case "end": return t.stop() } }), t) }))), function () { return r.apply(this, arguments) }) }, { key: "createEarth", value: function () { var t = new va(this.options.earth.radius, 50, 50); this.uniforms.map.value = this.options.textures.earth; var e = new gn({ uniforms: this.uniforms, vertexShader: "\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vp;\nvarying vec3 vPositionNormal;\nvoid main(void){\n  vUv = uv;\n  vNormal = normalize( normalMatrix * normal ); // 转换到视图空间\n  vp = position;\n  vPositionNormal = normalize(( modelViewMatrix * vec4(position, 1.0) ).xyz);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader: "uniform vec3 glowColor;\nuniform float bias;\nuniform float power;\nuniform float time;\nvarying vec3 vp;\nvarying vec3 vNormal;\nvarying vec3 vPositionNormal;\nuniform float scale;\n// 获取纹理\nuniform sampler2D map;\n// 纹理坐标\nvarying vec2 vUv;\n\nvoid main(void){\n  float a = pow( bias + scale * abs(dot(vNormal, vPositionNormal)), power );\n  if(vp.y > time && vp.y < time + 20.0) {\n    float t =  smoothstep(0.0, 0.8,  (1.0 - abs(0.5 - (vp.y - time) / 20.0)) / 3.0  );\n    gl_FragColor = mix(gl_FragColor, vec4(glowColor, 1.0), t * t );\n  }\n  gl_FragColor = mix(gl_FragColor, vec4( glowColor, 1.0 ), a);\n  float b = 0.8;\n  gl_FragColor = gl_FragColor + texture2D( map, vUv );\n}" }); e.needsUpdate = !0, this.earth = new un(t, e), this.earth.name = "earth", this.earth.position.set(0, -59, 0), this.earthGroup.add(this.earth) } }, { key: "createStars", value: function () { for (var t = [], e = [], n = 0; n < 500; n++) { var r = new mt; r.x = 800 * Math.random() - 300, r.y = 800 * Math.random() - 300, r.z = 800 * Math.random() - 300, t.push(r.x, r.y, r.z), e.push(new rt(1, 1, 1)) } this.around = new je, this.around.setAttribute("position", new Oe(new Float32Array(t), 3)), this.around.setAttribute("color", new Oe(new Float32Array(e), 3)); var i = new ua({ size: 2, sizeAttenuation: !0, color: 5076687, transparent: !0, opacity: 1, map: this.options.textures.gradient }); this.aroundPoints = new ma(this.around, i), this.aroundPoints.name = "星空", this.aroundPoints.scale.set(1, 1, 1), this.group.add(this.aroundPoints) } }, { key: "show", value: function () { Yu.to(this.group.scale, { x: 1, y: 1, z: 1, duration: 2, ease: "Quadratic" }) } }, { key: "render", value: function () { var t, e, n = this; null === (t = this.flyLineArcGroup) || void 0 === t || null === (e = t.userData.flyLineArray) || void 0 === e || e.forEach((function (t) { t.rotation.z += n.options.flyLine.speed, t.rotation.z >= t.flyEndAngle && (t.rotation.z = 0) })), this.isRotation && (this.earthGroup.rotation.y += this.options.earth.rotateSpeed), this.circleLineList.forEach((function (t) { t.rotateY(n.options.satellite.rotateSpeed) })), this.uniforms.time.value = this.uniforms.time.value < -this.timeValue ? this.timeValue : this.uniforms.time.value - 1, this.waveMeshArr.length && this.waveMeshArr.forEach((function (t) { t.userData.scale += .007, t.scale.set(t.userData.size * t.userData.scale, t.userData.size * t.userData.scale, t.userData.size * t.userData.scale), t.userData.scale <= 1.5 ? t.material.opacity = 2 * (t.userData.scale - 1) : t.userData.scale > 1.5 && t.userData.scale <= 2 ? t.material.opacity = 1 - 2 * (t.userData.scale - 1.5) : t.userData.scale = 1 })) } }], n && $u(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(); function nh(t) { return nh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, nh(t) } function rh() { rh = function () { return t }; var t = {}, e = Object.prototype, n = e.hasOwnProperty, r = "function" == typeof Symbol ? Symbol : {}, i = r.iterator || "@@iterator", a = r.asyncIterator || "@@asyncIterator", o = r.toStringTag || "@@toStringTag"; function s(t, e, n) { return Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }), t[e] } try { s({}, "") } catch (t) { s = function (t, e, n) { return t[e] = n } } function l(t, e, n, r) { var i = e && e.prototype instanceof h ? e : h, a = Object.create(i.prototype), o = new w(r || []); return a._invoke = function (t, e, n) { var r = "suspendedStart"; return function (i, a) { if ("executing" === r) throw new Error("Generator is already running"); if ("completed" === r) { if ("throw" === i) throw a; return { value: void 0, done: !0 } } for (n.method = i, n.arg = a; ;) { var o = n.delegate; if (o) { var s = x(o, n); if (s) { if (s === u) continue; return s } } if ("next" === n.method) n.sent = n._sent = n.arg; else if ("throw" === n.method) { if ("suspendedStart" === r) throw r = "completed", n.arg; n.dispatchException(n.arg) } else "return" === n.method && n.abrupt("return", n.arg); r = "executing"; var l = c(t, e, n); if ("normal" === l.type) { if (r = n.done ? "completed" : "suspendedYield", l.arg === u) continue; return { value: l.arg, done: n.done } } "throw" === l.type && (r = "completed", n.method = "throw", n.arg = l.arg) } } }(t, n, o), a } function c(t, e, n) { try { return { type: "normal", arg: t.call(e, n) } } catch (t) { return { type: "throw", arg: t } } } t.wrap = l; var u = {}; function h() { } function d() { } function f() { } var p = {}; s(p, i, (function () { return this })); var m = Object.getPrototypeOf, g = m && m(m(S([]))); g && g !== e && n.call(g, i) && (p = g); var v = f.prototype = h.prototype = Object.create(p); function _(t) { ["next", "throw", "return"].forEach((function (e) { s(t, e, (function (t) { return this._invoke(e, t) })) })) } function y(t, e) { function r(i, a, o, s) { var l = c(t[i], t, a); if ("throw" !== l.type) { var u = l.arg, h = u.value; return h && "object" == nh(h) && n.call(h, "__await") ? e.resolve(h.__await).then((function (t) { r("next", t, o, s) }), (function (t) { r("throw", t, o, s) })) : e.resolve(h).then((function (t) { u.value = t, o(u) }), (function (t) { return r("throw", t, o, s) })) } s(l.arg) } var i; this._invoke = function (t, n) { function a() { return new e((function (e, i) { r(t, n, e, i) })) } return i = i ? i.then(a, a) : a() } } function x(t, e) { var n = t.iterator[e.method]; if (void 0 === n) { if (e.delegate = null, "throw" === e.method) { if (t.iterator.return && (e.method = "return", e.arg = void 0, x(t, e), "throw" === e.method)) return u; e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method") } return u } var r = c(n, t.iterator, e.arg); if ("throw" === r.type) return e.method = "throw", e.arg = r.arg, e.delegate = null, u; var i = r.arg; return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = void 0), e.delegate = null, u) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, u) } function b(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function M(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function w(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(b, this), this.reset(!0) } function S(t) { if (t) { var e = t[i]; if (e) return e.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var r = -1, a = function e() { for (; ++r < t.length;)if (n.call(t, r)) return e.value = t[r], e.done = !1, e; return e.value = void 0, e.done = !0, e }; return a.next = a } } return { next: T } } function T() { return { value: void 0, done: !0 } } return d.prototype = f, s(v, "constructor", f), s(f, "constructor", d), d.displayName = s(f, o, "GeneratorFunction"), t.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === d || "GeneratorFunction" === (e.displayName || e.name)) }, t.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, f) : (t.__proto__ = f, s(t, o, "GeneratorFunction")), t.prototype = Object.create(v), t }, t.awrap = function (t) { return { __await: t } }, _(y.prototype), s(y.prototype, a, (function () { return this })), t.AsyncIterator = y, t.async = function (e, n, r, i, a) { void 0 === a && (a = Promise); var o = new y(l(e, n, r, i), a); return t.isGeneratorFunction(n) ? o : o.next().then((function (t) { return t.done ? t.value : o.next() })) }, _(v), s(v, o, "Generator"), s(v, i, (function () { return this })), s(v, "toString", (function () { return "[object Generator]" })), t.keys = function (t) { var e = []; for (var n in t) e.push(n); return e.reverse(), function n() { for (; e.length;) { var r = e.pop(); if (r in t) return n.value = r, n.done = !1, n } return n.done = !0, n } }, t.values = S, w.prototype = { constructor: w, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(M), !t) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (t) { if (this.done) throw t; var e = this; function r(n, r) { return o.type = "throw", o.arg = t, e.next = n, r && (e.method = "next", e.arg = void 0), !!r } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var a = this.tryEntries[i], o = a.completion; if ("root" === a.tryLoc) return r("end"); if (a.tryLoc <= this.prev) { var s = n.call(a, "catchLoc"), l = n.call(a, "finallyLoc"); if (s && l) { if (this.prev < a.catchLoc) return r(a.catchLoc, !0); if (this.prev < a.finallyLoc) return r(a.finallyLoc) } else if (s) { if (this.prev < a.catchLoc) return r(a.catchLoc, !0) } else { if (!l) throw new Error("try statement without catch or finally"); if (this.prev < a.finallyLoc) return r(a.finallyLoc) } } } }, abrupt: function (t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var i = this.tryEntries[r]; if (i.tryLoc <= this.prev && n.call(i, "finallyLoc") && this.prev < i.finallyLoc) { var a = i; break } } a && ("break" === t || "continue" === t) && a.tryLoc <= e && e <= a.finallyLoc && (a = null); var o = a ? a.completion : {}; return o.type = t, o.arg = e, a ? (this.method = "next", this.next = a.finallyLoc, u) : this.complete(o) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), u }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), M(n), u } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.tryLoc === t) { var r = n.completion; if ("throw" === r.type) { var i = r.arg; M(n) } return i } } throw new Error("illegal catch attempt") }, delegateYield: function (t, e, n) { return this.delegate = { iterator: S(t), resultName: e, nextLoc: n }, "next" === this.method && (this.arg = void 0), u } }, t } function ih(t, e, n, r, i, a, o) { try { var s = t[a](o), l = s.value } catch (t) { return void n(t) } s.done ? e(l) : Promise.resolve(l).then(r, i) } function ah(t) { return function () { var e = this, n = arguments; return new Promise((function (r, i) { var a = t.apply(e, n); function o(t) { ih(a, r, i, o, s, "next", t) } function s(t) { ih(a, r, i, o, s, "throw", t) } o(void 0) })) } } function oh(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function sh(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var lh = function () { function t(e) { var n = this; !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), sh(this, "basic", void 0), sh(this, "scene", void 0), sh(this, "camera", void 0), sh(this, "renderer", void 0), sh(this, "controls", void 0), sh(this, "sizes", void 0), sh(this, "material", void 0), sh(this, "resources", void 0), sh(this, "option", void 0), sh(this, "earth", void 0), sh(this, "jline", void 0), sh(this, "wline", void 0), this.option = e, this.basic = new Ka(e.dom), this.scene = this.basic.scene, this.renderer = this.basic.renderer, this.controls = this.basic.controls, this.camera = this.basic.camera, this.sizes = new to({ dom: e.dom }), this.sizes.$on("resize", (function () { n.renderer.setSize(Number(n.sizes.viewport.width), Number(n.sizes.viewport.height)), n.camera.aspect = Number(n.sizes.viewport.width) / Number(n.sizes.viewport.height), n.camera.updateProjectionMatrix() })), this.resources = new oo(ah(rh().mark((function t() { return rh().wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.next = 2, n.createEarth(); case 2: n.render(); case 3: case "end": return t.stop() } }), t) })))) } var e, n, r; return e = t, n = [{ key: "createEarth", value: (r = ah(rh().mark((function t() { return rh().wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return this.earth = new eh({ data: [], dom: this.option.dom, textures: this.resources.textures, earth: { radius: 50, rotateSpeed: 2e-4, isRotation: !0 }, satellite: { show: !1, rotateSpeed: -.01, size: 1, number: 2 }, punctuation: { circleColor: 3707647, lightColumn: { startColor: 14942335, endColor: 16777215 } }, flyLine: { color: 15969910, flyLineColor: 16742164, speed: .004 } }), this.scene.add(this.earth.group), t.next = 4, this.earth.init(); case 4: case "end": return t.stop() } }), t, this) }))), function () { return r.apply(this, arguments) }) }, { key: "render", value: function () { requestAnimationFrame(this.render.bind(this)), this.renderer.render(this.scene, this.camera), this.controls && this.controls.update(), this.earth && this.earth.render() } }], n && oh(e.prototype, n), Object.defineProperty(e, "prototype", { writable: !1 }), t }(), ch = { update: null, begin: null, loopBegin: null, changeBegin: null, change: null, changeComplete: null, loopComplete: null, complete: null, loop: 1, direction: "normal", autoplay: !0, timelineOffset: 0 }, uh = { duration: 1e3, delay: 0, endDelay: 0, easing: "easeOutElastic(1, .5)", round: 0 }, hh = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"], dh = { CSS: {}, springs: {} }; function fh(t, e, n) { return Math.min(Math.max(t, e), n) } function ph(t, e) { return t.indexOf(e) > -1 } function mh(t, e) { return t.apply(null, e) } var gh = { arr: function (t) { return Array.isArray(t) }, obj: function (t) { return ph(Object.prototype.toString.call(t), "Object") }, pth: function (t) { return gh.obj(t) && t.hasOwnProperty("totalLength") }, svg: function (t) { return t instanceof SVGElement }, inp: function (t) { return t instanceof HTMLInputElement }, dom: function (t) { return t.nodeType || gh.svg(t) }, str: function (t) { return "string" == typeof t }, fnc: function (t) { return "function" == typeof t }, und: function (t) { return void 0 === t }, nil: function (t) { return gh.und(t) || null === t }, hex: function (t) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t) }, rgb: function (t) { return /^rgb/.test(t) }, hsl: function (t) { return /^hsl/.test(t) }, col: function (t) { return gh.hex(t) || gh.rgb(t) || gh.hsl(t) }, key: function (t) { return !ch.hasOwnProperty(t) && !uh.hasOwnProperty(t) && "targets" !== t && "keyframes" !== t } }; function vh(t) { var e = /\(([^)]+)\)/.exec(t); return e ? e[1].split(",").map((function (t) { return parseFloat(t) })) : [] } function _h(t, e) { var n = vh(t), r = fh(gh.und(n[0]) ? 1 : n[0], .1, 100), i = fh(gh.und(n[1]) ? 100 : n[1], .1, 100), a = fh(gh.und(n[2]) ? 10 : n[2], .1, 100), o = fh(gh.und(n[3]) ? 0 : n[3], .1, 100), s = Math.sqrt(i / r), l = a / (2 * Math.sqrt(i * r)), c = l < 1 ? s * Math.sqrt(1 - l * l) : 0, u = l < 1 ? (l * s - o) / c : -o + s; function h(t) { var n = e ? e * t / 1e3 : t; return n = l < 1 ? Math.exp(-n * l * s) * (1 * Math.cos(c * n) + u * Math.sin(c * n)) : (1 + u * n) * Math.exp(-n * s), 0 === t || 1 === t ? t : 1 - n } return e ? h : function () { var e = dh.springs[t]; if (e) return e; for (var n = 1 / 6, r = 0, i = 0; ;)if (1 === h(r += n)) { if (++i >= 16) break } else i = 0; var a = r * n * 1e3; return dh.springs[t] = a, a } } function yh(t) { return void 0 === t && (t = 10), function (e) { return Math.ceil(fh(e, 1e-6, 1) * t) * (1 / t) } } var xh, bh, Mh = function () { var t = .1; function e(t, e) { return 1 - 3 * e + 3 * t } function n(t, e) { return 3 * e - 6 * t } function r(t) { return 3 * t } function i(t, i, a) { return ((e(i, a) * t + n(i, a)) * t + r(i)) * t } function a(t, i, a) { return 3 * e(i, a) * t * t + 2 * n(i, a) * t + r(i) } return function (e, n, r, o) { if (0 <= e && e <= 1 && 0 <= r && r <= 1) { var s = new Float32Array(11); if (e !== n || r !== o) for (var l = 0; l < 11; ++l)s[l] = i(l * t, e, r); return function (l) { return e === n && r === o || 0 === l || 1 === l ? l : i(function (n) { for (var o = 0, l = 1; 10 !== l && s[l] <= n; ++l)o += t; --l; var c = o + (n - s[l]) / (s[l + 1] - s[l]) * t, u = a(c, e, r); return u >= .001 ? function (t, e, n, r) { for (var o = 0; o < 4; ++o) { var s = a(e, n, r); if (0 === s) return e; e -= (i(e, n, r) - t) / s } return e }(n, c, e, r) : 0 === u ? c : function (t, e, n, r, a) { var o, s, l = 0; do { (o = i(s = e + (n - e) / 2, r, a) - t) > 0 ? n = s : e = s } while (Math.abs(o) > 1e-7 && ++l < 10); return s }(n, o, o + t, e, r) }(l), n, o) } } } }(), wh = (xh = { linear: function () { return function (t) { return t } } }, bh = { Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2) } }, Expo: function () { return function (t) { return t ? Math.pow(2, 10 * t - 10) : 0 } }, Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t) } }, Back: function () { return function (t) { return t * t * (3 * t - 2) } }, Bounce: function () { return function (t) { for (var e, n = 4; t < ((e = Math.pow(2, --n)) - 1) / 11;); return 1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2) } }, Elastic: function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = .5); var n = fh(t, 1, 10), r = fh(e, .1, 2); return function (t) { return 0 === t || 1 === t ? t : -n * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - r / (2 * Math.PI) * Math.asin(1 / n)) * (2 * Math.PI) / r) } } }, ["Quad", "Cubic", "Quart", "Quint"].forEach((function (t, e) { bh[t] = function () { return function (t) { return Math.pow(t, e + 2) } } })), Object.keys(bh).forEach((function (t) { var e = bh[t]; xh["easeIn" + t] = e, xh["easeOut" + t] = function (t, n) { return function (r) { return 1 - e(t, n)(1 - r) } }, xh["easeInOut" + t] = function (t, n) { return function (r) { return r < .5 ? e(t, n)(2 * r) / 2 : 1 - e(t, n)(-2 * r + 2) / 2 } }, xh["easeOutIn" + t] = function (t, n) { return function (r) { return r < .5 ? (1 - e(t, n)(1 - 2 * r)) / 2 : (e(t, n)(2 * r - 1) + 1) / 2 } } })), xh); function Sh(t, e) { if (gh.fnc(t)) return t; var n = t.split("(")[0], r = wh[n], i = vh(t); switch (n) { case "spring": return _h(t, e); case "cubicBezier": return mh(Mh, i); case "steps": return mh(yh, i); default: return mh(r, i) } } function Th(t) { try { return document.querySelectorAll(t) } catch (t) { return } } function Eh(t, e) { for (var n = t.length, r = arguments.length >= 2 ? arguments[1] : void 0, i = [], a = 0; a < n; a++)if (a in t) { var o = t[a]; e.call(r, o, a, t) && i.push(o) } return i } function Ah(t) { return t.reduce((function (t, e) { return t.concat(gh.arr(e) ? Ah(e) : e) }), []) } function Ch(t) { return gh.arr(t) ? t : (gh.str(t) && (t = Th(t) || t), t instanceof NodeList || t instanceof HTMLCollection ? [].slice.call(t) : [t]) } function Lh(t, e) { return t.some((function (t) { return t === e })) } function Ph(t) { var e = {}; for (var n in t) e[n] = t[n]; return e } function Rh(t, e) { var n = Ph(t); for (var r in t) n[r] = e.hasOwnProperty(r) ? e[r] : t[r]; return n } function Dh(t, e) { var n = Ph(t); for (var r in e) n[r] = gh.und(t[r]) ? e[r] : t[r]; return n } function Ih(t) { var e = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(t); if (e) return e[1] } function Oh(t, e) { return gh.fnc(t) ? t(e.target, e.id, e.total) : t } function Nh(t, e) { return t.getAttribute(e) } function zh(t, e, n) { if (Lh([n, "deg", "rad", "turn"], Ih(e))) return e; var r = dh.CSS[e + n]; if (!gh.und(r)) return r; var i = document.createElement(t.tagName), a = t.parentNode && t.parentNode !== document ? t.parentNode : document.body; a.appendChild(i), i.style.position = "absolute", i.style.width = 100 + n; var o = 100 / i.offsetWidth; a.removeChild(i); var s = o * parseFloat(e); return dh.CSS[e + n] = s, s } function Fh(t, e, n) { if (e in t.style) { var r = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), i = t.style[e] || getComputedStyle(t).getPropertyValue(r) || "0"; return n ? zh(t, i, n) : i } } function Uh(t, e) { return gh.dom(t) && !gh.inp(t) && (!gh.nil(Nh(t, e)) || gh.svg(t) && t[e]) ? "attribute" : gh.dom(t) && Lh(hh, e) ? "transform" : gh.dom(t) && "transform" !== e && Fh(t, e) ? "css" : null != t[e] ? "object" : void 0 } function kh(t) { if (gh.dom(t)) { for (var e, n = t.style.transform || "", r = /(\w+)\(([^)]*)\)/g, i = new Map; e = r.exec(n);)i.set(e[1], e[2]); return i } } function Bh(t, e, n, r) { switch (Uh(t, e)) { case "transform": return function (t, e, n, r) { var i = ph(e, "scale") ? 1 : 0 + function (t) { return ph(t, "translate") || "perspective" === t ? "px" : ph(t, "rotate") || ph(t, "skew") ? "deg" : void 0 }(e), a = kh(t).get(e) || i; return n && (n.transforms.list.set(e, a), n.transforms.last = e), r ? zh(t, a, r) : a }(t, e, r, n); case "css": return Fh(t, e, n); case "attribute": return Nh(t, e); default: return t[e] || 0 } } function Vh(t, e) { var n = /^(\*=|\+=|-=)/.exec(t); if (!n) return t; var r = Ih(t) || 0, i = parseFloat(e), a = parseFloat(t.replace(n[0], "")); switch (n[0][0]) { case "+": return i + a + r; case "-": return i - a + r; case "*": return i * a + r } } function Gh(t, e) { if (gh.col(t)) return function (t) { return gh.rgb(t) ? (n = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(e = t)) ? "rgba(" + n[1] + ",1)" : e : gh.hex(t) ? function (t) { var e = t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (function (t, e, n, r) { return e + e + n + n + r + r })), n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e); return "rgba(" + parseInt(n[1], 16) + "," + parseInt(n[2], 16) + "," + parseInt(n[3], 16) + ",1)" }(t) : gh.hsl(t) ? function (t) { var e, n, r, i = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(t), a = parseInt(i[1], 10) / 360, o = parseInt(i[2], 10) / 100, s = parseInt(i[3], 10) / 100, l = i[4] || 1; function c(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } if (0 == o) e = n = r = s; else { var u = s < .5 ? s * (1 + o) : s + o - s * o, h = 2 * s - u; e = c(h, u, a + 1 / 3), n = c(h, u, a), r = c(h, u, a - 1 / 3) } return "rgba(" + 255 * e + "," + 255 * n + "," + 255 * r + "," + l + ")" }(t) : void 0; var e, n }(t); if (/\s/g.test(t)) return t; var n = Ih(t), r = n ? t.substr(0, t.length - n.length) : t; return e ? r + e : r } function Hh(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function Wh(t) { for (var e, n = t.points, r = 0, i = 0; i < n.numberOfItems; i++) { var a = n.getItem(i); i > 0 && (r += Hh(e, a)), e = a } return r } function jh(t) { if (t.getTotalLength) return t.getTotalLength(); switch (t.tagName.toLowerCase()) { case "circle": return function (t) { return 2 * Math.PI * Nh(t, "r") }(t); case "rect": return function (t) { return 2 * Nh(t, "width") + 2 * Nh(t, "height") }(t); case "line": return function (t) { return Hh({ x: Nh(t, "x1"), y: Nh(t, "y1") }, { x: Nh(t, "x2"), y: Nh(t, "y2") }) }(t); case "polyline": return Wh(t); case "polygon": return function (t) { var e = t.points; return Wh(t) + Hh(e.getItem(e.numberOfItems - 1), e.getItem(0)) }(t) } } function qh(t, e) { var n = e || {}, r = n.el || function (t) { for (var e = t.parentNode; gh.svg(e) && gh.svg(e.parentNode);)e = e.parentNode; return e }(t), i = r.getBoundingClientRect(), a = Nh(r, "viewBox"), o = i.width, s = i.height, l = n.viewBox || (a ? a.split(" ") : [0, 0, o, s]); return { el: r, viewBox: l, x: l[0] / 1, y: l[1] / 1, w: o, h: s, vW: l[2], vH: l[3] } } function Xh(t, e, n) { function r(n) { void 0 === n && (n = 0); var r = e + n >= 1 ? e + n : 0; return t.el.getPointAtLength(r) } var i = qh(t.el, t.svg), a = r(), o = r(-1), s = r(1), l = n ? 1 : i.w / i.vW, c = n ? 1 : i.h / i.vH; switch (t.property) { case "x": return (a.x - i.x) * l; case "y": return (a.y - i.y) * c; case "angle": return 180 * Math.atan2(s.y - o.y, s.x - o.x) / Math.PI } } function Yh(t, e) { var n = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g, r = Gh(gh.pth(t) ? t.totalLength : t, e) + ""; return { original: r, numbers: r.match(n) ? r.match(n).map(Number) : [0], strings: gh.str(t) || e ? r.split(n) : [] } } function Zh(t) { return Eh(t ? Ah(gh.arr(t) ? t.map(Ch) : Ch(t)) : [], (function (t, e, n) { return n.indexOf(t) === e })) } function Kh(t) { var e = Zh(t); return e.map((function (t, n) { return { target: t, id: n, total: e.length, transforms: { list: kh(t) } } })) } function Jh(t, e) { var n = Ph(e); if (/^spring/.test(n.easing) && (n.duration = _h(n.easing)), gh.arr(t)) { var r = t.length; 2 !== r || gh.obj(t[0]) ? gh.fnc(e.duration) || (n.duration = e.duration / r) : t = { value: t } } var i = gh.arr(t) ? t : [t]; return i.map((function (t, n) { var r = gh.obj(t) && !gh.pth(t) ? t : { value: t }; return gh.und(r.delay) && (r.delay = n ? 0 : e.delay), gh.und(r.endDelay) && (r.endDelay = n === i.length - 1 ? e.endDelay : 0), r })).map((function (t) { return Dh(t, n) })) } var Qh = { css: function (t, e, n) { return t.style[e] = n }, attribute: function (t, e, n) { return t.setAttribute(e, n) }, object: function (t, e, n) { return t[e] = n }, transform: function (t, e, n, r, i) { if (r.list.set(e, n), e === r.last || i) { var a = ""; r.list.forEach((function (t, e) { a += e + "(" + t + ") " })), t.style.transform = a } } }; function $h(t, e) { Kh(t).forEach((function (t) { for (var n in e) { var r = Oh(e[n], t), i = t.target, a = Ih(r), o = Bh(i, n, a, t), s = Vh(Gh(r, a || Ih(o)), o), l = Uh(i, n); Qh[l](i, n, s, t.transforms, !0) } })) } function td(t, e) { return Eh(Ah(t.map((function (t) { return e.map((function (e) { return function (t, e) { var n = Uh(t.target, e.name); if (n) { var r = function (t, e) { var n; return t.tweens.map((function (r) { var i = function (t, e) { var n = {}; for (var r in t) { var i = Oh(t[r], e); gh.arr(i) && 1 === (i = i.map((function (t) { return Oh(t, e) }))).length && (i = i[0]), n[r] = i } return n.duration = parseFloat(n.duration), n.delay = parseFloat(n.delay), n }(r, e), a = i.value, o = gh.arr(a) ? a[1] : a, s = Ih(o), l = Bh(e.target, t.name, s, e), c = n ? n.to.original : l, u = gh.arr(a) ? a[0] : c, h = Ih(u) || Ih(l), d = s || h; return gh.und(o) && (o = c), i.from = Yh(u, d), i.to = Yh(Vh(o, u), d), i.start = n ? n.end : 0, i.end = i.start + i.delay + i.duration + i.endDelay, i.easing = Sh(i.easing, i.duration), i.isPath = gh.pth(a), i.isPathTargetInsideSVG = i.isPath && gh.svg(e.target), i.isColor = gh.col(i.from.original), i.isColor && (i.round = 1), n = i, i })) }(e, t), i = r[r.length - 1]; return { type: n, property: e.name, animatable: t, tweens: r, duration: i.end, delay: r[0].delay, endDelay: i.endDelay } } }(t, e) })) }))), (function (t) { return !gh.und(t) })) } function ed(t, e) { var n = t.length, r = function (t) { return t.timelineOffset ? t.timelineOffset : 0 }, i = {}; return i.duration = n ? Math.max.apply(Math, t.map((function (t) { return r(t) + t.duration }))) : e.duration, i.delay = n ? Math.min.apply(Math, t.map((function (t) { return r(t) + t.delay }))) : e.delay, i.endDelay = n ? i.duration - Math.max.apply(Math, t.map((function (t) { return r(t) + t.duration - t.endDelay }))) : e.endDelay, i } var nd = 0, rd = [], id = function () { var t; function e(n) { for (var r = rd.length, i = 0; i < r;) { var a = rd[i]; a.paused ? (rd.splice(i, 1), r--) : (a.tick(n), i++) } t = i > 0 ? requestAnimationFrame(e) : void 0 } return "undefined" != typeof document && document.addEventListener("visibilitychange", (function () { od.suspendWhenDocumentHidden && (ad() ? t = cancelAnimationFrame(t) : (rd.forEach((function (t) { return t._onDocumentVisibility() })), id())) })), function () { t || ad() && od.suspendWhenDocumentHidden || !(rd.length > 0) || (t = requestAnimationFrame(e)) } }(); function ad() { return !!document && document.hidden } function od(t) { void 0 === t && (t = {}); var e, n = 0, r = 0, i = 0, a = 0, o = null; function s(t) { var e = window.Promise && new Promise((function (t) { return o = t })); return t.finished = e, e } var l = function (t) { var e = Rh(ch, t), n = Rh(uh, t), r = function (t, e) { var n = [], r = e.keyframes; for (var i in r && (e = Dh(function (t) { for (var e = Eh(Ah(t.map((function (t) { return Object.keys(t) }))), (function (t) { return gh.key(t) })).reduce((function (t, e) { return t.indexOf(e) < 0 && t.push(e), t }), []), n = {}, r = function (r) { var i = e[r]; n[i] = t.map((function (t) { var e = {}; for (var n in t) gh.key(n) ? n == i && (e.value = t[n]) : e[n] = t[n]; return e })) }, i = 0; i < e.length; i++)r(i); return n }(r), e)), e) gh.key(i) && n.push({ name: i, tweens: Jh(e[i], t) }); return n }(n, t), i = Kh(t.targets), a = td(i, r), o = ed(a, n), s = nd; return nd++, Dh(e, { id: s, children: [], animatables: i, animations: a, duration: o.duration, delay: o.delay, endDelay: o.endDelay }) }(t); function c() { var t = l.direction; "alternate" !== t && (l.direction = "normal" !== t ? "normal" : "reverse"), l.reversed = !l.reversed, e.forEach((function (t) { return t.reversed = l.reversed })) } function u(t) { return l.reversed ? l.duration - t : t } function h() { n = 0, r = u(l.currentTime) * (1 / od.speed) } function d(t, e) { e && e.seek(t - e.timelineOffset) } function f(t) { for (var e = 0, n = l.animations, r = n.length; e < r;) { var i = n[e], a = i.animatable, o = i.tweens, s = o.length - 1, c = o[s]; s && (c = Eh(o, (function (e) { return t < e.end }))[0] || c); for (var u = fh(t - c.start - c.delay, 0, c.duration) / c.duration, h = isNaN(u) ? 1 : c.easing(u), d = c.to.strings, f = c.round, p = [], m = c.to.numbers.length, g = void 0, v = 0; v < m; v++) { var _ = void 0, y = c.to.numbers[v], x = c.from.numbers[v] || 0; _ = c.isPath ? Xh(c.value, h * y, c.isPathTargetInsideSVG) : x + h * (y - x), f && (c.isColor && v > 2 || (_ = Math.round(_ * f) / f)), p.push(_) } var b = d.length; if (b) { g = d[0]; for (var M = 0; M < b; M++) { d[M]; var w = d[M + 1], S = p[M]; isNaN(S) || (g += w ? S + w : S + " ") } } else g = p[0]; Qh[i.type](a.target, i.property, g, a.transforms), i.currentValue = g, e++ } } function p(t) { l[t] && !l.passThrough && l[t](l) } function m(t) { var h = l.duration, m = l.delay, g = h - l.endDelay, v = u(t); l.progress = fh(v / h * 100, 0, 100), l.reversePlayback = v < l.currentTime, e && function (t) { if (l.reversePlayback) for (var n = a; n--;)d(t, e[n]); else for (var r = 0; r < a; r++)d(t, e[r]) }(v), !l.began && l.currentTime > 0 && (l.began = !0, p("begin")), !l.loopBegan && l.currentTime > 0 && (l.loopBegan = !0, p("loopBegin")), v <= m && 0 !== l.currentTime && f(0), (v >= g && l.currentTime !== h || !h) && f(h), v > m && v < g ? (l.changeBegan || (l.changeBegan = !0, l.changeCompleted = !1, p("changeBegin")), p("change"), f(v)) : l.changeBegan && (l.changeCompleted = !0, l.changeBegan = !1, p("changeComplete")), l.currentTime = fh(v, 0, h), l.began && p("update"), t >= h && (r = 0, l.remaining && !0 !== l.remaining && l.remaining--, l.remaining ? (n = i, p("loopComplete"), l.loopBegan = !1, "alternate" === l.direction && c()) : (l.paused = !0, l.completed || (l.completed = !0, p("loopComplete"), p("complete"), !l.passThrough && "Promise" in window && (o(), s(l))))) } return s(l), l.reset = function () { var t = l.direction; l.passThrough = !1, l.currentTime = 0, l.progress = 0, l.paused = !0, l.began = !1, l.loopBegan = !1, l.changeBegan = !1, l.completed = !1, l.changeCompleted = !1, l.reversePlayback = !1, l.reversed = "reverse" === t, l.remaining = l.loop, e = l.children; for (var n = a = e.length; n--;)l.children[n].reset(); (l.reversed && !0 !== l.loop || "alternate" === t && 1 === l.loop) && l.remaining++, f(l.reversed ? l.duration : 0) }, l._onDocumentVisibility = h, l.set = function (t, e) { return $h(t, e), l }, l.tick = function (t) { i = t, n || (n = i), m((i + (r - n)) * od.speed) }, l.seek = function (t) { m(u(t)) }, l.pause = function () { l.paused = !0, h() }, l.play = function () { l.paused && (l.completed && l.reset(), l.paused = !1, rd.push(l), h(), id()) }, l.reverse = function () { c(), l.completed = !l.reversed, h() }, l.restart = function () { l.reset(), l.play() }, l.remove = function (t) { ld(Zh(t), l) }, l.reset(), l.autoplay && l.play(), l } function sd(t, e) { for (var n = e.length; n--;)Lh(t, e[n].animatable.target) && e.splice(n, 1) } function ld(t, e) { var n = e.animations, r = e.children; sd(t, n); for (var i = r.length; i--;) { var a = r[i], o = a.animations; sd(t, o), o.length || a.children.length || r.splice(i, 1) } n.length || r.length || e.pause() } od.version = "3.2.1", od.speed = 1, od.suspendWhenDocumentHidden = !0, od.running = rd, od.remove = function (t) { for (var e = Zh(t), n = rd.length; n--;)ld(e, rd[n]) }, od.get = Bh, od.set = $h, od.convertPx = zh, od.path = function (t, e) { var n = gh.str(t) ? Th(t)[0] : t, r = e || 100; return function (t) { return { property: t, el: n, svg: qh(n), totalLength: jh(n) * (r / 100) } } }, od.setDashoffset = function (t) { var e = jh(t); return t.setAttribute("stroke-dasharray", e), e }, od.stagger = function (t, e) { void 0 === e && (e = {}); var n = e.direction || "normal", r = e.easing ? Sh(e.easing) : null, i = e.grid, a = e.axis, o = e.from || 0, s = "first" === o, l = "center" === o, c = "last" === o, u = gh.arr(t), h = u ? parseFloat(t[0]) : parseFloat(t), d = u ? parseFloat(t[1]) : 0, f = Ih(u ? t[1] : t) || 0, p = e.start || 0 + (u ? h : 0), m = [], g = 0; return function (t, e, v) { if (s && (o = 0), l && (o = (v - 1) / 2), c && (o = v - 1), !m.length) { for (var _ = 0; _ < v; _++) { if (i) { var y = l ? (i[0] - 1) / 2 : o % i[0], x = l ? (i[1] - 1) / 2 : Math.floor(o / i[0]), b = y - _ % i[0], M = x - Math.floor(_ / i[0]), w = Math.sqrt(b * b + M * M); "x" === a && (w = -b), "y" === a && (w = -M), m.push(w) } else m.push(Math.abs(o - _)); g = Math.max.apply(Math, m) } r && (m = m.map((function (t) { return r(t / g) * g }))), "reverse" === n && (m = m.map((function (t) { return a ? t < 0 ? -1 * t : -t : Math.abs(g - t) }))) } return p + (u ? (d - h) / g : h) * (Math.round(100 * m[e]) / 100) + f } }, od.timeline = function (t) { void 0 === t && (t = {}); var e = od(t); return e.duration = 0, e.add = function (n, r) { var i = rd.indexOf(e), a = e.children; function o(t) { t.passThrough = !0 } i > -1 && rd.splice(i, 1); for (var s = 0; s < a.length; s++)o(a[s]); var l = Dh(n, Rh(uh, t)); l.targets = l.targets || t.targets; var c = e.duration; l.autoplay = !1, l.direction = e.direction, l.timelineOffset = gh.und(r) ? c : Vh(r, c), o(e), e.seek(l.timelineOffset); var u = od(l); o(u), a.push(u); var h = ed(a, t); return e.delay = h.delay, e.endDelay = h.endDelay, e.duration = h.duration, e.seek(0), e.reset(), e.autoplay && e.play(), e }, e }, od.easing = Sh, od.penner = wh, od.random = function (t, e) { return Math.floor(Math.random() * (e - t + 1)) + t }; const cd = od; function ud(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function hd(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function dd(t, e, n) { return e && hd(t.prototype, e), n && hd(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function fd(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var pd = new lh({ dom: document.querySelector("#earth-canvas") }), md = document.querySelector("#startConsulation"); md.addEventListener("click", (function () { md.disabled = !0, md.style.display = "none", cd({ targets: "#firstPage", opacity: 0, duration: 2e3, easing: "easeInOutQuad", complete: function () { setTimeout((function () { document.querySelector("#firstPage").style.display = "none", document.querySelector("#secondPage").style.display = "block", cd({ targets: "#secondPage", opacity: 1, duration: 1e3, easing: "easeInOutQuad" }), cd({ targets: ".secondPageTitle", duration: 1, easing: "easeInOutExpo", translateX: "-14.06vw" }) }), 500) } }), Yu.to(pd.basic.camera, { fov: 50, duration: 2, onUpdate: function () { pd.basic.camera.updateProjectionMatrix(), Yu.to(pd.basic.camera.position, { x: pd.basic.camera.position.x, y: pd.basic.camera.position.y + 40, z: pd.basic.camera.position.z, duration: 2 }), Yu.to(pd.earth.earth.position, { x: pd.earth.earth.position.x + 0, y: pd.earth.earth.position.y + 20, z: pd.earth.earth.position.z + 0, duration: 2 }) }, onComplete: function () { cd({ targets: "#earth-canvas", translateX: "40%", translateY: "50%", scale: 2, duration: 2e3, easing: "easeInOutExpo", complete: function () { console.log("Animation Complete") } }), setTimeout((function () { Yu.to(pd.basic.camera, { fov: 35, duration: 1, onUpdate: function () { pd.basic.camera.updateProjectionMatrix() } }) }), 600) } }) })); var gd, vd, _d = document.getElementById("nebulaCanvas"), yd = _d.getContext("2d"), xd = [], bd = [], Md = function () { function t() { ud(this, t), fd(this, "x", void 0), fd(this, "y", void 0), fd(this, "size", void 0), fd(this, "speed", void 0), fd(this, "brightness", void 0), this.reset() } return dd(t, [{ key: "reset", value: function () { this.x = Math.random() * gd, this.y = Math.random() * vd, this.size = 2 * Math.random() + .5, this.speed = .05 * Math.random() + .01, this.brightness = Math.random() } }, { key: "update", value: function () { this.y -= this.speed, this.y < 0 && (this.reset(), this.y = vd), this.brightness = .5 * Math.sin(Date.now() * this.speed * .01) + .5 } }, { key: "draw", value: function () { yd.beginPath(), yd.arc(this.x, this.y, this.size, 0, 2 * Math.PI), yd.fillStyle = "rgba(255, 255, 255, ".concat(this.brightness, ")"), yd.fill() } }]), t }(), wd = function () { function t() { ud(this, t), fd(this, "x", void 0), fd(this, "y", void 0), fd(this, "radius", void 0), fd(this, "color", void 0), fd(this, "points", void 0), fd(this, "angle", void 0), fd(this, "rotationSpeed", void 0), this.reset() } return dd(t, [{ key: "reset", value: function () { this.x = Math.random() * gd, this.y = Math.random() * vd, this.radius = 300 * Math.random() + 150, this.color = this.getRandomColor(), this.points = this.generatePoints(), this.angle = 0, this.rotationSpeed = .001 * (Math.random() - .5) } }, { key: "getRandomColor", value: function () { var t = ["rgba(65, 105, 225, 0.1)", "rgba(138, 43, 226, 0.1)", "rgba(255, 20, 147, 0.1)", "rgba(75, 0, 130, 0.1)", "rgba(147, 112, 219, 0.1)", "rgba(218, 112, 214, 0.1)"]; return t[Math.floor(Math.random() * t.length)] } }, { key: "generatePoints", value: function () { for (var t = 2 * Math.PI / 12, e = [], n = 0; n <= 12; n++) { var r = n * t, i = .5 * Math.random() + .5, a = Math.cos(r) * this.radius * i, o = Math.sin(r) * this.radius * i; e.push({ x: a, y: o }) } return e } }, { key: "update", value: function () { this.angle += this.rotationSpeed } }, { key: "draw", value: function () { yd.save(), yd.translate(this.x, this.y), yd.rotate(this.angle), yd.beginPath(), yd.moveTo(this.points[0].x, this.points[0].y); for (var t = 1; t < this.points.length; t++)yd.lineTo(this.points[t].x, this.points[t].y); yd.closePath(); var e = yd.createRadialGradient(0, 0, 0, 0, 0, this.radius); e.addColorStop(0, this.color), e.addColorStop(1, "transparent"), yd.fillStyle = e, yd.globalCompositeOperation = "screen", yd.fill(), yd.restore() } }]), t }(); function Sd() { gd = window.innerWidth, vd = window.innerHeight, _d.width = gd, _d.height = vd, function () { bd = []; for (var t = 0; t < 300; t++)bd.push(new Md) }(), function () { xd = []; for (var t = 0; t < 8; t++)xd.push(new wd) }() } window.addEventListener("resize", Sd), Sd(), function t() { var e; yd.clearRect(0, 0, gd, vd), (e = yd.createRadialGradient(gd / 2, vd / 2, 0, gd / 2, vd / 2, Math.max(gd, vd) / 2)).addColorStop(0, "#0c0d1d"), e.addColorStop(1, "#000000"), yd.fillStyle = e, yd.fillRect(0, 0, gd, vd), xd.forEach((function (t) { t.update(), t.draw() })), bd.forEach((function (t) { t.update(), t.draw() })), requestAnimationFrame(t) }() }(), r }() }));